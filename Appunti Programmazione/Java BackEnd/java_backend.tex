\documentclass[a4paper,11pt, oneside]{book}

% ------------------------------------------------
% LINGUA E FONT
% ------------------------------------------------
\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{eurosym}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} % Aggiunto per sicurezza sui caratteri
\usepackage[italian]{babel}
\usepackage{lmodern}
\usepackage{microtype} % Migliora notevolmente la giustificazione del testo

% ------------------------------------------------
% GRAFICA E COLORI
% ------------------------------------------------
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning, trees, fit}
\usepackage{tabularx}
\usepackage[table]{xcolor}


% ------------------------------------------------
% URL E HYPERREF (Caricato PRIMA di geometry/listings per evitare conflitti)
% ------------------------------------------------
% xurl permette di mandare a capo gli URL lunghi in qualsiasi punto
\usepackage{xurl} 
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=deepblue,
    urlcolor=javablue,
    pdftitle={Manuale Back-End Java},
    pdfauthor={Alessandro Bastianoni},
    breaklinks=true % Forza la rottura dei link lunghi
}

% ------------------------------------------------
% MARGINI
% ------------------------------------------------
\usepackage{geometry}
\geometry{
    left=2.5cm,
    right=2.5cm,
    top=3cm,
    bottom=3cm
}

% ------------------------------------------------
% DEFINIZIONE COLORI
% ------------------------------------------------
\definecolor{javablue}{rgb}{0.1, 0.3, 0.7}
\definecolor{javagreen}{rgb}{0.2, 0.6, 0.3}
\definecolor{javared}{rgb}{0.7, 0.2, 0.2}
\definecolor{intervieworange}{RGB}{255, 140, 0}
\definecolor{deepblue}{RGB}{0, 51, 102}
\definecolor{codebg}{RGB}{245, 245, 245} % Grigio chiarissimo per sfondo codice

% ------------------------------------------------
% CODICE JAVA (LISTINGS OTTIMIZZATO)
% ------------------------------------------------
\usepackage{listings}

\lstset{
    language=Java,
    basicstyle=\ttfamily\small, % Font monospaziato piccolo
    keywordstyle=\color{javablue}\bfseries,
    stringstyle=\color{javared},
    commentstyle=\color{javagreen}\itshape,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    backgroundcolor=\color{codebg},
    frame=single,
    frameround=tttt, % Angoli leggermente arrotondati
    rulecolor=\color{black!20},
    % --- GESTIONE A CAPO AUTOMATICA ---
    breaklines=true,        % Manda a capo le righe lunghe
    breakatwhitespace=false, % Manda a capo anche se non c'è spazio (es. stringhe lunghe)
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}, % Freccia rossa quando va a capo
    captionpos=b,
    tabsize=4,
    showstringspaces=false,
    keepspaces=true, % Mantiene l'indentazione quando va a capo
    columns=flexible % Migliora la copiatura del codice dal PDF
}

% ------------------------------------------------
% TCOLORBOX (BOX COLORATI)
% ------------------------------------------------
\usepackage[most]{tcolorbox}

% Box Domande da colloquio
\newtcolorbox{interview}[1]{
    colback=intervieworange!5!white, % Sfondo più chiaro per leggibilità
    colframe=intervieworange,
    fonttitle=\bfseries,
    title=Colloquio: #1,
    boxrule=1pt,
    sharp corners=downhill,
    enhanced,
    attach boxed title to top left={yshift=-2mm, xshift=2mm},
    boxed title style={colback=intervieworange, colframe=intervieworange},
    breakable, % FONDAMENTALE: Permette al box di spezzarsi su più pagine
    parbox=false % Aiuta a gestire meglio i paragrafi interni
}

% Box approfondimenti
\newtcolorbox{deepdive}[1]{
    colback=deepblue!5!white,
    colframe=deepblue,
    fonttitle=\bfseries,
    title=Deep Dive: #1,
    boxrule=1pt,
    sharp corners=downhill,
    enhanced,
    attach boxed title to top left={yshift=-2mm, xshift=2mm},
    boxed title style={colback=deepblue, colframe=deepblue},
    breakable, % FONDAMENTALE: Permette al box di spezzarsi su più pagine
    parbox=false
}

% ------------------------------------------------
% LISTE
% ------------------------------------------------
\usepackage{enumitem}
\setlist{nosep} % Riduci spazio tra elementi liste per risparmiare spazio

% ------------------------------------------------
% INFO DOCUMENTO
% ------------------------------------------------
\title{\textbf{\Huge Manuale Back-End Java}\\
\large Realizzato per Colloqui di Lavoro ed il Ripasso}
\author{Alessandro Bastianoni}
\date{\today}

\begin{document}
\sloppy 

\maketitle
\tableofcontents

\part{Fondamenti e Strumenti del Mestiere}

% -------------------------------------------------------------------
% CAPITOLO 
% -------------------------------------------------------------------

\chapter{L'Ecosistema di Sviluppo: Setup Professionale}

Prima di scrivere una sola riga di codice, un Back-End Developer deve saper configurare il proprio ambiente. Non si tratta solo di "installare Java", ma di gestire un ecosistema complesso fatto di versioni multiple, licenze diverse e variabili d'ambiente critiche per il funzionamento dei tool di build.

\section{Il Kit dello Sviluppatore: JDK vs JRE}

La prima distinzione fondamentale è tra l'ambiente di esecuzione e quello di sviluppo. Spesso i junior developer installano solo il runtime e si bloccano quando Maven non trova il compilatore.

\begin{itemize}
    \item \textbf{JRE (Java Runtime Environment)}: Contiene la JVM e le librerie standard. Serve solo per \textit{eseguire} programmi Java già compilati (es. file \texttt{.jar}).
    \item \textbf{JDK (Java Development Kit)}: È un superset della JRE. Include il compilatore (\texttt{javac}), i tool di debug, di monitoraggio (JConsole, JVisualVM) e le librerie per lo sviluppo.
\end{itemize}

\begin{interview}{Errore Classico: "javac non riconosciuto"}
    \textbf{Domanda:} "Ho installato Java, ma quando scrivo \texttt{javac -version} nel terminale il comando non viene trovato. Perché?"\\
    \textbf{Risposta:} Probabilmente hai installato solo la JRE. La JRE non contiene \texttt{javac}. Devi installare il JDK completo e assicurarti che la cartella \texttt{bin} del JDK sia aggiunta alla variabile d'ambiente \texttt{PATH} del sistema operativo.
\end{interview}

\section{Quale Java installare? Oracle vs OpenJDK}

Fino a qualche anno fa, la scelta era ovvia: Oracle JDK. Oggi, a causa dei cambi di licenza, lo standard industriale si è spostato sulle build gratuite basate su OpenJDK.

\begin{itemize}
    \item \textbf{Oracle JDK}: Richiede una licenza commerciale per uso in produzione (in molti casi).
    \item \textbf{OpenJDK}: È la reference implementation open source.
    \item \textbf{Distribuzioni Production-Ready}: Aziende come Amazon, Microsoft e la community Eclipse forniscono build di OpenJDK stabili, gratuite e con supporto a lungo termine (LTS).
    \begin{itemize}
        \item \textbf{Eclipse Temurin} (ex AdoptOpenJDK): La scelta più neutra e diffusa.
        \item \textbf{Amazon Corretto}: Ottimizzata per girare su AWS.
        \item \textbf{Azul Zulu}: Famosa per le performance e il supporto legacy.
    \end{itemize}
\end{itemize}

\section{Gestione Versioni Multiple: Mai più installazioni manuali}

Un professionista lavora spesso su più progetti contemporaneamente: un monolite legacy in Java 8, un microservizio in Java 17 e un prototipo in Java 21. Disinstallare e reinstallare Java ogni volta è impensabile.

La soluzione standard su Linux/macOS è \textbf{SDKMAN!} (Software Development Kit Manager). Su Windows si può usare PowerShell o WSL.

\begin{lstlisting}[language=bash, caption=Uso di SDKMAN per switchare versione]
# Lista tutte le versioni disponibili
sdk list java

# Installa l'ultima versione LTS di Temurin (Java 17)
sdk install java 17.0.8-tem

# Passa al volo a Java 8 per un progetto legacy
sdk use java 8.0.382-tem

# Controlla la versione attiva
java -version
\end{lstlisting}

Questo tool gestisce automaticamente il cambio delle variabili d'ambiente, permettendoti di cambiare contesto in un secondo.

\section{Le Variabili d'Ambiente: Il motore sotto il cofano}

Perché i tool come Maven, Gradle o Tomcat funzionino, il sistema operativo deve sapere \textit{dove} è installato Java.

\subsection{JAVA\_HOME}
È la variabile d'ambiente più importante. Deve puntare alla cartella radice dell'installazione del JDK (es. \texttt{/usr/lib/jvm/java-17-openjdk}).
Molti script di avvio (come quello di Tomcat o di Maven) controllano questa variabile prima di partire. Se non è settata o punta a una JRE, il build fallirà con errori criptici.

\subsection{PATH}
È una lista di directory dove il sistema operativo cerca gli eseguibili. Devi aggiungere \texttt{\%JAVA\_HOME\%/bin} (o \texttt{\$JAVA\_HOME/bin}) al PATH per poter lanciare \texttt{java} e \texttt{javac} da qualsiasi cartella nel terminale.

\begin{deepdive}{Symlinks e Wrapper}
    Sistemi operativi moderni spesso usano dei "trucchi" (Symlinks o Wrapper) per far funzionare il comando \texttt{java} anche senza settare il PATH manualmente. Tuttavia, affidarsi a questi meccanismi è rischioso per lo sviluppo. Configurare esplicitamente \texttt{JAVA\_HOME} e \texttt{PATH} garantisce che l'IDE e i tool di build usino esattamente la versione che ti aspetti, evitando il classico problema "sulla mia macchina compila ma sulla CI fallisce".
\end{deepdive}

% -------------------------------------------------------------------
% CAPITOLO 
% -------------------------------------------------------------------
\chapter{L'Ambiente di Sviluppo Integrato (IDE)}

Java è un linguaggio verboso e fortemente tipizzato. Scriverlo con un semplice editor di testo (come Notepad++ o Sublime) è tecnicamente possibile ma professionalmente suicida.
L'IDE (\textit{Integrated Development Environment}) non serve solo a colorare la sintassi: è uno strumento che comprende la struttura logica del tuo progetto, permettendo refactoring complessi e navigazione istantanea tra milioni di righe di codice.

\section{La "Guerra" degli IDE: Cosa scegliere oggi?}

Nel mercato attuale esistono tre contendenti principali. Un Senior Developer deve conoscerli per adattarsi agli standard aziendali.

\subsection{IntelliJ IDEA (JetBrains)}
Oggi è lo standard \textit{de-facto} per lo sviluppo moderno, specialmente con Spring Boot.
\begin{itemize}
    \item \textbf{Pro:} Indicizzazione profonda del codice (suggerimenti "intelligenti"), refactoring imbattibile, supporto nativo a Kotlin e Maven/Gradle.
    \item \textbf{Contro:} Pesante sulla RAM. La versione \textit{Ultimate} (a pagamento) è necessaria per il supporto completo a Spring e Database, anche se la \textit{Community} è sufficiente per iniziare.
\end{itemize}

\subsection{Eclipse IDE}
Il gigante storico. Ancora molto diffuso nella Pubblica Amministrazione, nelle banche e nei sistemi Legacy.
\begin{itemize}
    \item \textbf{Pro:} Gratuito, open-source, ecosistema di plugin infinito. Utilizza un compilatore incrementale proprietario (ECJ) che permette di eseguire codice anche in presenza di errori in altre classi.
    \item \textbf{Contro:} Interfaccia datata, gestione dei plugin spesso instabile ("DLL hell"), più lento nell'indicizzazione rispetto a IntelliJ.
\end{itemize}

\subsection{Visual Studio Code (Microsoft)}
L'astro nascente. È un editor leggero che diventa un IDE tramite estensioni (Red Hat Java, Spring Boot Tools).
\begin{itemize}
    \item \textbf{Pro:} Leggerissimo, avvio istantaneo, ottimo per ambienti polyglot (es. Backend Java + Frontend React nello stesso editor).
    \item \textbf{Contro:} Il supporto al refactoring e al debug di applicazioni Java complesse non è ancora al livello di IntelliJ.
\end{itemize}

\begin{interview}{Perché usiamo un IDE e non un Text Editor?}
    \textbf{Domanda:} "In un colloquio di System Design, ti chiedo di rinominare una classe pubblica usata in 50 file diversi. Come procedi?"\\
    \textbf{Risposta:} "Non uso mai il \textit{Find \& Replace} testuale, perché è pericoloso (potrebbe rinominare stringhe o commenti che non c'entrano). Uso la funzione di \textbf{Refactoring} dell'IDE. L'IDE conosce l'AST (Abstract Syntax Tree) del codice: sa esattamente quali riferimenti puntano a quella classe e li aggiorna in sicurezza, gestendo anche gli import e i nomi dei file."
\end{interview}

\section{Configurazione Critica: Encoding e Line Endings}

Prima di scrivere codice in un team, devi configurare l'IDE per evitare il caos nei commit Git.

\subsection{Text File Encoding: UTF-8 Ovunque}
Di default, Windows usa l'encoding \texttt{CP1252}, mentre Linux/Mac usano \texttt{UTF-8}. Se non forzi l'IDE a usare \textbf{UTF-8} per tutto (codice e properties file), i caratteri speciali (accenti, valute) si romperanno passando da un OS all'altro.
\textbf{In IntelliJ:} \texttt{Settings -> Editor -> File Encodings -> Global/Project Encoding: UTF-8}.

\subsection{Line Separators (LF vs CRLF)}
Windows termina le righe con \texttt{CRLF} (Carriage Return + Line Feed), Unix/Mac con \texttt{LF}.
Git può gestirlo automaticamente (\texttt{autocrlf}), ma è buona norma configurare l'IDE per usare solo \textbf{LF} (Unix style), evitando che i diff di Git segnino ogni riga come modificata solo perché è cambiato il carattere invisibile di fine riga.

\section{Strumenti di Produttività}

\subsection{Decompiler Integrato}
Spesso dovrai capire perché una libreria esterna lancia un errore. Non hai il codice sorgente. In IntelliJ, basta fare \texttt{CTRL+Click} su una classe di libreria: l'IDE decompila il \texttt{.class} al volo mostrandoti il codice sorgente quasi originale. È fondamentale per il debugging avanzato.

\subsection{Live Templates}
Non scrivere mai \texttt{public static void main...} a mano.
\begin{itemize}
    \item Scrivi \texttt{psvm} + Tab $\rightarrow$ genera il main.
    \item Scrivi \texttt{sout} + Tab $\rightarrow$ genera \texttt{System.out.println()}.
    \item Scrivi \texttt{iter} + Tab $\rightarrow$ genera un ciclo for-each.
\end{itemize}

\begin{deepdive}{Il file .gitignore e i file dell'IDE}
    Ogni IDE crea delle cartelle di configurazione all'interno del progetto (es. \texttt{.idea/} per IntelliJ, \texttt{.settings/} e \texttt{.classpath} per Eclipse, \texttt{.vscode/} per VS Code).
    \textbf{Regola d'oro:} Queste cartelle NON devono mai finire nel repository Git. Contengono configurazioni locali (percorsi del tuo PC) che romperebbero il progetto ai tuoi colleghi. Vanno inserite tassativamente nel file \texttt{.gitignore}.
    La configurazione del progetto deve risiedere solo nel file di build agnostico (\texttt{pom.xml} o \texttt{build.gradle}).
\end{deepdive}
% -------------------------------------------------------------------
% CAPITOLO 
% -------------------------------------------------------------------
\chapter{Scrivere Java: Sintassi, Convenzioni e Stile}

Un principio fondamentale dell'ingegneria del software è: \textit{"Il codice è scritto per essere letto dagli umani, e solo incidentalmente per essere eseguito dalle macchine."}
Java impone una struttura rigida. In questo capitolo analizzeremo l'anatomia di un file sorgente, le regole di nomenclatura (Naming Conventions) e come documentare il codice affinché sia manutenibile nel tempo.

\section{Anatomia di un file Java}

Ogni file sorgente \texttt{.java} segue una struttura gerarchica precisa.

\begin{lstlisting}[caption=Struttura tipica di una classe Java]
// 1. Dichiarazione del Package (Namespace)
package com.azienda.progetto.service;

// 2. Import (Dipendenze)
import java.util.List;
import java.util.ArrayList;

// 3. Definizione della Classe
public class UserService {

    // Campi (Stato)
    private static final int MAX_USERS = 100;
    private String serviceName;

    // Costruttore
    public UserService(String name) {
        this.serviceName = name;
    }

    // Metodi (Comportamento)
    public List<String> findAll() {
        return new ArrayList<>();
    }
}
\end{lstlisting}

\subsection{La Regola del Nome del File}
In Java esiste un vincolo fisico: una classe \texttt{public} deve essere definita in un file che ha \textbf{esattamente lo stesso nome} (case-sensitive) ed estensione \texttt{.java}.
Se la classe è \texttt{public class UserService}, il file \textbf{deve} chiamarsi \texttt{UserService.java}. Se non lo fai, il compilatore lancerà un errore.

\section{Naming Conventions: Il Codice Parla}

Java ha uno standard di nomenclatura non scritto ma universalmente accettato (definito originariamente da Sun Microsystems e poi da Google/Oracle). Violarlo ti fa apparire immediatamente inesperto agli occhi di un recruiter o di un team leader.

\begin{table}[h]
    \centering
    % Aumenta lo spazio tra le righe per migliorare la leggibilità (molto importante!)
    \renewcommand{\arraystretch}{1.5} 
    
    % La definizione della tabella:
    % l = left (adatta al contenuto)
    % >{\raggedright\arraybackslash}X = colonna elastica allineata a sinistra (evita spazi strani)
    % l = left (adatta al contenuto)
    \begin{tabularx}{\textwidth}{|l|>{\raggedright\arraybackslash}X|l|}
        \hline
        % Intestazione con colore di sfondo
        \rowcolor{deepblue!10} 
        \textbf{Elemento} & \textbf{Convenzione} & \textbf{Esempio} \\ \hline
        
        \textbf{Classi / Interfacce} & 
        \textbf{PascalCase}. Inizia con maiuscola, ogni nuova parola è maiuscola. Nomi Sostantivi. & 
        \texttt{UserService} \\ \hline
        
        \textbf{Metodi} & 
        \textbf{camelCase}. Inizia con minuscola. Verbi o azioni. & 
        \texttt{calculateTax()} \\ \hline
        
        \textbf{Variabili} & 
        \textbf{camelCase}. Corte ma significative. & 
        \texttt{userName} \\ \hline
        
        \textbf{Costanti} & 
        \textbf{UPPER\_SNAKE\_CASE}. Tutte maiuscole con underscore. & 
        \texttt{MAX\_RETRY} \\ \hline
        
        \textbf{Package} & 
        Tutto \textbf{lowercase}. Spesso usa il dominio invertito. & 
        \texttt{com.google.common} \\ \hline
        
    \end{tabularx}
    \caption{Java Naming Conventions}
\end{table}

\begin{interview}{Perché le convenzioni sono importanti?}
    \textbf{Domanda:} "Il compilatore se ne frega se chiamo una classe \texttt{userService} (minuscolo) o una variabile \texttt{USER\_NAME}. Perché dovrei seguirle?"\\
    \textbf{Risposta:} Per ridurre il \textbf{Carico Cognitivo}. Quando un programmatore Java legge \texttt{Color.RED}, sa istantaneamente (senza guardare la definizione) che \texttt{Color} è una Classe e \texttt{RED} è una Costante. Se violi le convenzioni, costringi chi legge a fermarsi e controllare, rallentando l'intero team e aumentando il rischio di bug.
\end{interview}

\section{Package e Directory Structure}

I package servono a evitare conflitti di nomi (Namespace) e a organizzare logicamente il codice.
Ma in Java, c'è un legame diretto tra nome logico e posizione fisica.

\begin{deepdive}{Il Classpath e le Cartelle}
    Se dichiari \texttt{package com.azienda.app;}, il file \textbf{deve} trovarsi fisicamente nel percorso di cartelle:
    \texttt{src/main/java/com/azienda/app/}.
    
    La JVM usa il \textbf{Classpath} come punto di partenza e poi cerca le classi scendendo nelle cartelle che corrispondono ai package. Se sposti il file senza cambiare la dichiarazione \texttt{package}, otterrai l'errore runtime: \texttt{Could not find or load main class}.
\end{deepdive}

\section{Javadoc vs Commenti: Documentare l'Intento}

Scrivere codice autodocumentante è l'obiettivo, ma a volte serve spiegare il \textit{perché} o il \textit{contratto} di un metodo.

\subsection{Commenti Implementativi (//)}
Si usano con il doppio slash \texttt{//}. Servono a spiegare passaggi complessi \textbf{dentro} un metodo.
\textit{Best Practice:} Non commentare \textit{cosa} fai (il codice lo dice già), commenta \textit{perché} lo fai.

\subsection{Javadoc (/** ... */)}
Si usa per documentare Classi e Metodi pubblici (API). Viene processato da tool esterni per generare documentazione HTML.

\begin{lstlisting}
/**
 * Calcola l'interesse composto.
 * 
 * @param amount L'importo iniziale (non può essere negativo)
 * @param rate Il tasso di interesse annuale
 * @return L'importo finale calcolato
 * @throws IllegalArgumentException se amount è negativo
 */
public BigDecimal calculateInterest(BigDecimal amount, double rate) { ... }
\end{lstlisting}

Notare come il Javadoc definisce il \textbf{Contratto}: input, output ed eccezioni. Questo è vitale per chi userà il tuo metodo senza poterne leggere il codice interno.

% -------------------------------------------------------------------
% CAPITOLO 
% -------------------------------------------------------------------
\chapter{Storia Moderna: Le Versioni LTS e le Feature Chiave}

Java non è un linguaggio statico. Dal 2017, il ciclo di rilascio è cambiato radicalmente, passando da anni di attesa a una release ogni 6 mesi.
Per un professionista, orientarsi in questa "zuppa di numeri" è fondamentale. Non devi conoscere tutte le versioni, ma devi conoscere le \textbf{LTS (Long Term Support)}.

\section{Il Ciclo di Rilascio: LTS vs Feature Release}

Oracle e la community OpenJDK hanno adottato un modello a due velocità:

\begin{itemize}
    \item \textbf{Feature Releases (ogni 6 mesi):} Versioni intermedie (es. 18, 19, 20, 22, 23, 24). Hanno vita breve (supporto di 6 mesi). Servono per testare nuove funzionalità in produzione rapida. Sconsigliate per progetti enterprise a lungo termine.
    \item \textbf{LTS - Long Term Support (ogni 2-3 anni):} Versioni stabili (8, 11, 17, 21, 25). I vendor (Oracle, Amazon, Red Hat) garantiscono patch di sicurezza per anni (anche 8-10 anni). Sono lo standard industriale.
\end{itemize}

\begin{interview}{Che versione usare in Produzione?}
    \textbf{Domanda:} "Se dovessi iniziare un nuovo progetto oggi con Spring Boot 3, quale versione di Java sceglieresti?"\\
    \textbf{Risposta:} "Sceglierei \textbf{Java 17} o \textbf{Java 21}. Spring Boot 3 richiede come minimo Java 17 (ha droppato il supporto a Java 8 e 11). Java 21 è preferibile se vogliamo sfruttare i Virtual Threads per la scalabilità, altrimenti la 17 è la scelta conservativa e ultra-stabile."
\end{interview}

\section{Java 8: LTS 2014 - Il Grande Spartiacque (Legacy)}
Rilasciato nel 2014, è stato il cambiamento più grande nella storia del linguaggio. Ha introdotto il paradigma funzionale.
\begin{itemize}
    \item \textbf{Lambda Expressions:} Funzioni anonime concise (\texttt{x -> x * 2}).
    \item \textbf{Stream API:} Elaborazione dati dichiarativa (filter, map, reduce).
    \item \textbf{Optional:} Un contenitore per evitare le \texttt{NullPointerException}.
    \item \textbf{Date/Time API:} Il pacchetto \texttt{java.time} (immutabile) che sostituisce le vecchie e buggate \texttt{Date} e \texttt{Calendar}.
\end{itemize}
\textit{Stato attuale:} Ancora molto diffuso nei sistemi legacy bancari/assicurativi, ma in fase di dismissione attiva.

\section{Java 11: LTS 2018 - La Pulizia (LTS)}
La prima LTS dopo il cambio di licenza.
\begin{itemize}
    \item \textbf{Local Variable Syntax (var):} Inferenza dei tipi per variabili locali. Rende il codice meno verboso.
    \item \textbf{Rimozione moduli Java EE:} JAXB, CORBA e altri moduli "enterprise" sono stati rimossi dal JDK standard (bisogna aggiungerli come dipendenze Maven).
    \item \textbf{HttpClient nativo:} Finalmente un client HTTP moderno e asincrono integrato nel JDK.
\end{itemize}

\begin{lstlisting}[caption=Esempio di var in Java 11]
// Prima di Java 10/11
HashMap<String, List<String>> map = new HashMap<>();

// Con Java 11
var map = new HashMap<String, List<String>>(); // Il compilatore inferisce il tipo
\end{lstlisting}

\section{Java 17: LTS 2021 - Lo Standard Moderno (LTS)}
Questa è la versione base per tutto l'ecosistema moderno (Spring Boot 3, Quarkus).
\begin{itemize}
    \item \textbf{Records (Java 14/16):} Classi immutabili "data-carrier". Sostituiscono i DTO pieni di boilerplate (getter, setter, equals, hashCode).
    \item \textbf{Text Blocks (Java 15):} Stringhe multilinea reali, utilissime per incollare JSON o SQL nel codice.
    \item \textbf{Switch Expressions:} Switch migliorato che ritorna valori e non richiede il \texttt{break}.
    \item \textbf{Pattern Matching per instanceof:} Evita il cast esplicito dopo il controllo del tipo.
\end{itemize}

\begin{lstlisting}[caption=Record e Text Block in Java 17]
// Record: Tutto (costruttore, getter, equals) in una riga
public record UserDTO(String name, String email) {}

// Text Block
String json = """
    {
      "name": "Mario",
      "city": "Roma"
    }
    """;
\end{lstlisting}

\section{Java 21: LTS 2023 - Il Futuro della Concorrenza}
Rilasciato a Settembre 2023, sta cambiando il modo in cui gestiamo i thread.
\begin{itemize}
    \item \textbf{Virtual Threads (Project Loom):} Thread ultra-leggeri gestiti dalla JVM, non dal sistema operativo. Permettono di avere milioni di thread simultanei, rendendo il codice bloccante scalabile quanto quello reattivo.
    \item \textbf{Sequenced Collections:} Nuove interfacce per accedere a primo/ultimo elemento di liste e set in modo unificato (\texttt{getFirst()}, \texttt{getLast()}).
\end{itemize}

\begin{deepdive}{Perché la migrazione da 8 a 17 è difficile?}
    Passare da Java 8 a Java 17+ non è banale. Il motivo principale è il \textbf{Module System (Project Jigsaw)} introdotto in Java 9. Questo sistema incapsula le API interne del JDK (\texttt{sun.misc.*}). Molte librerie vecchie (es. vecchie versioni di Hibernate o Lombok) usavano queste API interne e si rompono sulle nuove versioni. Migrare richiede di aggiornare tutte le dipendenze del progetto.
\end{deepdive}

\section{Java 25: LTS 2025 - Stabilità, Velocità e Semplicità}

Java 25 è l"ultima versione con supporto a lungo termine.  
Non introduce una "mega-rivoluzione" come era avvenuto con i Virtual Threads di Java 21, ma porta miglioramenti molto concreti che rendono Java più veloce, più leggero e più semplice da usare.
\begin{itemize}
    \item \textbf{Programmi più veloci da avviare.}  
    La JVM può preparare alcune ottimizzazioni in anticipo, così le applicazioni si "scaldano" più rapidamente. È utile per microservizi o programmi che devono partire spesso.
    \item \textbf{Meno memoria sprecata.}  
    Grazie agli "header compatti", ogni oggetto occupa meno spazio. Questo aumenta l"efficienza quando ci sono tante istanze in memoria (API, batch, processing di dati).
    \item \textbf{Codice più semplice per programmi piccoli.}  
    Java 25 permette di scrivere file sorgente più compatti, senza tutto il boilerplate classico. Perfetto per script, strumenti interni, esempi didattici.
    \item \textbf{Concorrenza più sicura e più pulita.}  
    Con le nuove "Scoped Values" diventa più facile far circolare informazioni tra thread senza usare meccanismi complessi. Questo si integra bene con i Virtual Threads introdotti in Java 21.
    \item \textbf{Maggiore aiuto nel capire cosa succede dentro il programma.}  
    I miglioramenti agli strumenti di diagnostica (come Flight Recorder) rendono più semplice monitorare prestazioni, colli di bottiglia e comportamenti sospetti.
    \item \textbf{Sicurezza moderna.}  
    Arrivano nuove funzioni crittografiche pronte all"uso, utili per autenticazione, cifratura, gestione di chiavi. Non serve più dipendere da librerie esterne.
\end{itemize}



\part{Il cuore di Java}

% -------------------------------------------------------------------
% CAPITOLO 
% -------------------------------------------------------------------

\chapter{Introduzione e Architettura della JVM}

Java non è solo un linguaggio, è un intero ecosistema. Per superare un colloquio tecnico, non basta saper scrivere codice: bisogna capire come questo codice viene eseguito, ottimizzato e gestito in memoria.

\section{Cos'è Java? Caratteristiche Chiave}

Java è un linguaggio di programmazione nato con una filosofia precisa: \textit{"Write Once, Run Anywhere"} (Scrivi una volta, esegui ovunque). È definito come un linguaggio di \textbf{alto livello}, \textbf{orientato agli oggetti (OOP)} e \textbf{fortemente tipizzato}.

\begin{interview}{Quali sono le caratteristiche principali di Java?}
Questa è una domanda classica per rompere il ghiaccio. Oltre alla lista standard, è importante spiegare il \textit{perché} di queste caratteristiche:

\begin{enumerate}
    \item \textbf{Platform Independent (WORA):} A differenza di C++, Java non compila in codice macchina specifico per la CPU, ma in \textbf{Bytecode}. Questo formato intermedio può essere eseguito su qualsiasi OS dotato di una JVM.
    \item \textbf{Object-Oriented (OOP):} Tutto in Java è un oggetto (tranne i tipi primitivi, anche se esistono i Wrapper). Supporta nativamente Incapsulamento, Ereditarietà, Polimorfismo e Astrazione.
    \item \textbf{Robusto e Sicuro:}
    \begin{itemize}
        \item \textit{Memory Management:} Gestisce automaticamente la memoria tramite il Garbage Collector (niente \texttt{malloc/free} o puntatori espliciti pericolosi come in C).
        \item \textit{Exception Handling:} Possiede un sistema rigoroso di gestione degli errori (Checked vs Unchecked).
    \end{itemize}
    \item \textbf{Multi-threading:} Permette l'esecuzione simultanea di più parti di codice (Thread) per massimizzare l'uso della CPU.
    \item \textbf{Rich Standard Library:} Offre API predefinite per quasi ogni necessità (Networking, I/O, Collections, Concurrency, Database).
\end{enumerate}
\end{interview}

\section{Dietro le Quinte: JDK, JRE e JVM}

Per capire come Java funzioni "dietro le quinte" e risolvere problemi di configurazione ambientale, dobbiamo distinguere tre acronimi fondamentali che formano una gerarchia inclusiva.

\begin{center}
\begin{tikzpicture}[
    node distance=0.5cm,
    box/.style={rectangle, rounded corners, draw, align=center, line width=1pt},
    label_text/.style={font=\bfseries, anchor=north west}
]
    % JDK Container
    \node[box, fill=deepblue!5, draw=deepblue, minimum width=14cm, minimum height=5cm] (jdk) {};
    \node[label_text, text=deepblue] at (jdk.north west) {JDK (Java Development Kit)};
    
    % Tools inside JDK
    \node[right=0.5cm of jdk.west, text width=2cm, align=center, font=\small] {Tools:\\\texttt{javac}\\\texttt{debugger}\\\texttt{javadoc}};

    % JRE Container
    \node[box, fill=javagreen!5, draw=javagreen, minimum width=10.5cm, minimum height=3.5cm, right=3cm of jdk.west] (jre) {};
    \node[label_text, text=javagreen] at (jre.north west) {JRE (Java Runtime Environment)};

    % Libs inside JRE
    \node[right=0.2cm of jre.west, text width=2.5cm, align=center, font=\small] {Libraries:\\\texttt{java.lang.*}\\\texttt{java.util.*}};

    % JVM Container
    \node[box, fill=javared!5, draw=javared, minimum width=7cm, minimum height=2cm, right=3cm of jre.west] (jvm) {};
    \node[label_text, text=javared] at (jvm.north west) {JVM (Java Virtual Machine)};
    
    % Content inside JVM
    \node[align=center, font=\footnotesize] at (jvm.center) {Interpreter\\Garbage Collector\\JIT Compiler};

\end{tikzpicture}
\end{center}

\begin{itemize}
    \item \textbf{JDK (Java Development Kit):} È il kit completo per gli sviluppatori.
    \begin{itemize}
        \item Contiene il compilatore (\texttt{javac}), debugger, javadoc.
        \item \textbf{Include al suo interno la JRE.}
    \end{itemize}
    
    \item \textbf{JRE (Java Runtime Environment):} È l'ambiente minimo necessario per \textit{eseguire} (non sviluppare) programmi Java.
    \begin{itemize}
        \item Contiene le librerie standard di classe Java (es. \texttt{java.lang.*}, \texttt{java.util.*}).
        \item \textbf{Include al suo interno la JVM.}
    \end{itemize}
    
    \item \textbf{JVM (Java Virtual Machine):} È il "motore" che esegue fisicamente il codice.
    \begin{itemize}
        \item Interpreta il Bytecode e lo traduce in istruzioni macchina.
        \item Gestisce la memoria (Heap/Stack) e il Garbage Collection.
        \item \textbf{Nota:} La JVM è \textit{Platform Dependent} (esiste una JVM specifica per Windows, una per Linux, una per Mac), mentre il Bytecode è \textit{Platform Independent}.
    \end{itemize}
\end{itemize}

\[ JDK \supset JRE \supset JVM \]

\section{Il ciclo di vita del codice: Compile-time vs Runtime}

\begin{interview}{Cosa succede quando compili ed esegui un programma Java?}
Il processo si divide in due fasi distinte e sequenziali. Confondere errori di compilazione con errori di runtime è un segnale di inesperienza.

\textbf{1. Compile-time (Compilazione)}
\begin{itemize}
    \item Il programmatore scrive il codice sorgente (\texttt{.java}).
    \item Il compilatore \texttt{javac} controlla la sintassi e la tipizzazione statica.
    \item Se non ci sono errori, genera il \textbf{Bytecode} (file \texttt{.class}).
\end{itemize}

\textbf{2. Runtime (Esecuzione)}
\begin{itemize}
    \item \textbf{Class Loading:} Il \textit{ClassLoader} carica i file \texttt{.class} necessari in memoria.
    \item \textbf{Bytecode Verification:} La JVM controlla che il bytecode sia sicuro e valido.
    \item \textbf{Execution:} La JVM esegue le istruzioni. Qui entra in gioco il \textbf{JIT (Just-In-Time) Compiler}.
\end{itemize}
\end{interview}

\begin{deepdive}{JIT Compiler e Performance}
Java è spesso accusato di essere lento rispetto a C++. Tuttavia, il \textbf{JIT Compiler} mitiga questo problema.
Mentre il codice viene interpretato, il JIT identifica le parti di codice eseguite più frequentemente (\textit{Hotspots}). Compila queste parti direttamente in \textbf{codice macchina nativo} (altamente ottimizzato) e lo memorizza nella Code Cache.
Risultato: Dopo una fase di "riscaldamento" (warm-up), un'applicazione Java può raggiungere performance vicine a quelle native.
\end{deepdive}

\subsection{Analisi dell'Entry Point: il metodo main}
Tutto inizia da qui. Ogni parola chiave ha un ruolo specifico per la JVM.

\begin{lstlisting}[language=Java, caption=Hello World standard]
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{public:} Modificatore di accesso. Deve essere pubblico affinché la JVM (che è esterna al programma) possa invocare questo metodo.
    \item \textbf{static:} Permette alla JVM di invocare il metodo \textit{senza dover prima istanziare un oggetto} della classe Main. Al momento dell'avvio non esistono oggetti, esiste solo la classe.
    \item \textbf{void:} Il main non restituisce alcun valore alla JVM; una volta terminato, il programma finisce (o termina il thread principale).
    \item \textbf{String[] args:} Un array di stringhe che raccoglie eventuali argomenti passati da riga di comando (es. configurazioni di avvio).
\end{itemize}

\section{Gestione della Memoria: Primitivi vs Riferimenti}
Per comprendere a fondo la differenza tra tipi primitivi e oggetti (reference types), dobbiamo guardare come Java organizza la RAM. La memoria utilizzata dalla Java Virtual Machine (JVM) è divisa principalmente in due aree logiche: lo \textbf{Stack} e lo \textbf{Heap}.

\subsection{Lo Stack (La Pila)}
Lo Stack è un'area di memoria \textit{veloce}, ordinata secondo il principio LIFO (Last In, First Out).
\begin{itemize}
    \item Ogni volta che viene invocato un metodo, viene creato un nuovo blocco di memoria chiamato \textbf{Stack Frame}.
    \item Lo Stack contiene i \textbf{tipi primitivi} locali e i \textbf{riferimenti} agli oggetti.
    \item Quando il metodo termina, il Frame viene distrutto e la memoria liberata immediatamente.
    \item È thread-safe: ogni Thread ha il proprio Stack.
\end{itemize}

\subsection{Lo Heap (Il Mucchio)}
Lo Heap è un'area di memoria molto più grande e disordinata.
\begin{itemize}
    \item Qui risiedono \textbf{tutti gli oggetti} (istanze di classi) e gli array.
    \item È condiviso tra tutti i Thread.
    \item La memoria non viene liberata automaticamente alla fine del metodo, ma è gestita dal \textbf{Garbage Collector}.
\end{itemize}

\subsection{Tipi Primitivi: Allocazione Diretta}
Quando dichiari un tipo primitivo (es. \texttt{int}, \texttt{double}, \texttt{boolean}), Java riserva lo spazio esatto in bit direttamente nello Stack Frame corrente. Il nome della variabile è associato direttamente al valore binario.

Esempio: \texttt{int x = 42;}
\begin{itemize}
    \item Nello Stack vengono allocati \textbf{4 byte} (32 bit).
    \item Il valore binario di 42 (\texttt{0000...00101010}) è scritto in quei 4 byte.
    \item Non c'è nessun overhead (peso aggiuntivo).
\end{itemize}

\subsection{Oggetti: Il Concetto di Riferimento}
Quando dichiari un oggetto, la situazione cambia drasticamente.
\begin{lstlisting}[caption={Dichiarazione di un Oggetto}]
Person p = new Person("Alessandro");
\end{lstlisting}

In questa singola riga avvengono due allocazioni distinte:
\begin{enumerate}
    \item \textbf{Nello Stack (Il Riferimento):} Viene creata la variabile \texttt{p}. Questa variabile \textbf{non contiene i dati} dell'oggetto. Contiene un indirizzo di memoria (un "puntatore" o "reference") che indica dove trovare l'oggetto nello Heap.
    \begin{itemize}
		\item Dimensione: Solitamente \textbf{4 byte}, se la JVM è 32 bit oppure usa \textit{Compressed Oops} ovvero una tecnica che consente di memorizzare i riferimenti in formato ridotto sfruttando l'allineamento della memoria, oppure \textbf{8 byte} su JVM a 64 bit senza compressione, quando sono richiesti puntatori a 64 bit completi.
    \end{itemize}
    
    \item \textbf{Nello Heap (L'Oggetto Reale):} Viene allocato spazio per l'istanza di \texttt{Person}. Qui risiedono i campi interni (es. la stringa "Alessandro").
\end{enumerate}

L'operatore \texttt{=} copia solo il contenuto dello Stack.
\begin{lstlisting}[caption={Copia di riferimenti}]
Person a = new Person("Mario");
Person b = a; 
// b ora contiene lo STESSO indirizzo di memoria di a.
// Non e' stato creato un nuovo "Mario".
// Entrambi puntano allo stesso oggetto nello Heap.
\end{lstlisting}

\begin{deepdive}{Quanto pesa davvero un Oggetto? (Byte Level)}
È un errore comune pensare che un oggetto vuoto (senza campi) occupi 0 byte. In realtà, ogni oggetto allocato nello Heap porta con sé un sovraccarico strutturale (\textit{Overhead}) gestito dalla JVM, noto come \textbf{Object Header}.

La struttura in memoria di un oggetto è composta da:
\begin{itemize}
    \item \textbf{Mark Word (4 o 8 byte):} Contiene metadati vitali come l'hashcode, i lock di sincronizzazione e i flag per il Garbage Collector. (4 byte su 32-bit, 8 byte su 64-bit).
    \item \textbf{Class Pointer (4 o 8 byte):} È il puntatore che collega l'istanza alla sua classe nel Metaspace. Su JVM a 64-bit, questo puntatore viene solitamente compresso a 4 byte (\textit{Compressed Oops}) per risparmiare memoria.
    \item \textbf{Instance Data:} I dati effettivi dei campi dell'oggetto (0 byte se l'oggetto è vuoto).
    \item \textbf{Padding:} Spazio vuoto aggiunto per rispettare l'allineamento della memoria. La JVM impone che ogni oggetto occupi un numero di byte multiplo di 8.
\end{itemize}

\textbf{Esempi di calcolo per un oggetto vuoto:}

\begin{enumerate}
    \item \textbf{Architettura 32-bit:}
    Mark Word (4) + Class Pointer (4) = \textbf{8 byte}.
    Essendo un multiplo di 8, non serve padding.
    
    \item \textbf{Architettura 64-bit (Standard - Compressed Oops attivi):}
    Mark Word (8) + Class Pointer (4) = 12 byte.
    Poiché 12 non è multiplo di 8, la JVM aggiunge 4 byte di \textit{Padding}.
    \textbf{Totale: 16 byte}.
    
    \item \textbf{Architettura 64-bit (Senza compressione):}
    Mark Word (8) + Class Pointer (8) = \textbf{16 byte}.
    Nessun padding necessario.
\end{enumerate}
\end{deepdive}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
\hline
\rowcolor{deepblue} \textbf{\textcolor{white}{Stack Memory (La "Pila")}} & \textbf{\textcolor{white}{Heap Memory (Il "Mucchio")}} \\
\hline
Usata per l'esecuzione dei metodi e il flusso del codice. & Usata per l'allocazione dinamica degli oggetti. \\
\hline
Memorizza variabili locali primitive (\texttt{int}, \texttt{double}) e i \textbf{riferimenti} agli oggetti. & Memorizza gli \textbf{Oggetti} reali (il contenuto effettivo, es. \texttt{new String("...")}). \\
\hline
Gestione LIFO (Last In, First Out). & Gestione complessa tramite Garbage Collector. \\
\hline
\textbf{Thread-Safe}: Ogni Thread ha il proprio Stack privato. & \textbf{Non Thread-Safe}: Lo Heap è condiviso tra tutti i Thread (necessita sincronizzazione). \\
\hline
Veloce, dimensione limitata (rischio \texttt{StackOverflowError}). & Più lento, dimensione grande (rischio \texttt{OutOfMemoryError}). \\
\hline
\end{tabularx}
\end{center}

\textbf{Esempio Pratico:}
\begin{lstlisting}
void metodo() {
    int x = 10;            // 'x' e 10 sono nello Stack
    Person p = new Person(); 
    // Il riferimento 'p' e' nello Stack.
    // L'oggetto reale 'Person' (con i suoi campi) e' nello Heap.
}
\end{lstlisting}


\section{Garbage Collection: Algoritmi e Tuning}

La Garbage Collection (GC) è il processo automatico di gestione della memoria nello Heap. Identifica gli oggetti non più utilizzati e libera spazio.
Un oggetto diventa "eleggibile" per il GC quando non è più \textbf{raggiungibile} (Unreachable) da nessun riferimento attivo nello Stack (GC Roots).

\subsection{GC Roots e Stack: Il punto di ancoraggio}
    Per capire cosa sia una \textbf{GC Root}, dobbiamo guardare la struttura della memoria di un Thread Java.
    
    \textbf{1. Lo Stack (La pila di esecuzione)}
    Ogni volta che esegui un metodo, Java crea un "Frame" nello \textbf{Stack}. Qui risiedono le variabili locali (es. \texttt{int x}, \texttt{User u}).
    \begin{itemize}
        \item Le variabili primitive contengono il valore direttamente.
        \item Le variabili oggetto (es. \texttt{User u}) \textbf{NON} contengono l'oggetto. Contengono solo un \textbf{indirizzo di memoria} (un puntatore).
    \end{itemize}
    
    \textbf{2. Le GC Roots}
    Quel puntatore che risiede nello Stack è una \textbf{GC Root}. È un "morsetto" che tiene ancorato l'oggetto che si trova nell'Heap. Finché il metodo è in esecuzione, quel puntatore esiste sullo Stack e l'oggetto nell'Heap è considerato "vivo".
    
    \textbf{3. Rappresentazione Grafica}
    Ecco come il GC "vede" la memoria. Nota come l'Oggetto B è morto perché nessuno Stack lo sta puntando.
    
    \vspace{0.5cm}
    \begin{center}
    \begin{tikzpicture}[
        scale=0.9, transform shape,
        stacknode/.style={rectangle, draw=deepblue, fill=white, line width=1pt, minimum width=3cm, minimum height=0.8cm, text centered, rounded corners},
        heapnode/.style={circle, draw=javared, fill=white, line width=1pt, minimum size=1.5cm, text centered, text width=1.2cm, font=\footnotesize},
        deadnode/.style={circle, draw=gray, fill=gray!10, minimum size=1.5cm, text centered, dashed, font=\footnotesize\color{gray}}
    ]

        % STACK SECTION
        \draw[fill=deepblue!5, draw=none, rounded corners] (-2, 0) rectangle (2, 5);
        \node (stacklabel) at (0, 4.5) {\textbf{\color{deepblue}STACK (GC Roots)}};
        \node[stacknode] (method2) at (0, 3.5) {\texttt{main()}};
        \node[stacknode] (var1) at (0, 2.5) {\texttt{User u1}};
        
        % HEAP SECTION
        \draw[fill=javared!5, draw=none, rounded corners] (3, 0) rectangle (10, 5);
        \node (heaplabel) at (6.5, 4.5) {\textbf{\color{javared}HEAP (Oggetti)}};
        \node[heapnode] (obj1) at (5, 3) {Obj A (Vivo)};
        \node[heapnode] (obj2) at (8, 1.5) {Obj C (Vivo)};
        
        % DEAD OBJECT
        \node[deadnode] (dead) at (5, 1) {Obj B (Morto)};

        % CONNECTIONS
        % Root 1: var1 $\rightarrow$ obj1
        \draw[->, thick, deepblue] (var1.east) -- (obj1.west) node[midway, above, font=\scriptsize, color=black] {Ref};
        
        % Reference inside Heap (A points to C)
        \draw[->, thick, javared] (obj1.south east) -- (obj2.north west) node[midway, right,  xshift=1mm, yshift=2mm, font=\scriptsize, color=black] {Ref interna};

    \end{tikzpicture}
    \end{center}
    
    \textbf{Analisi del Grafico:}
    \begin{enumerate}
        \item \textbf{Oggetto A:} È vivo perché puntato direttamente da \texttt{u1} (che è nello Stack, quindi è una GC Root).
        \item \textbf{Oggetto C:} È vivo per transizione. Lo Stack punta ad A, e A punta a C. Il GC segue la catena.
        \item \textbf{Oggetto B:} È morto. Esiste in memoria (occupa spazio), ma nessuna freccia parte dallo Stack per arrivare a lui, né direttamente né indirettamente. Al prossimo Sweep verrà rimosso.
    \end{enumerate}

\subsection{Dietro le quinte: Come decide il GC? (Mark \& Sweep)}
    Per stabilire chi deve morire, il Garbage Collector non controlla gli oggetti uno per uno chiedendo "ti serve ancora?". Sarebbe troppo lento.
    Invece, usa un algoritmo chiamato \textbf{Mark \& Sweep} (Marca e Spazza), che funziona in due fasi precise:

    \subsubsection{FASE 1: MARK (Marcatura - "Chi è vivo?")}
    Il GC fa una "fotografia" istantanea della memoria e si pone una domanda: \textit{"Quali oggetti sto sicuramente usando in questo preciso istante?"}.
    Questi oggetti sicuri si chiamano \textbf{GC Roots} (Radici) e sono essenzialmente le variabili dei metodi che sono in esecuzione ora.
    
    Il GC agisce come un verniciatore:
    \begin{enumerate}
        \item Parte dalle \textbf{Radici} e le "colora" di vivo.
        \item Guarda dentro questi oggetti: se puntano ad altri oggetti, va lì e colora anche quelli.
        \item Continua a seguire i riferimenti a catena (gli amici degli amici) finché non ha trovato e colorato tutto ciò che è collegato.
    \end{enumerate}
    Alla fine di questa fase, tutto ciò che è raggiungibile è stato "marcato".

    \subsubsection{FASE 2: SWEEP (Pulizia - "Elimina il resto")}
    Ora il GC guarda tutta la memoria rimanente. 
    Tutti gli oggetti che \textbf{non sono stati colorati} significano una cosa sola: non c'è nessuna strada che parte dal codice in esecuzione per arrivare a loro. Sono isolati.
    Quindi, vengono spazzati via brutalmente.

    \textbf{Esempio pratico:}
    Se hai \texttt{Utente u = new Utente();}, il GC parte dalla variabile \texttt{u} (Radice) e marca l'oggetto in memoria.
    Se poi scrivi \texttt{u = null;}, spezzi l'unica strada. Al prossimo passaggio, il GC partirà dalle radici, non troverà più la strada per quell'oggetto, non lo marcherà, e nella fase di Sweep lo cancellerà.

\begin{deepdive}{Stop-The-World Events}
Durante alcune fasi del GC, la JVM deve mettere in pausa \textit{tutti} i thread dell'applicazione (\textbf{Stop-The-World}). Se il GC parte troppo spesso o dura troppo a lungo, l'applicazione "si congela" (latenza alta). L'obiettivo del tuning è ridurre la durata di queste pause.
\end{deepdive}

\subsection{Le generazioni dello Heap (Young, Old, Metaspace)}

La JVM non gestisce la memoria come un blocco unico, ma la divide in zone basandosi sull'\textit{Ipotesi Generazionale Debole} (\textit{Weak Generational Hypothesis}), che afferma una verità statistica fondamentale:
\begin{quote}
    \textit{"La maggior parte degli oggetti muore giovane, mentre quelli che sopravvivono tendono a restare in vita a lungo."}
\end{quote}

Di conseguenza, lo Heap è diviso in tre aree principali per ottimizzare il Garbage Collection (GC).

\subsubsection{1. Young Generation (La "Nursery")}
È l'area dove avvengono le allocazioni e le prime fasi di vita degli oggetti. È progettata basandosi sull'ipotesi che \emph{la maggior parte degli oggetti muore giovane}.

\begin{itemize}
    \item \textbf{Eden Space:} È il punto di ingresso. Ogni volta che esegui \texttt{new Object()}, l'allocazione avviene qui.
    
    \item \textbf{Survivor Spaces (S0 e S1):} Fungono da "filtro temporale". Non vengono mai usati contemporaneamente: in ogni momento uno è attivo (\emph{From}) e l'altro è vuoto (\emph{To}).
    \begin{enumerate}
        \item Quando avviene un Minor GC, gli oggetti ancora vivi nell'Eden e nel Survivor attivo (\emph{From}) vengono copiati nel Survivor vuoto (\emph{To}).
        \item Una volta copiati, l'Eden e il \emph{From} vengono svuotati completamente.
        \item I ruoli si invertono: chi era \emph{To} diventa \emph{From} e viceversa.
        \item Ad ogni passaggio, l'età dell'oggetto (age) viene incrementata.
    \end{enumerate}

    \item \textbf{Tipo di GC:} Qui avviene il \textbf{Minor GC}. È molto frequente ed estremamente veloce perché la JVM copia solo gli oggetti vivi (pochi) e ignora quelli morti (tanti).
\end{itemize}

\begin{deepdive}{Perché il "Ping-Pong" tra S0 e S1 è utile?}
    Questa pratica di travasamento continuo serve a due scopi principali:
    
    \begin{enumerate}
        \item \textbf{Compattazione Gratuita (No Frammentazione):} 
        Invece di cercare i "buchi" lasciati dagli oggetti morti nell'Eden, la JVM copia gli oggetti vivi uno accanto all'altro nel nuovo spazio S1 (o S0). Questo mantiene la memoria contigua e rende l'allocazione futura rapidissima.
        
        \item \textbf{Aging (Invecchiamento):} 
        I Survivor Spaces agiscono come un buffer per ritardare la promozione alla \emph{Old Generation}. Se un oggetto sopravvive a un certo numero di scambi (solitamente 15, definito dal \emph{Tenuring Threshold}), viene considerato stabile e promosso. Senza S0/S1, ogni oggetto sopravvissuto all'Eden finirebbe subito nella Old Gen, riempiendola di spazzatura temporanea e causando frequenti \emph{Full GC} (che sono lenti).
    \end{enumerate}
\end{deepdive}

\subsubsection{2. Old Generation (Tenured)}
Questa è l'area di memoria destinata agli oggetti a lunga vita. Solitamente è dimensionalmente più grande della Young Generation e ospita componenti strutturali dell'applicazione (es. Cache, Singleton di Spring, Connection Pools, Sessioni Utente attive).

\begin{itemize}
    \item \textbf{Promozione (Tenuring):} Un oggetto arriva qui principalmente in due modi:
    \begin{enumerate}
        \item Ha superato la soglia di età massima (Max Tenuring Threshold) sopravvivendo a numerosi cicli nella Young Gen.
        \item È troppo grande per essere allocato nell'Eden (allocazione diretta in Old Gen per evitare copie costose).
    \end{enumerate}
    
    \item \textbf{Tipo di GC:} Qui avviene il \textbf{Major GC} (spesso parte di un Full GC).
    \begin{itemize}
        \item È un'operazione molto più lenta rispetto al Minor GC.
        \item Spesso comporta uno \textbf{"Stop-The-World"}: l'applicazione si blocca completamente finché la pulizia non è terminata.
        \item Deve gestire la \textbf{frammentazione}: mentre nella Young Gen si copiano gli oggetti (veloce), qui spesso si usa un algoritmo \emph{Mark-Sweep-Compact} (segna, pulisce e ricompatta i buchi), che richiede molto calcolo CPU.
    \end{itemize}
\end{itemize}

% Approfondimento sul flusso
\begin{deepdive}{Il Ciclo di Vita Completo di un Oggetto}
Per visualizzare l'intero viaggio di un dato all'interno della Heap, seguiamo questo flusso:
\begin{enumerate}
    \item \textbf{Nascita (Allocation):} L'oggetto viene istanziato nell'\texttt{Eden} (la maggior parte delle volte).
    
    \item \textbf{Sopravvivenza (Minor GC):} Al primo GC, se l'oggetto è ancora referenziato, viene salvato e spostato nel \textit{Survivor Space} attivo (es. S0). La sua "età" diventa 1.
    
    \item \textbf{Invecchiamento (Aging):} Ai successivi Minor GC, l'oggetto fa "ping-pong" tra S0 e S1, incrementando la sua età ad ogni passaggio.
    
    \item \textbf{Promozione (Promotion):} Una volta raggiunta la soglia critica (es. 15 cicli), viene considerato stabile e promosso nella \textbf{Old Generation}.
    
    \item \textbf{Morte (Major GC):} Se l'oggetto diventa irraggiungibile (garbage) mentre risiede nella Old Gen, non verrà rimosso subito. Rimarrà lì ad occupare spazio fino al prossimo, costoso, Major GC.
\end{enumerate}
\end{deepdive}

\subsubsection{3. Metaspace (Memoria Nativa)}
Introdotto in Java 8 per sostituire la vecchia \textit{PermGen} (Permanent Generation).
\begin{itemize}
    \item \textbf{Non è nello Heap:} Risiede nella \textit{Native Memory} del Sistema Operativo.
    \item \textbf{Cosa contiene:} I metadati delle classi (il "DNA" del codice: definizioni di metodi, nomi di variabili statiche, constant pool). In maniera sintetica le definizioni.
    \item \textbf{Vantaggio:} A differenza della PermGen che aveva una dimensione fissa (causando spesso \texttt{OutOfMemoryError}), il Metaspace può crescere automaticamente fino al limite della RAM del server (se non limitato esplicitamente).
\end{itemize}

% Box per il colloquio
\begin{interview}{PermGen vs Metaspace e Memory Leak}
\textbf{Domanda:} "Qual è la differenza tra Heap e Metaspace e quando si riempiono?"

\textbf{Risposta:}
\begin{itemize}
    \item Lo \textbf{Heap} contiene le \textit{istanze} (i dati). Si riempie se crei troppi oggetti senza rilasciarli (es. una \texttt{List} statica che cresce all'infinito). Errore: \texttt{java.lang.OutOfMemoryError: Java heap space}.
    \item Il \textbf{Metaspace} contiene le \textit{classi} (il codice). Si riempie se carichi troppe classi diverse dinamicamente (comune con framework che usano molta Reflection o CGLIB come Spring o Hibernate). Errore: \texttt{java.lang.OutOfMemoryError: Metaspace}.
\end{itemize}
\end{interview}
% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Il Ciclo di Vita del Software: Dal Codice al Runtime}

Molti sviluppatori junior pensano che il lavoro finisca quando il codice compila nell'IDE. In realtà, quello è solo l'inizio.
Per diventare un Software Engineer, devi comprendere l'intero viaggio che il codice compie: da semplice testo scritto da un umano, a istruzioni macchina eseguite da un processore su un server remoto.

In questo capitolo dissezioneremo questo processo, analizzando il Build System, la gestione delle dipendenze e l'ambiente di esecuzione (Runtime).


\section{Il formato JAR e il processo di Build}

Prima di poter avviare un'applicazione, il codice sorgente deve essere trasformato in un artefatto distribuibile. In Java, lo standard \textit{de facto} è il file \textbf{JAR} (Java ARchive).

\subsection{Che cos'è un file JAR?}
Sotto il cofano, un file \texttt{.jar} non è altro che un archivio \textbf{ZIP} che contiene:
\begin{itemize}
    \item I file \texttt{.class} (il bytecode compilato).
    \item Risorse statiche (immagini, file di configurazione \texttt{.properties} o \texttt{.xml}).
    \item I metadati all'interno della cartella \texttt{META-INF}.
\end{itemize}

Puoi letteralmente rinominare un file \texttt{app.jar} in \texttt{app.zip} e aprirlo con WinRAR o il gestore archivi del tuo OS per ispezionarne il contenuto.

\subsection{Compilazione e Packaging Manuale}
Per capire come funzionano i moderni strumenti di build, è utile vedere come si faceva "alla vecchia maniera" da riga di comando.

\subsubsection{1. Compilazione}
Il compilatore \texttt{javac} trasforma il codice leggibile dall'uomo in bytecode.
\begin{verbatim}
javac -d out src/com/example/Main.java
\end{verbatim}

\subsubsection{2. Il Manifesto (META-INF/MANIFEST.MF)}
Questo è il cuore dell'eseguibile. Senza questo file (o senza configurarlo correttamente), la JVM non saprà quale classe contiene il metodo \texttt{main} da avviare.

Un file \texttt{MANIFEST.MF} minimale per un eseguibile appare così:

\begin{lstlisting}[caption={Esempio di MANIFEST.MF}]
Manifest-Version: 1.0
Main-Class: com.example.Main
Created-By: 17.0.1 (Oracle Corporation)
\end{lstlisting}

\subsubsection{3. Packaging}
Il comando \texttt{jar} impacchetta tutto insieme:
\begin{verbatim}
jar cvfm app.jar MANIFEST.MF -C out .
\end{verbatim}
Dove le flag stanno per: \textbf{c}reate, \textbf{v}erbose, \textbf{f}ile (nome output), \textbf{m}anifest (file input).

\subsection{Build Moderni: Fat JAR vs Thin JAR}
Nel mondo enterprise moderno, raramente userai \texttt{javac} a mano. Strumenti come \textbf{Maven} o \textbf{Gradle} automatizzano il processo. Tuttavia, sorge un problema architetturale: come gestiamo le dipendenze esterne (librerie)?

Qui entra in gioco la distinzione fondamentale tra Fat JAR e Thin JAR.

\begin{deepdive}{Fat JAR (o Uber-JAR) vs Thin JAR}
Questa distinzione è cruciale quando si lavora con \textbf{Docker} e \textbf{Microservizi}.

\subsubsection{Thin JAR (Il classico)}
Contiene \textit{solo} le tue classi e risorse. Le dipendenze esterne (es. driver del DB, Spring Framework) devono essere presenti nel \textit{Classpath} della macchina che esegue il codice o in una cartella \texttt{lib} separata.
\begin{itemize}
    \item \textbf{Pro:} Il file è piccolissimo (pochi KB). Ottimo per aggiornamenti incrementali.
    \item \textbf{Contro:} "Dependency Hell". È difficile assicurarsi che l'ambiente di produzione abbia le stesse versioni delle librerie dell'ambiente di sviluppo.
\end{itemize}

\subsubsection{Fat JAR / Uber-JAR (Lo standard Cloud Native)}
Contiene le tue classi \textbf{PIÙ} tutte le dipendenze (tutti i jar delle librerie vengono estratti e rimpacchettati dentro, o inseriti come jar annidati). È l'approccio standard di \textbf{Spring Boot}.
\begin{itemize}
    \item \textbf{Pro:} "Self-contained". Basta avere la JVM installata e l'app gira ovunque (`java -jar app.jar`). Nessuna configurazione del classpath necessaria.
    \item \textbf{Contro:} Dimensioni maggiori (50MB+ per un Hello World Spring Boot).
\end{itemize}
\end{deepdive}

\begin{interview}{Differenza tra library JAR ed executable JAR}
\textbf{Domanda:} "Ho un file .jar, ma quando provo a lanciarlo mi da errore 'no main manifest attribute'. Perché?"

\textbf{Risposta:}
Stai cercando di eseguire un JAR configurato come \textbf{Libreria}, non come \textbf{Eseguibile}.
\begin{itemize}
    \item Un \textbf{Executable JAR} ha nel suo \texttt{META-INF/MANIFEST.MF} l'attributo \texttt{Main-Class} che punta alla classe contenente il \texttt{public static void main}.
    \item Un \textbf{Library JAR} è solo un contenitore di classi pensato per essere usato da altre applicazioni. Non ha un punto di ingresso (entry point).
\end{itemize}
\end{interview}

\begin{interview}{ClassNotFoundException vs NoClassDefFoundError}
\begin{itemize}
    \item \textbf{ClassNotFoundException (Checked Exception):}
    Avviene quando provi a caricare una classe dinamicamente a runtime (usando Reflection o \texttt{Class.forName("...")}) e il nome fornito non esiste nel classpath. È un errore "esplicito".
    
    \item \textbf{NoClassDefFoundError (Error - Unchecked):}
    Molto più subdolo. Succede quando la classe c'era durante la compilazione (quindi il codice compilava), ma \textbf{non c'è più} al momento dell'esecuzione (runtime). 
    Esempio tipico: Hai compilato usando la libreria A versione 2.0, ma sul server c'è la libreria A versione 1.0 che manca di quella classe. È un problema di configurazione ambientale o dipendenze corrotte (JAR Hell).
\end{itemize}
\end{interview}

\section{Il Build System: Perché usiamo Maven o Gradle?}

Immagina di voler costruire una casa. Non forgi i chiodi a mano e non tagli gli alberi per fare le assi. Vai dal fornitore e compri materiali pronti.
Nello sviluppo software, raramente scrivi tutto da zero. Usi librerie esterne (es. driver per il database, librerie per generare PDF, framework come Spring).

\subsection{L'incubo del Classpath manuale}
Senza un Build Tool, dovresti:
\begin{enumerate}
    \item Andare sui siti delle librerie e scaricare i file \texttt{.jar}.
    \item Metterli in una cartella \texttt{lib/}.
    \item Dire a Java di includerli nel Classpath manualmente.
\end{enumerate}

\vspace{0.5cm}
\textbf{Esempio Pratico Visuale:}

Immagina di avere una struttura di progetto organizzata in questo modo sul tuo computer:

\begin{lstlisting}[language=bash, caption={Struttura delle directory}, numbers=none]
IlTuoProgetto/
|-- src/
|   `-- Main.java          (Il tuo codice)
`-- lib/
    `-- commons-lang3.jar  (La libreria esterna scaricata)
\end{lstlisting}

Per compilare ed eseguire il codice includendo manualmente il file \texttt{.jar}, dovrai usare il flag \texttt{-cp} (o \texttt{-classpath}) nel terminale:

\begin{lstlisting}[language=bash, caption={Compilazione ed Esecuzione da Terminale}]
# 1. COMPILAZIONE
# Diciamo a javac: "Guarda anche nella cartella lib/ per trovare le classi"
javac -cp "lib/commons-lang3.jar" src/Main.java

# 2. ESECUZIONE
# Diciamo a java: "Il classpath è composto dalla cartella corrente (.) 
# PIÙ il jar esterno"
# NOTA: I separatori cambiano in base al Sistema Operativo (vedi sotto)
java -cp ".;lib/commons-lang3.jar" src.Main
\end{lstlisting}

\begin{deepdive}{Attenzione ai Separatori del Classpath!}
Quando concateni più percorsi nel Classpath, il separatore cambia a seconda del sistema operativo. Questo è spesso causa di errori "Class Not Found" quando si sposta codice da Windows a Linux.

\begin{itemize}
    \item \textbf{Windows}: Usa il punto e virgola (\texttt{;})\\
    Es: \texttt{-cp ".;lib/libreria.jar"}
    \item \textbf{Mac/Linux}: Usa i due punti (\texttt{:})\\
    Es: \texttt{-cp ".:lib/libreria.jar"}
\end{itemize}
\end{deepdive}

Ma c'è un problema peggiore: le \textbf{Dipendenze Transitive}.
Se usi la libreria A, e la libreria A ha bisogno della libreria B, devi scaricare anche B. E se B ha bisogno di C? È l'inferno delle dipendenze ("Dependency Hell").

\subsection{Maven al salvataggio}
Maven (o Gradle) risolve questo problema.
\begin{itemize}
    \item \textbf{POM (Project Object Model)}: È il file \texttt{pom.xml}. Qui dichiari \textbf{cosa} vuoi (es. "Voglio Spring Web versione 3.0").
    \item \textbf{Central Repository}: È un magazzino online gigantesco che contiene quasi tutte le librerie Java del mondo.
    \item \textbf{Gestione Automatica}: Maven scarica la libreria che hai chiesto, controlla di cosa ha bisogno quella libreria (dipendenze transitive) e scarica pure quelle.
\end{itemize}

\begin{interview}{Intervista: Cos'è il ciclo di vita di Maven?}
Maven non serve solo a scaricare jar. Gestisce l'intero ciclo di vita del build tramite fasi standard:
\begin{enumerate}
    \item \textbf{Clean:} Pulisce i vecchi file compilati (cartella \texttt{target}).
    \item \textbf{Compile:} Compila i sorgenti \texttt{.java} in \texttt{.class}.
    \item \textbf{Test:} Esegue gli Unit Test (JUnit). Se falliscono, il build si ferma.
    \item \textbf{Package:} Impacchetta i file compilati in un artefatto distribuibile (JAR o WAR).
    \item \textbf{Install:} Copia l'artefatto nel tuo repository locale, rendendolo disponibile ad altri tuoi progetti.
\end{enumerate}
\end{interview}

\section{Packaging: JAR vs WAR (e la rivoluzione Spring Boot)}

Una volta che il codice è compilato e testato, dobbiamo impacchettarlo per spedirlo al server. Esistono due formati principali.

\subsection{WAR (Web ARchive) - L'approccio Legacy}
Fino a pochi anni fa (era pre-Cloud), l'architettura standard era:
\begin{itemize}
    \item Compri un server fisico potente.
    \item Installi sopra un \textbf{Application Server} (come Tomcat, JBoss, WebLogic). Questo server è sempre acceso.
    \item Il tuo build produce un file \textbf{.war}.
    \item "Deploayi" il file .war dentro l'Application Server.
\end{itemize}
\textbf{Analogia:} È come un condominio (Application Server). Tu porti solo i mobili (il file WAR) e abiti in un appartamento pre-costruito.

\subsection{JAR (Java ARchive) - L'approccio Moderno (Cloud Native)}
Spring Boot ha reso popolare l'approccio "Fat Jar" (o Uber Jar).
\begin{itemize}
    \item Il build produce un file \textbf{.jar}.
    \item Questo file contiene il tuo codice, le tue dipendenze E ANCHE il server web (Tomcat Embedded).
    \item Per avviarlo non serve installare Tomcat sulla macchina. Basta avere Java: \texttt{java -jar miaopp.jar}.
\end{itemize}
\textbf{Analogia:} È come un Camper. Ha il motore e la casa tutti insieme. È autonomo e puoi spostarlo ovunque (Docker, Kubernetes) senza dipendere dall'infrastruttura esterna.

\section{Avvio di un'applicazione Java: Sotto il cofano}

Capire cosa succede esattamente quando digitiamo \texttt{java -jar app.jar} nel terminale è fondamentale per un ingegnere Back-End. Non si tratta solo di eseguire codice, ma di attivare una complessa macchina virtuale che gestisce memoria, sicurezza e ottimizzazioni in tempo reale.

Il ciclo di vita dell'avvio può essere suddiviso in fasi distinte: dal caricamento del binario del sistema operativo fino all'esecuzione del metodo \texttt{main}.

\subsection{Il comando \texttt{java} e la JNI}
Quando lanci il comando:
\begin{verbatim}
java -jar app.jar
\end{verbatim}
Il Sistema Operativo avvia un processo. Questo processo non è ancora la tua applicazione, ma il \textbf{launcher} della JVM (scritto solitamente in C/C++).
\begin{itemize}
    \item Il launcher analizza gli argomenti della riga di comando (es. opzioni \texttt{-Xmx}, \texttt{-Dproperty}).
    \item Carica la libreria dinamica della JVM (es. \texttt{jvm.dll} su Windows o \texttt{libjvm.so} su Linux).
    \item Inizializza la \textbf{Java Native Interface (JNI)}, il ponte che permette al mondo C++ di creare un'istanza della Java Virtual Machine.
\end{itemize}

\subsection{Class Loading: Portare il Codice in Vita}

Per capire il \textit{Class Loading}, dobbiamo prima sfatare un mito: quando avvii un programma Java, la JVM \textbf{non} carica tutto il tuo codice in memoria immediatamente. Se il tuo progetto ha 10.000 classi ma ne usi solo 3, caricarle tutte sarebbe uno spreco enorme di RAM e tempo di avvio.

\subsubsection{Cos'è quindi il Class Loading?}
Immagina i file \texttt{.class} (il bytecode compilato) come dei libri chiusi in una biblioteca (il tuo Hard Disk). La JVM è lo studioso.
\begin{enumerate}
    \item Il "Caricamento" avviene quando lo studioso prende un libro dallo scaffale e lo apre sulla scrivania (la Memoria RAM).
    \item Solo quando il libro è aperto, lo studioso può leggerne le istruzioni e creare oggetti.
\end{enumerate}

Questo approccio si chiama \textbf{Lazy Loading} (Caricamento Pigro): Java carica una classe in memoria solo nell'esatto istante in cui viene menzionata per la prima volta nel codice (es. quando fai \texttt{new MioOggetto()}).

\begin{deepdive}{Come funziona la Gerarchia (Chi carica cosa?)}
    Java non butta tutte le classi in un unico calderone. Usa dei "magazzinieri" specializzati chiamati \textbf{ClassLoader}, organizzati gerarchicamente.
    
    Il principio fondamentale è la \textbf{Delega al Genitore}: quando serve una classe, il magazziniere più in basso (il tuo) chiede prima al suo capo se ce l'ha lui. Se il capo ce l'ha, bene. Se il capo non ce l'ha, il magazziniere prova a cercarla da solo.
    
    Ecco i tre livelli, dal "Capo Supremo" all'ultimo arrivato:
    
    \begin{description}
        \item[\textcolor{deepblue}{1. Bootstrap ClassLoader (Il Capo Supremo)}] 
        Carica le classi vitali per la sopravvivenza di Java (es. \texttt{String}, \texttt{Integer}, \texttt{List}). 
        \begin{itemize}
            \item \textbf{Curiosità:} È scritto in C++ (nativo), non in Java. Per questo, se provi a stampare il ClassLoader di una Stringa, ottieni \texttt{null}: la JVM non sa rappresentarlo come oggetto Java.
        \end{itemize}
        
        \item[\textcolor{deepblue}{2. Platform ClassLoader (Il Manager)}] 
        È figlio del Bootstrap. Carica le librerie standard aggiuntive che fanno parte del JDK ma non del nucleo vitale (es. \texttt{java.sql.*} per i database o classi XML).
        
        \item[\textcolor{deepblue}{3. Application ClassLoader (L'Operaio)}] 
        È figlio del Platform. Questo è quello che carica \textbf{il tuo codice} e le librerie esterne (i \texttt{.jar}) che hai aggiunto al progetto (il famoso \textit{Classpath}).
    \end{description}
\end{deepdive}

\begin{interview}{Perché la delega è importante?}
    Domanda tipica: \textit{"Perché Java usa questo modello a delega?"}
    \\
    \textbf{Risposta:} Per \textbf{Sicurezza}. 
    Se tu creassi nel tuo progetto una classe maligna chiamandola \texttt{java.lang.String}, il sistema di delega proteggerebbe la JVM.
    
    Quando il tuo codice chiede "dammi \texttt{String}", la richiesta sale fino al \textit{Bootstrap ClassLoader}. Lui troverà la \textit{vera} Stringa di Java e restituirà quella, ignorando completamente la tua versione maligna. Senza delega, potresti sovrascrivere le classi base del linguaggio!
\end{interview}

\vspace{0.5cm}
\textbf{Esempio Pratico:}
Questo codice interroga le classi per chiedere: "Chi ti ha portato in memoria?".

\begin{lstlisting}[caption={Analisi dei ClassLoader a Runtime}]
public class ChiMiHaCaricato {
    public static void main(String[] args) {
        
        // 1. Chiediamo a una classe creata da noi
        // Risposta attesa: AppClassLoader (perché è codice nostro)
        System.out.println("Mio Codice: " + 
            ChiMiHaCaricato.class.getClassLoader());

        // 2. Chiediamo a una libreria standard (es. SQL)
        // Risposta attesa: PlatformClassLoader (estensione JDK)
        System.out.println("SQL: " + 
            java.sql.SQLData.class.getClassLoader());

        // 3. Chiediamo a una classe base (String)
        // Risposta attesa: null (Bootstrap, scritto in C++)
        System.out.println("String: " + 
            String.class.getClassLoader());
    }
}
\end{lstlisting}

\subsection{Linking (Collegamento)}
Dopo che una classe è stata caricata (il file \texttt{.class} è stato letto), deve passare attraverso la fase di Linking, divisa in tre sotto-fasi:

\begin{enumerate}
    \item \subsubsection{Verification (Verifica)}
    È la fase più complessa e importante per la sicurezza. Il \textit{Bytecode Verifier} controlla che il codice non violi le regole della JVM (es. non saltare a istruzioni inesistenti, non causare overflow dello stack, rispetto dei tipi). Se questa fase fallisce, viene lanciato un \texttt{java.lang.VerifyError}.
    
    \item \subsubsection{Preparation (Preparazione)}
    La JVM alloca la memoria per le variabili statiche della classe e le inizializza ai valori di default (0 per gli interi, \texttt{null} per i riferimenti, \texttt{false} per i booleani). \textbf{Nota:} In questa fase non viene ancora eseguito il tuo codice di inizializzazione, solo i default della JVM.
    
    \item \subsubsection{Resolution (Risoluzione)}
    I riferimenti simbolici nel bytecode (nomi di classi, interfacce, campi) vengono sostituiti con riferimenti diretti alla memoria (puntatori).
\end{enumerate}

\subsection{Initialization (Inizializzazione)}
Questa è la prima fase in cui il tuo codice viene effettivamente eseguito. La JVM esegue il blocco di inizializzazione statico della classe (\texttt{<clinit>}).

\begin{lstlisting}[caption={Ordine di esecuzione all'avvio}]
public class StartupExample {
    // 1. Questo viene eseguito durante la fase di Initialization
    static {
        System.out.println("Blocco statico: Classe caricata e inizializzata.");
    }

    // 2. Il main viene chiamato solo DOPO l'inizializzazione della classe
    public static void main(String[] args) {
        System.out.println("Metodo Main: Inizio esecuzione applicazione.");
    }
}
\end{lstlisting}

\subsection{Esecuzione: Interprete e JIT}
Dopo aver inizializzato la classe principale, la JVM invoca il metodo \texttt{public static void main(String[] args)}.
Inizialmente, il bytecode viene letto ed eseguito da un \textbf{Interprete} (riga per riga). È veloce da avviare, ma lento nell'esecuzione prolungata.

Qui entra in gioco il \textbf{Just-In-Time (JIT) Compiler}:
\begin{itemize}
    \item La JVM monitora quali metodi vengono eseguiti più spesso ("Hot Spots").
    \item Il JIT compila questi "pezzi caldi" di bytecode in codice macchina nativo ottimizzato per la CPU specifica.
    \item Da quel momento in poi, viene eseguito direttamente il codice nativo, bypassando l'interprete.
\end{itemize}

\begin{interview}{Java è compilato o interpretato?}
Questa è una domanda trabocchetto classica. La risposta corretta è: \textbf{Entrambi}.

\begin{itemize}
    \item Il codice sorgente (\texttt{.java}) viene \textbf{compilato} staticamente da \texttt{javac} in Bytecode (\texttt{.class}).
    \item Il Bytecode è intermedio e indipendente dalla piattaforma.
    \item A runtime, la JVM agisce come un \textbf{interprete} per il bytecode.
    \item Tuttavia, grazie al compilatore \textbf{JIT} (Just-In-Time), le parti di codice eseguite frequentemente vengono compilate dinamicamente in codice macchina nativo per massimizzare le performance.
\end{itemize}
\end{interview}

\subsection{Shutdown (Terminazione)}
L'applicazione Java continua a girare finché esiste almeno un \textbf{Non-Daemon Thread} attivo.
\begin{itemize}
    \item Il thread \texttt{main} è un thread non-daemon.
    \item Se il \texttt{main} finisce, ma hai avviato altri thread utente (non-daemon), la JVM non si chiude.
    \item Quando l'ultimo thread non-daemon termina, la JVM inizia la procedura di shutdown, eseguendo eventuali \textit{Shutdown Hooks} (usati ad esempio da Spring Boot per chiudere le connessioni al database gentilmente) e rilasciando la memoria al sistema operativo.
\end{itemize}

\begin{deepdive}{System.exit(0) vs Runtime Exception}
\begin{itemize}
    \item \texttt{System.exit(n)}: Forza la chiusura immediata della JVM. L'argomento \texttt{n} è lo status code (0 = ok, altro = errore). Questo comando ferma tutto, anche se ci sono thread attivi.
    \item \texttt{RuntimeException}: Se un'eccezione non gestita risale fino al \texttt{main}, quel thread muore. Se è l'unico thread non-daemon, la JVM si spegne con uno stack trace.
\end{itemize}
\end{deepdive}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Variabili, Tipi di Dati e Operatori}

Una comprensione superficiale dei tipi di dati porta a bug subdoli (come \texttt{NullPointerException} o errori di precisione). In questo capitolo analizziamo come Java gestisce i dati a basso livello.

\section{Tipi Primitivi vs Reference: La gestione in memoria}

Java è un linguaggio \textbf{Strongly Typed}: ogni variabile deve avere un tipo dichiarato. Esistono due macro-categorie:

\subsection{Tipi Primitivi (Primitive Data Types)}
Sono i "mattoni" del linguaggio. Non sono oggetti, contengono direttamente il valore nello Stack e hanno performance elevate.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Tipo} & \textbf{Bit} & \textbf{Range / Valore} & \textbf{Default (Campi)} \\
\hline
\texttt{boolean} & - & \texttt{true}, \texttt{false} & \texttt{false} \\
\texttt{byte} & 8 & -128 a 127 & 0 \\
\texttt{short} & 16 & -32,768 a 32,767 & 0 \\
\texttt{char} & 16 & Unicode (unsigned) & \texttt{'{\textbackslash}u0000'}\\
\texttt{int} & 32 & $\approx \pm 2$ miliardi & 0 \\
\texttt{long} & 64 & Molto grande (suffisso \texttt{L}) & 0L \\
\texttt{float} & 32 & Virgola mobile (suffisso \texttt{f}) & 0.0f \\
\texttt{double} & 64 & Virgola mobile doppia prec. & 0.0d \\
\hline
\end{tabular}
\caption{Tipi Primitivi in Java}
\end{table}

\textbf{Regola di Inizializzazione:}
\begin{itemize}
    \item \textbf{Campi di istanza (Fields):} Se non inizializzati, assumono il valore di default (vedi tabella).
    \item \textbf{Variabili Locali (dentro i metodi):} \textbf{Non} hanno valore di default. Il compilatore darà errore se provi a usarle senza aver assegnato un valore.
\end{itemize}

\section{Numeri Decimali: Float, Double e BigDecimal}

In Java, i tipi primitivi per i numeri con la virgola sono \texttt{float} (32 bit) e \texttt{double} (64 bit). Tuttavia, il loro comportamento nasconde insidie che ogni sviluppatore Back-End deve conoscere, specialmente quando si tratta di precisione.

\begin{deepdive}{Sotto il cofano: IEEE 754 e la Mantissa}
    I computer non salvano i numeri decimali come facciamo noi (es. 12.5), ma utilizzano uno standard chiamato \textbf{IEEE 754}. Questo standard rappresenta i numeri in notazione scientifica binaria:
    \[ V = (-1)^S \times M \times 2^E \]
    Dove:
    \begin{itemize}
        \item \textbf{S (Sign):} 1 bit per il segno (+ o -).
        \item \textbf{E (Exponent):} L'esponente che "sposta" la virgola (8 bit per float, 11 per double).
        \item \textbf{M (Mantissa):} La parte frazionaria significativa (23 bit per float, 52 per double).
    \end{itemize}
    
    \textbf{Il problema della precisione:}
    Così come in base 10 non possiamo scrivere esattamente $1/3$ (che diventa $0.3333...$), in base 2 (binario) non è possibile rappresentare esattamente numeri apparentemente semplici come \textbf{0.1} o \textbf{0.2}.
    Questi numeri diventano periodici in binario. Poiché la mantissa ha un numero finito di bit, il computer è costretto a "tagliare" e arrotondare il numero, introducendo un piccolo errore di approssimazione.
\end{deepdive}

\subsection{Perché usiamo la 'f'?}
In Java, qualsiasi numero decimale scritto nel codice (es. \texttt{3.14}) viene interpretato di default come \textbf{double}.
Un \texttt{double} occupa 64 bit, mentre un \texttt{float} ne occupa solo 32. Se proviamo ad assegnare un double a un float senza specificarlo, il compilatore da errore perché stiamo cercando di infilare un dato grande in un contenitore piccolo (possibile perdita di dati).
Il suffisso \texttt{f} (o \texttt{F}) dice esplicitamente al compilatore: \textit{"Tratta questo letterale come un float a 32 bit"}.

\begin{lstlisting}
// Errore di compilazione: 3.14 e' double
float pi = 3.14; 

// Corretto: forziamo il tipo float
float pi = 3.14f; 
\end{lstlisting}

\subsection{Il problema di Float e Double}
A causa del funzionamento della mantissa spiegato sopra, le operazioni aritmetiche possono dare risultati inaspettati.

\begin{lstlisting}[caption={Errore di precisione aritmetica}]
double a = 0.1;
double b = 0.2;
double somma = a + b;

System.out.println(somma); 
// STAMPA: 0.30000000000000004 (Non e' 0.3!)
\end{lstlisting}

\subsection{La Soluzione: BigDecimal}
Per calcoli che richiedono precisione assoluta (come calcoli finanziari, tasse, coordinate GPS precise), Java offre la classe \texttt{java.math.BigDecimal}.

\textbf{Cosa ha di speciale?}
\begin{itemize}
    \item \textbf{Precisione Arbitraria:} Non usa l'approssimazione binaria IEEE 754. Memorizza il numero come un \textit{intero non scalato} (un \texttt{BigInteger} enorme) e un intero che rappresenta la \textit{scala} (dove mettere la virgola). È come se memorizzasse "123" e "sposta la virgola di 2 a sinistra" per ottenere 1.23.
    \item \textbf{Immutabilità:} Come le Stringhe, le operazioni su BigDecimal non modificano l'oggetto corrente ma ne restituiscono uno nuovo.
    \item \textbf{Controllo sugli arrotondamenti:} Permette di specificare esattamente come arrotondare (per eccesso, per difetto, verso pari, ecc.).
\end{itemize}

\begin{lstlisting}[caption={Uso corretto di BigDecimal}]
// ATTENZIONE: Usare sempre il costruttore Stringa!
// new BigDecimal(0.1) porterebbe dentro l'errore del double.
BigDecimal bd1 = new BigDecimal("0.1");
BigDecimal bd2 = new BigDecimal("0.2");

BigDecimal risultato = bd1.add(bd2);

System.out.println(risultato); // STAMPA: 0.3
\end{lstlisting}

\begin{interview}{Float/Double vs BigDecimal per i soldi}
    \textbf{Domanda:} "In un e-commerce, quale tipo di dato useresti per rappresentare il prezzo dei prodotti?"
    
    \textbf{Risposta:} "Non userei mai \texttt{float} o \texttt{double} a causa degli errori di arrotondamento della virgola mobile (IEEE 754), che su grandi volumi portano a perdite finanziarie. Utilizzerei \texttt{BigDecimal} per la massima precisione decimale, oppure in alcuni casi un \texttt{long} rappresentando il valore in centesimi (es. 1000 invece di 10.00) per performance migliori, convertendo solo in fase di visualizzazione."
\end{interview}

\section{Gestire i Soldi con Long (Centesimi)}

Una valida alternativa a \texttt{BigDecimal} per le performance è l'uso dei tipi interi (\texttt{long}), rappresentando tutto nell'unità più piccola della valuta (es. centesimi per Euro/Dollari, Yen interi, Satoshi per Bitcoin).

\textbf{Esempio:} \euro 10.50 diventa \texttt{1050} (long).

Tuttavia, questo approccio si scontra con un muro matematico durante le divisioni: la divisione intera tronca i decimali.

\subsection{Il problema del centesimo sparito}
Immaginiamo di dover dividere \euro 1.00 (\texttt{100} centesimi) tra 3 persone.

\begin{lstlisting}
long totale = 100;
long persone = 3;

long quota = totale / persone; 
// Risultato: 33 (divisione intera)

long sommaFinale = quota * 3; 
// Risultato: 99. Manca 1 centesimo!
\end{lstlisting}

In finanza, il denaro non può essere distrutto né creato. Quel centesimo deve andare a qualcuno.

\begin{deepdive}{Algoritmo di Allocazione del Resto}
    Quando la divisione non è intera, la soluzione standard è calcolare il \textbf{resto} (operatore modulo \texttt{\%}) e distribuirlo un centesimo alla volta ai beneficiari finché non finisce.
    
    La formula logica è:
    \begin{enumerate}
        \item \textbf{Base Share:} \texttt{totale / n} (quanto spetta a tutti come minimo).
        \item \textbf{Remainder:} \texttt{totale \% n} (i centesimi avanzati).
        \item \textbf{Distribuzione:} I primi \textit{Remainder} utenti ricevono \texttt{Base + 1}, gli altri solo \texttt{Base}.
    \end{enumerate}
\end{deepdive}

Ecco come implementare una funzione utility sicura per dividere importi monetari interi:

\begin{lstlisting}[caption={Divisione Monetaria con Distribuzione del Resto}]
/**
 * Divide un importo in centesimi in N parti.
 * Distribuisce il resto ai primi beneficiari.
 */
public static long[] dividiImporto(long amount, int parti) {
    long[] risultati = new long[parti];
    
    long quotaBase = amount / parti; // Es. 100 / 3 = 33
    long resto = amount \% parti;     // Es. 100 % 3 = 1
    
    for (int i = 0; i < parti; i++) {
        // Assegna la quota base
        risultati[i] = quotaBase;
        
        // Se c'e' ancora resto, dai 1 centesimo in piu' a questo utente
        if (resto > 0) {
            risultati[i]++;
            resto--;
        }
    }
    
    return risultati; 
    // Ritorna: [34, 33, 33] -> Totale: 100. Nulla e' andato perso.
}
\end{lstlisting}

\subsection{Percentuali e Moltiplicazioni con i Long}
Quando si calcolano percentuali (es. sconti o IVA) usando i \texttt{long}, l'ordine delle operazioni è fondamentale: bisogna sempre \textbf{moltiplicare prima} e \textbf{dividere poi}. Se si dividesse prima, si perderebbe immediatemente la precisione a causa del troncamento intero.

Prendiamo come esempio il calcolo del 15\% di \euro 50.05, che in centesimi corrisponde a \texttt{5005}:

\begin{enumerate}
    \item \textbf{Moltiplicazione:} $5005 \times 15 = 75075$.
    \item \textbf{Divisione (Problematico):} $75075 / 100 = 750$.
\end{enumerate}

Il risultato matematico esatto sarebbe $750.75$. La divisione intera di Java tronca sempre verso zero, restituendo \texttt{750} (\euro 7.50). Tuttavia, in ambito commerciale, $750.75$ dovrebbe essere arrotondato a \texttt{751} (\euro 7.51).

\textbf{La tecnica del "+ Metà Divisore"}
Per ottenere l'arrotondamento aritmetico classico (\textit{Round Half Up}: da .5 in su si arrotonda per eccesso) lavorando solo con interi positivi, si aggiunge la metà del divisore al numeratore \textit{prima} di dividere.
Poiché dividiamo per 100 (percentuale), la metà è 50.

\[ \text{Risultato} = \frac{(\text{Valore} \times \text{Percentuale}) + 50}{100} \]

Applicandolo al nostro esempio:
\[ \text{Risultato} = \frac{75075 + 50}{100} = \frac{75125}{100} = 751 \]

Ora il risultato è \textbf{751} centesimi, ovvero l'arrotondamento corretto.

\begin{deepdive}{Nota sulla Terminologia}
    Questa formula implementa l'\textbf{Arrotondamento Commerciale} (Round Half Up).
    Spesso si confonde con lo "Standard Bancario" (\textit{Round Half to Even}), che invece arrotonda al numero pari più vicino (es. 2.5 diventa 2, 3.5 diventa 4) per ridurre l'accumulo di errori statistici. Per ottenere il vero comportamento bancario o gestire numeri negativi, questa formula semplice non basta e serve una logica condizionale più complessa.
\end{deepdive}

\begin{interview}{Long vs BigDecimal: Cosa scegliere?}
    \textbf{Domanda:} "In un sistema ad alta frequenza (HFT), useresti BigDecimal?"
    
    \textbf{Risposta:} "Probabilmente no. \texttt{BigDecimal} crea molti oggetti in memoria (è immutabile) e ha un overhead di CPU. In sistemi Real-Time o Low-Latency, si preferisce usare \texttt{long} (centesimi o millesimi di centesimo) per sfruttare le istruzioni native della CPU ed evitare la Garbage Collection frequente. Tuttavia, per applicazioni Enterprise standard (gestionali, e-commerce), la sicurezza e la leggibilità di \texttt{BigDecimal} vincono sulle micro-ottimizzazioni."
\end{interview}

\begin{interview}{Perché non si usa mai \texttt{double} per i soldi?}
I tipi a virgola mobile (\texttt{float}, \texttt{double}) seguono lo standard IEEE 754, che è pensato per la velocità scientifica, non per la precisione assoluta.
Esempio classico:
\begin{lstlisting}
double a = 0.1;
double b = 0.2;
System.out.println(a + b); // Stampa 0.30000000000000004
\end{lstlisting}
Quell'errore infinitesimale, su milioni di transazioni, crea buchi di bilancio.
\textbf{Soluzione:} Usare sempre \textbf{\texttt{java.math.BigDecimal}}.
\end{interview}

\begin{itemize}
    \item \textbf{Costruttore:} Usare sempre il costruttore \textbf{String} o \texttt{valueOf}. Mai quello double.
    \begin{lstlisting}
    BigDecimal safe = new BigDecimal("0.1"); // Corretto
    BigDecimal unsafe = new BigDecimal(0.1); // Pericoloso (include l'imprecisione del double)
    BigDecimal preferred = BigDecimal.valueOf(0.1); // Corretto (chiama toString internamente)
    \end{lstlisting}
    
    \item \textbf{Immutabilità:} \texttt{BigDecimal} è immutabile (come String). Le operazioni restituiscono nuovi oggetti.
    \begin{lstlisting}
    BigDecimal b1 = new BigDecimal("10");
    b1.add(new BigDecimal("5")); // Errore! Il risultato viene perso
    b1 = b1.add(new BigDecimal("5")); // Corretto
    \end{lstlisting}
    
    \item \textbf{Confronti:} Mai usare \texttt{equals()} per confrontare valori numerici, perché controlla anche la scala (numero di decimali).
    \begin{lstlisting}
    BigDecimal x = new BigDecimal("1.0");
    BigDecimal y = new BigDecimal("1.00");
    x.equals(y);      // FALSE (Scale diverse: 1 vs 2)
    x.compareTo(y);   // 0 (Sono matematicamente uguali) -> USARE QUESTO
    \end{lstlisting}
\end{itemize}

\subsection{Anatomia di BigDecimal: Grandezza e Scala}

Spesso si pensa a \texttt{BigDecimal} come a un "contenitore magico", ma internamente è composto da due campi molto semplici che lavorano insieme per determinare il valore e la posizione della virgola.

\begin{deepdive}{Struttura Interna: Unscaled Value e Scale}
    Un oggetto \texttt{BigDecimal} è definito da questa formula matematica esatta:
    \[ \text{Valore} = \text{UnscaledValue} \times 10^{-\text{Scale}} \]
    
    Internamente, Java memorizza questi due dati:
    \begin{enumerate}
        \item \textbf{Unscaled Value (Valore non scalato):} Un oggetto \texttt{BigInteger}. Questo contiene il numero "intero", ignorando completamente la virgola. Essendo un \texttt{BigInteger}, può avere una grandezza arbitraria, limitata solo dalla RAM del computer.
        \item \textbf{Scale (Scala):} Un primitivo \texttt{int} (32 bit). Questo numero dice "di quanti posti dobbiamo spostare la virgola verso sinistra".
    \end{enumerate}
    
    \textbf{Esempio pratico:}
    Se creiamo \texttt{new BigDecimal("123.456")}, in memoria avremo:
    \begin{itemize}
        \item \texttt{intVal} (Unscaled): \textbf{123456}
        \item \texttt{scale}: \textbf{3}
    \end{itemize}
    Il calcolo è: $123456 \times 10^{-3} = 123.456$.
\end{deepdive}

\subsubsection{Quanto può essere grande?}
Mentre \texttt{double} esplode (diventa \texttt{Infinity}) se supera circa $1.8 \times 10^{308}$, \texttt{BigDecimal} è mostruosamente più capiente.

\begin{itemize}
    \item \textbf{Limite delle Cifre:} Il "numero di cifre" è gestito dal \texttt{BigInteger}. Teoricamente può contenere miliardi di cifre, finché hai memoria RAM libera.
    \item \textbf{Limite della Virgola (Scale):} La posizione della virgola è gestita da un \texttt{int}, quindi la scala può andare da circa \textbf{-2 miliardi} a \textbf{+2 miliardi} ($ \pm 2^{31} - 1 $).
\end{itemize}

Questo significa che puoi rappresentare un numero con 2 miliardi di cifre dopo la virgola, o un numero intero così grande da avere 2 miliardi di zeri finali. Per contestualizzare: il numero di atomi nell'universo è stimato a $10^{80}$. Un \texttt{BigDecimal} può gestire numeri enormemente più grandi.

\begin{lstlisting}[caption={Ispezione della struttura interna}]
BigDecimal numero = new BigDecimal("98.765");

// Il numero "puro" senza virgola
BigInteger unscaled = numero.unscaledValue(); 
// Risultato: 98765

// Dove mettere la virgola
int scala = numero.scale(); 
// Risultato: 3 (sposta la virgola di 3 a sinistra su 98765)
\end{lstlisting}

\begin{interview}{Scale Negativa?}
    \textbf{Domanda:} "Cosa succede se la scale è negativa in un BigDecimal?"
    
    \textbf{Risposta:} "Se la scale è positiva indica i decimali. Se è \textbf{negativa}, indica che il numero deve essere moltiplicato per potenze di 10 (aggiunge zeri alla fine).
    Ad esempio, un Unscaled Value di \texttt{5} con scale \texttt{-3} vale $5 \times 10^{-(-3)} = 5 \times 10^3 = 5000$. Questo permette di gestire numeri interi enormi risparmiando spazio."
\end{interview}

\section{Operazioni con Scale Diverse}

Cosa succede se sommiamo un numero con 1 decimale (\texttt{10.5}) a uno con 2 decimali (\texttt{0.25})? E nella moltiplicazione?
Le regole cambiano in base all'operazione matematica.

\subsection{Somma e Sottrazione: La regola del Max Scale}
Nella somma e nella sottrazione, la regola d'oro è l'allineamento. Java deve rendere i due numeri comparabili portandoli alla stessa scala.
La scala del risultato sarà sempre il \textbf{massimo} tra le scale degli operandi:
\[ \text{Scale}_{\text{risultato}} = \max(\text{Scale}_1, \text{Scale}_2) \]

\begin{deepdive}{Dietro le quinte: L'Allineamento degli Unscaled Value}
    Immagina di sommare:
    \begin{itemize}
        \item \textbf{A:} \texttt{10.5} (Unscaled: 105, Scale: 1)
        \item \textbf{B:} \texttt{0.25} (Unscaled: 25, Scale: 2)
    \end{itemize}
    
    Java non può fare $105 + 25$. Prima deve "gonfiare" il numero con la scala più piccola per pareggiare quella più grande:
    \begin{enumerate}
        \item Identifica la scala target: \textbf{2} (la maggiore).
        \item Prende \textbf{A}. La differenza di scala è $2 - 1 = 1$.
        \item Moltiplica l'unscaled value di A per $10^1$: $105 \times 10 = 1050$.
        \item Ora A è virtualmente \texttt{10.50} (Unscaled: 1050, Scale: 2).
        \item Esegue la somma degli interi: $1050 + 25 = 1075$.
    \end{enumerate}
    Il risultato è un nuovo BigDecimal con unscaled \textbf{1075} e scale \textbf{2} $\rightarrow$ \texttt{10.75}.
\end{deepdive}

\subsection{Moltiplicazione: La somma delle Scale}
Nella moltiplicazione non serve allineare. La regola è puramente matematica: il numero di cifre decimali del risultato è la somma delle cifre decimali dei fattori.
\[ \text{Scale}_{\text{risultato}} = \text{Scale}_1 + \text{Scale}_2 \]

\begin{lstlisting}
BigDecimal a = new BigDecimal("1.2");  // Scale 1
BigDecimal b = new BigDecimal("3.45"); // Scale 2

// Scale risultante: 1 + 2 = 3
BigDecimal res = a.multiply(b); 
System.out.println(res); // 4.140
// Nota: 12 * 345 = 4140. La virgola si sposta di 3.
\end{lstlisting}

\subsection{Divisione: Il terreno minato}
La divisione è l'operazione più pericolosa con i \texttt{BigDecimal}.

Se il risultato della divisione ha un numero finito di decimali (es. $1/2 = 0.5$), Java calcola la scala necessaria (spesso \texttt{scale1 - scale2}, ma si adatta per contenere il risultato).
Tuttavia, se il risultato è un numero periodico o infinito (es. $1/3 = 0.333...$), \texttt{BigDecimal} cerca di calcolare la rappresentazione \textbf{esatta}. Non potendolo fare con una memoria finita, lancia un'eccezione.

\begin{interview}{ArithmeticException: Non-terminating decimal expansion}
    \textbf{Problema:} Molti junior dev scrivono questo codice che funziona nei test (es. 10/2) ma crasha in produzione (es. 10/3).
    
\begin{lstlisting}
BigDecimal a = new BigDecimal("1");
BigDecimal b = new BigDecimal("3");

// CRASH! ArithmeticException
BigDecimal c = a.divide(b); 
\end{lstlisting}

    \textbf{Soluzione:} Quando si divide, è \textbf{obbligatorio} specificare due cose:
    \begin{enumerate}
        \item La \texttt{Scale} desiderata (quanti decimali voglio tenere).
        \item Il \texttt{RoundingMode} (come arrotondare l'ultima cifra).
    \end{enumerate}

\begin{lstlisting}
// Corretto: Voglio 2 decimali, arrotondando per eccesso se serve
BigDecimal c = a.divide(b, 2, RoundingMode.HALF_UP);
System.out.println(c); // 0.33
\end{lstlisting}
\end{interview}

\subsection{Wrapper Classes e Autoboxing}
Per ogni primitivo esiste una classe corrispondente (Wrapper) che permette di trattarlo come un oggetto (es. \texttt{int} $\to$ \texttt{Integer}). Questo è necessario per usare i Generics (es. \texttt{List<Integer>}, non esiste \texttt{List<int>}).

\begin{deepdive}{Autoboxing - Unboxing - Performance}
Dal Java 5, la conversione è automatica:
\begin{lstlisting}
Integer x = 10; // Autoboxing (da int a Integer)
int y = x;      // Unboxing (da Integer a int)
\end{lstlisting}
\textbf{Attenzione ai rischi:}
\begin{enumerate}
    \item \textbf{NullPointerException:} Se \texttt{x} fosse \texttt{null}, la riga \texttt{int y = x;} lancerebbe una NPE, perché la JVM prova a invocare \texttt{x.intValue()} su un riferimento nullo.
    \item \textbf{Performance:} L'autoboxing crea nuovi oggetti nello Heap. In cicli intensivi, usare \texttt{Integer} invece di \texttt{int} può causare un overhead inutile e pressione sul Garbage Collector.
\end{enumerate}
\end{deepdive}

\begin{interview}{Il trabocchetto dell'Integer Cache}
Cosa stampa questo codice?
\begin{lstlisting}
Integer a = 100; Integer b = 100;
System.out.println(a == b); // true

Integer c = 200; Integer d = 200;
System.out.println(c == d); // false (???)
\end{lstlisting}
\textbf{Risposta:} Java mantiene una \textbf{Cache} per gli oggetti \texttt{Integer} (e altri wrapper) tra \textbf{-128 e 127}.
\begin{itemize}
    \item Per 100, Java riutilizza lo stesso oggetto dalla cache $\to$ riferimenti uguali.
    \item Per 200, Java crea due nuovi oggetti nello Heap $\to$ riferimenti diversi.
\end{itemize}
\textbf{Morale:} Confrontare sempre i Wrapper Objects con \texttt{.equals()}, mai con \texttt{==}.
\end{interview}

\section{Pass-by-Value vs Pass-by-Reference: Sfatiamo il mito}

Questa è probabilmente la domanda teorica più sbagliata dai candidati Junior/Mid.

\begin{deepdive}{Java è rigorosamente Pass-by-Value}
In Java, il passaggio dei parametri avviene \textbf{sempre per valore (copia)}. Non esiste il "Pass-by-Reference" come in C++.

\textbf{Cosa viene copiato?}
\begin{itemize}
    \item \textbf{Primitivi:} Viene copiato il valore effettivo (i bit). Modificare il parametro nel metodo non influenza la variabile originale.
    \item \textbf{Oggetti (Reference):} Viene copiato \textbf{il valore del riferimento} (l'indirizzo di memoria).
\end{itemize}

Questo significa che:
\begin{enumerate}
    \item Puoi modificare lo \textbf{stato} dell'oggetto puntato (es. \texttt{p.setName("Mario")}), e la modifica sarà visibile fuori.
    \item \textbf{NON} puoi cambiare l'oggetto a cui punta la variabile originale riassegnando il riferimento.
\end{enumerate}
\end{deepdive}

\textbf{Esempio di prova:}
\begin{lstlisting}
public void swap(Object a, Object b) {
    Object temp = a;
    a = b;
    b = temp;
}
// Questo metodo NON scambia gli oggetti nel main.
// Ha solo scambiato le copie locali dei riferimenti 'a' e 'b'.
\end{lstlisting}

\section{Operatori e Precedenza}

Oltre agli operatori aritmetici base, è fondamentale conoscere le sfumature logiche e di concatenazione.

\subsection{Short-Circuit Evaluation (\&\& vs \&)}
\begin{itemize}
    \item \texttt{\&\&} (AND logico): Se il primo operando è \texttt{false}, non valuta nemmeno il secondo. (Più efficiente e sicuro contro le NPE).
    \item \texttt{\&} (AND bitwise/booleano): Valuta \textbf{sempre} entrambi gli operandi.
\end{itemize}
Esempio critico: \texttt{if (obj != null \&\& obj.isValid())} è sicuro. Usando \texttt{\&}, lancerebbe NPE se \texttt{obj} è null.

\subsection{Concatenazione di Stringhe}
L'operatore \texttt{+} è sovraccaricato per le stringhe. La valutazione avviene da sinistra a destra.
\begin{lstlisting}
System.out.println(1 + 2 + "Java"); // Stampa "3Java" (1+2=3, poi concatena)
System.out.println("Java" + 1 + 2); // Stampa "Java12" (String+1="Java1", poi "Java1"+2)
\end{lstlisting}

\section{Control Flow: Best Practices e Modern Java}

\subsection{Switch vs If-Else}
\begin{itemize}
    \item \textbf{Switch Classico:} Funziona con byte, short, char, int, String ed Enum. Richiede \texttt{break} per evitare il fall-through.
    \item \textbf{If-Else:} Necessario per condizioni complesse o range di valori.
\end{itemize}

\subsection{Java 14+: Switch Expressions}
Java moderno ha introdotto una sintassi più pulita che può ritornare valori e non soffre di fall-through accidentali.

\begin{lstlisting}
// Sintassi "Arrow" ->
String tipoGiorno = switch (giorno) {
    case LUN, MAR, MER, GIO, VEN -> "Lavorativo";
    case SAB, DOM -> "Weekend";
    default -> throw new IllegalArgumentException("Giorno non valido");
};
\end{lstlisting}
Questa feature mostra al colloquio che sei aggiornato sulle ultime versioni.

\subsection{Cicli e Recursion}
\begin{itemize}
    \item \textbf{For-Loop:} Usalo quando sai a priori il numero di iterazioni o ti serve l'indice.
    \item \textbf{For-Each:} (\texttt{for (Tipo t : collezione)}) Usalo sempre per leggibilità su Array e Liste, a meno che tu non debba modificare la struttura (rimuovere elementi) mentre iteri.
    \item \textbf{Recursion Risk:} Ogni chiamata ricorsiva aggiunge un frame allo \textbf{Stack}. Troppe chiamate causano \texttt{StackOverflowError}. In Java, l'iterazione è quasi sempre preferibile alla ricorsione per problemi profondi.
\end{itemize}

\section{L'Operatore Ternario}

L'operatore ternario (\texttt{? :}) è una scorciatoia sintattica per l'istruzione \texttt{if-else}. È l'unico operatore in Java che accetta tre operandi.

La sua sintassi generale è:
\begin{center}
    \texttt{condizione ? espressione\_se\_vera : espressione\_se\_falsa}
\end{center}

A differenza di un blocco \texttt{if}, l'operatore ternario è un'\textbf{espressione}, il che significa che \textbf{restituisce sempre un valore}. Pertanto, non può essere utilizzato come un'istruzione a sé stante (void), ma il suo risultato deve essere assegnato a una variabile, restituito da un metodo o passato come argomento.

\subsection{Esempio Pratico}
Vediamo come semplificare il codice sostituendo un classico \texttt{if-else} con l'operatore ternario.

\begin{lstlisting}[caption={Confronto If-Else vs Operatore Ternario}]
public class TernaryExample {
    public static void main(String[] args) {
        int score = 75;
        String result;

        // Approccio Classico (Verboso)
        if (score >= 60) {
            result = "Promosso";
        } else {
            result = "Bocciato";
        }

        // Approccio con Operatore Ternario (Conciso)
        // Leggilo come: "Se score >= 60 allora 'Promosso', altrimenti 'Bocciato'"
        String quickResult = (score >= 60) ? "Promosso" : "Bocciato";
        
        System.out.println(quickResult);
    }
}
\end{lstlisting}

\begin{interview}{Il tranello della "Numeric Promotion"}
    Una domanda comune nei test scritti riguarda il comportamento dell'operatore ternario quando i due valori di ritorno hanno \textbf{tipi numerici diversi}.
    
    Cosa stampa il seguente codice?
    
\begin{lstlisting}
Object o1 = true ? new Integer(1) : new Double(2.0);
System.out.println(o1);
\end{lstlisting}
    
    \textbf{Risposta:}
    Stampa \texttt{1.0}, non \texttt{1}.
    
    \textbf{Spiegazione:}
    Java applica la \textit{Binary Numeric Promotion}. Se uno degli operandi è \texttt{double} (o \texttt{Double}) e l'altro è convertibile in un numero (come \texttt{Integer}), Java converte entrambi al tipo più ampio (in questo caso \texttt{double}) prima di restituire il valore. Quindi l'\texttt{Integer(1)} viene promosso a \texttt{1.0}.
\end{interview}

\begin{deepdive}{Quando NON usare l'operatore ternario}
    Sebbene sia molto utile per assegnazioni semplici, l'abuso dell'operatore ternario può rendere il codice illeggibile.
    
    \textbf{Evita il "Nesting" (annidamento):}
\begin{lstlisting}
// CATTIVA PRATICA: Difficile da leggere
String status = (age > 18) ? (hasLicense ? "Driver" : "Passenger") : "Child";

// BUONA PRATICA: Usa if-else o variabili intermedie
if (age <= 18) {
    status = "Child";
} else {
    status = hasLicense ? "Driver" : "Passenger";
}
\end{lstlisting}
    La regola d'oro è: se devi fermarti a riflettere per capire l'ordine di valutazione, probabilmente dovresti usare un \texttt{if-else} standard.
\end{deepdive}

\section{Modificatori: Visibilità e Stato}

In Java, la definizione di una variabile (o metodo/classe) è preceduta da parole chiave che ne determinano la visibilità e il ciclo di vita.

\subsection{Modificatori di Accesso (Visibilità)}
Controllano \textit{chi} può vedere e usare i tuoi campi e metodi. Questo è il cuore dell'\textbf{Incapsulamento}.

\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Modificatore} & \textbf{Classe} & \textbf{Package} & \textbf{Sottoclasse} & \textbf{Mondo} \\
\hline
\texttt{public} & \checkmark & \checkmark & \checkmark & \checkmark \\
\hline
\texttt{protected} & \checkmark & \checkmark & \checkmark & \textbf{X} \\
\hline
\texttt{default} (nessuno) & \checkmark & \checkmark & \textbf{X} & \textbf{X} \\
\hline
\texttt{private} & \checkmark & \textbf{X} & \textbf{X} & \textbf{X} \\
\hline
\end{tabular} 
\caption{Livelli di visibilità in Java}
\end{table}

\begin{interview}{Differenza tra Default e Protected}
    Questa domanda serve a verificare se conosci la gestione dei package.
    \begin{itemize}
        \item \textbf{Default (Package-Private):} Se non scrivi nulla, il membro è visibile solo alle classi dello \textbf{stesso package}.
        \item \textbf{Protected:} Come il default, MA è visibile anche alle \textbf{sottoclassi} che si trovano in \textbf{package diversi}. È pensato per l'ereditarietà.
    \end{itemize}
\end{interview}

\subsection{Modificatori di Stato (Non-Access Modifiers)}

Questi modificatori cambiano il comportamento della variabile in memoria.

\subsubsection{1. static}
Rende la variabile appartenente alla \textbf{Classe} e non all'istanza (oggetto).
\begin{itemize}
    \item C'è una sola copia della variabile in memoria, condivisa da tutte le istanze.
    \item Se un oggetto modifica una variabile statica, la modifica è visibile a tutti gli altri oggetti.
    \item \textbf{Uso comune:} Costanti, contatori globali, Singleton.
\end{itemize}

\subsubsection{2. final}
Indica che il valore non può essere cambiato una volta inizializzato.
\begin{itemize}
    \item \textbf{Su primitive:} Il valore è costante (es. \texttt{final int MAX = 10;}).
    \item \textbf{Su oggetti:} Il \textbf{riferimento} è costante (non puoi riassegnare l'oggetto), ma lo \textbf{stato interno} dell'oggetto può cambiare (a meno che la classe stessa non sia immutabile).
\end{itemize}

\subsubsection{3. volatile (Concetto Avanzato Back-End)}
Utilizzato nella programmazione concorrente (Thread).
Indica alla JVM che il valore della variabile deve essere letto/scritto sempre direttamente dalla \textbf{Main Memory} (RAM) e non dalla cache della CPU. Garantisce la visibilità delle modifiche tra thread diversi, ma non garantisce l'atomicità.

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Classi, Oggetti e Membri}

Java è un linguaggio puramente orientato agli oggetti. Comprendere l'anatomia di una classe non significa solo sapere scrivere \texttt{class Pippo}, ma capire come la JVM costruisce gli oggetti in memoria e in che ordine esegue il codice.

\section{Anatomia di una Classe: Campi, Metodi, Costruttori}

\subsection{Ordine di Inizializzazione (The Initialization Block Trap)}
Una delle domande più frequenti nei test di certificazione (OCP) e nei colloqui riguarda l'ordine esatto in cui vengono eseguiti i blocchi di codice quando si istanzia un oggetto.

L'ordine rigido è:
\begin{enumerate}
    \item \textbf{Static Blocks \& Fields:} Eseguiti \textbf{una sola volta} quando la classe viene caricata dal ClassLoader (prima ancora di creare istanze). Ordine di apparizione nel file.
    \item \textbf{Parent Constructor:} Se la classe estende qualcos'altro, viene prima completata la costruzione del genitore.
    \item \textbf{Instance Initializer Blocks \& Fields:} Blocchi di codice tra graffe \texttt{\{ ... \}} fuori dai metodi e inizializzazione variabili di istanza. Eseguiti \textbf{ogni volta} che si crea un oggetto, in ordine di apparizione.
    \item \textbf{Constructor:} Il corpo del costruttore è l'\textbf{ultimo} ad essere eseguito.
\end{enumerate}

\begin{interview}{Cosa stampa questo codice?}
\begin{lstlisting}
class Test {
    static { System.out.println("Static Block"); }
    
    { System.out.println("Instance Block"); }
    
    public Test() { System.out.println("Constructor"); }
    
    public static void main(String[] args) {
        new Test();
        new Test();
    }
}
\end{lstlisting}
\textbf{Risposta:}
\begin{verbatim}
Static Block     (Solo una volta al caricamento classe)
Instance Block   (Per il primo oggetto)
Constructor      (Per il primo oggetto)
Instance Block   (Per il secondo oggetto)
Constructor      (Per il secondo oggetto)
\end{verbatim}
\end{interview}

\section{Specificatori di Accesso (Access Modifiers)}

L'incapsulamento inizia qui. Java controlla la visibilità di classi, metodi e variabili attraverso quattro livelli di accesso. Saper scegliere quello giusto è il primo passo per un design sicuro.

\begin{interview}{Quali sono i modificatori di accesso in Java e le loro differenze?}
Spesso i candidati dimenticano il livello "Default".
Ecco la gerarchia dal più restrittivo al più aperto:

\begin{enumerate}
    \item \textbf{private:} Visibile \textbf{solo} all'interno della stessa classe. È lo standard per i campi (variabili di istanza).
    \item \textbf{Default (Package-Private):} Si applica quando \textbf{non} scrivi nessun modificatore. Visibile solo alle classi dello \textbf{stesso package}.
    \item \textbf{protected:} Visibile nello stesso package \textbf{E} nelle \textbf{sottoclassi} (anche se si trovano in package diversi).
    \item \textbf{public:} Visibile ovunque.
\end{enumerate}
\end{interview}

\subsection{La Matrice di Visibilità}
Memorizzare questa tabella è essenziale.

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Modificatore} & \textbf{Stessa Classe} & \textbf{Stesso Pkg} & \textbf{Sottoclasse (Diff. Pkg)} & \textbf{Mondo} \\
\hline
\texttt{public} & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javagreen}{\textbf{SÌ}} \\
\hline
\texttt{protected} & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javared}{\textbf{NO}} \\
\hline
\texttt{default} (no mod.) & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javared}{\textbf{NO}} & \textcolor{javared}{\textbf{NO}} \\
\hline
\texttt{private} & \textcolor{javagreen}{\textbf{SÌ}} & \textcolor{javared}{\textbf{NO}} & \textcolor{javared}{\textbf{NO}} & \textcolor{javared}{\textbf{NO}} \\
\hline
\end{tabular}
\caption{Matrice dei permessi di accesso}
\end{table}

\begin{deepdive}{Il trabocchetto di 'protected'}
Molti pensano che \texttt{protected} significhi "solo sottoclassi". \textbf{Falso.}
\texttt{protected} include \textbf{anche} l'accesso \textit{package-private}.
Se la classe \texttt{A} ha un metodo \texttt{protected}, e la classe \texttt{B} è nello stesso package (ma non estende A), \texttt{B} può comunque chiamare quel metodo.
\end{deepdive}

\subsection{Best Practice: Principle of Least Privilege}
La regola d'oro per i colloqui e il codice pulito: \textbf{"Rendi tutto il più privato possibile"}.
\begin{itemize}
    \item Inizia sempre con \texttt{private}.
    \item Se serve accesso ai test unitari nello stesso package, rimuovi il modificatore (usa \texttt{default}).
    \item Usa \texttt{protected} solo se stai progettando una libreria pensata per essere estesa.
    \item Usa \texttt{public} solo per i metodi dell'API (il "contratto" della classe).
\end{itemize}

\section{La keyword \texttt{static}: Implicazioni e Memory Leak}

Il modificatore \texttt{static} disaccoppia un membro dall'istanza dell'oggetto. Appartiene alla classe (o meglio, al Class Object nel Metaspace/Heap).

\subsection{Static Methods}
\begin{itemize}
    \item Non possono accedere a variabili di istanza (non-static) perché non esiste il riferimento \texttt{this}.
    \item Sono risolti a \textbf{Compile-Time} (Static Binding).
\end{itemize}

\begin{deepdive}{Static e il Method Hiding}
In Java, i metodi statici \textbf{NON} supportano l'Overriding (polimorfismo a runtime).
Se una sottoclasse ridefinisce un metodo statico con la stessa firma del padre, si parla di \textbf{Method Hiding}.

Quale metodo viene eseguito dipende dal \textbf{tipo della variabile di riferimento}, non dall'oggetto reale.
\end{deepdive}

\noindent Di seguito un esempio pratico che dimostra come il compilatore risolva la chiamata basandosi sul tipo del riferimento (\texttt{Parent}) e non sull'istanza creata (\texttt{Child}). Quella che segue è una \textbf{BAD PRACTICE} ove si richiama un metodo statico tramite l'istanza di un oggetto. In questi casi è una scorciatoia che si attua implicando che il metodo statico sia legato alla classe del tipo della variabile che lo ha chiamato. Questo spiega nell'esempio il paradosso del Method Hiding.

\begin{lstlisting}[caption={Dimostrazione del Method Hiding}, label={lst:methodhiding}]
class Parent {
    // Metodo statico nella superclasse
    public static void print() {
        System.out.println("Statico in Parent");
    }
}

class Child extends Parent {
    // HIDING: Questo metodo nasconde quello del padre, non lo sovrascrive
    public static void print() {
        System.out.println("Statico in Child");
    }
}

public class Main {
    public static void main(String[] args) {
        // Riferimento di tipo Parent, Oggetto di tipo Child
        Parent p = new Child();
        
        // Poiche' il metodo e' statico, Java guarda il TIPO DEL RIFERIMENTO (Parent)
        // Il polimorfismo non si applica qui.
        p.print(); 
    }
}
\end{lstlisting}

\noindent \textbf{Output del programma:}
\begin{lstlisting}[numbers=none, frame=none, backgroundcolor=\color{white}, basicstyle=\ttfamily\bfseries]
Statico in Parent
\end{lstlisting}

\bigskip

\begin{interview}{Perché il metodo statico non va in Override?}
Durante un colloquio potresti dover spiegare il "perché".
\\
\textbf{Risposta:} L'Overriding si basa sul \textit{dynamic binding} (risoluzione a runtime dell'oggetto reale). I metodi statici, invece, sono risolti tramite \textit{static binding} (al momento della compilazione) e sono legati alla Classe, non all'istanza. Per questo motivo il compilatore guarda solo il tipo della variabile dichiarata.
\end{interview}

\subsection{Static Variables e Memory Leaks}
Le variabili statiche sono, di fatto, variabili globali.
\textbf{Il Rischio:} Poiché le variabili statiche sono legate alla classe (che solitamente non viene mai scaricata dal GC finché l'app gira), gli oggetti referenziati da variabili statiche rimangono in memoria \textbf{per sempre}.
\newline
\textbf{Scenario Classico:} Una \texttt{static List<Object> cache} che continua a crescere senza mai essere svuotata causerà un \textbf{OutOfMemoryError}. Le variabili statiche sono considerate \textbf{GC Roots}.

\section{Il riferimento \texttt{this} e \texttt{super}}

\subsection{Constructor Chaining}
Una pratica essenziale per evitare duplicazione di codice nei costruttori e rispettare il principio \textbf{DRY} (\textit{Don't Repeat Yourself}). Invece di riscrivere la logica di inizializzazione in ogni costruttore, si crea una "catena" di chiamate.

\begin{itemize}
    \item \texttt{this(...)}: Chiama un altro costruttore della \textbf{stessa} classe.
    \item \texttt{super(...)}: Chiama un costruttore della \textbf{superclasse} (classe padre). Se non esplicito con extends si riferisce ad Object. Non esplicitare un metodo costruttore implicitamente richiama il costruttore della classe genitore.
\end{itemize}

\begin{lstlisting}[caption={Esempio di Constructor Chaining con this()}]
public class ServerConfig {
    private String host;
    private int port;
    private int timeout;

    // 1. Costruttore "Master": contiene l'unica logica di assegnazione
    public ServerConfig(String host, int port, int timeout) {
        this.host = host;
        this.port = port;
        this.timeout = timeout;
        System.out.println("Configurazione creata.");
    }

    // 2. Costruttore parziale: delega al Master fornendo un timeout di default
    public ServerConfig(String host, int port) {
        this(host, port, 3000); // Chiama il costruttore sopra
    }

    // 3. Costruttore vuoto: delega fornendo valori di default per tutto
    public ServerConfig() {
        this("localhost", 8080); // Chiama il costruttore parziale
    }
}
\end{lstlisting}

Nell'esempio sopra, se instanziamo \texttt{new ServerConfig()}, Java eseguirà la catena: 
\begin{enumerate}
    \item \texttt{ServerConfig()} chiama...
    \item \texttt{ServerConfig(String, int)} che chiama...
    \item \texttt{ServerConfig(String, int, int)} (dove avviene l'inizializzazione reale).
\end{enumerate}

\subsubsection{La Regola d'Oro}
La gestione della prima istruzione è rigida in Java. Ecco come affrontarla in sede di colloquio.

\begin{interview}{Posso usare this() e super() nello stesso costruttore?}
    \textbf{No, è impossibile.}
    
    La chiamata a \texttt{this(...)} o \texttt{super(...)} deve essere tassativamente la \textbf{prima istruzione} del costruttore.
    
    \begin{itemize}
        \item \textbf{Motivo tecnico:} Java deve garantire che l'oggetto sia inizializzato correttamente (partendo dalla classe padre Object in giù) prima che si possa accedere a qualsiasi variabile d'istanza.
        \item Se provassi a scriverli entrambi, il secondo non sarebbe la prima istruzione, generando un errore di compilazione: \textit{"Constructor call must be the first statement in a constructor"}.
    \end{itemize}
    
    \textbf{Nota:} Se non scrivi nulla, il compilatore inserisce implicitamente \texttt{super()} (senza argomenti) come prima riga.
\end{interview}

\begin{deepdive}{Chaining e Eccezioni}
    Se i costruttori nella catena lanciano \textbf{Checked Exceptions}, il costruttore chiamante deve dichiarare di lanciare le stesse eccezioni (o eccezioni padre). Non è possibile inserire un blocco \texttt{try-catch} attorno a una chiamata \texttt{super()} o \texttt{this()} perché, dovendo essere la prima istruzione, non può essere preceduta dalla keyword \texttt{try}.
\end{deepdive}

\section{Tassonomia delle Classi}

In Java, una classe non è solo un file \texttt{.java}. Possiamo classificare le classi in base ai modificatori (cosa permettono di fare) e al loro ambito di definizione (dove si trovano).

\subsection{Classi Top-Level e Modificatori}
Le classi standard definite direttamente in un file package-level. Oltre alla dichiarazione base, possono avere modificatori che ne alterano drasticamente l'uso:

\begin{itemize}
    \item \textbf{Abstract Class:} Una classe che non può essere istanziata direttamente (\texttt{new} non è permesso), ma serve solo come base per sottoclassi. Può contenere metodi astratti (senza corpo).
    \item \textbf{Final Class:} Una classe che \textbf{non può essere estesa}. Utile per garantire l'immutabilità (es. \texttt{String}) e la sicurezza, impedendo a chiunque di alterarne il comportamento tramite override.
    \item \textbf{Sealed Class (Java 17+):} Una via di mezzo. Permette l'ereditarietà, ma solo a un set specifico di classi permesse (\texttt{permits}).
\end{itemize}

\subsection{Nested Classes (Classi Annidate)}
Java permette di definire classi dentro altre classi. La distinzione cruciale è la parola chiave \texttt{static}.

\subsubsection{A. Static Nested Class}
Dichiarata come \texttt{static class Nested \{ ... \}} all'interno di una classe esterna.
\begin{itemize}
    \item \textbf{Comportamento:} È a tutti gli effetti una classe Top-Level, ma "impacchettata" dentro un'altra per coesione logica.
    \item \textbf{Accesso:} \textbf{Non ha accesso} ai membri d'istanza (non-statici) della classe esterna.
    \item \textbf{Istanziazione:} Non richiede un'istanza dell'outer class.
\end{itemize}
\begin{lstlisting}
Outer.Nested n = new Outer.Nested(); // Sintassi pulita
\end{lstlisting}

\subsubsection{B. Inner Class (Non-static / Member Class)}
Dichiarata senza \texttt{static} all'interno di una classe.
\begin{itemize}
    \item \textbf{Legame:} È legata indissolubilmente a una specifica \textbf{istanza} della classe esterna.
    \item \textbf{Accesso:} Vede \textbf{tutto} della classe esterna, inclusi i campi \texttt{private}.
    \item \textbf{Istanziazione:} Sintassi "aliena" che evidenzia la dipendenza dall'oggetto padre.
\end{itemize}
\begin{lstlisting}
Outer o = new Outer();
Outer.Inner i = o.new Inner(); // Serve 'o' per creare 'i'
\end{lstlisting}

\begin{deepdive}{Deep Dive: Il Memory Leak silenzioso}
    Quando compili una Inner Class, il compilatore genera un costruttore nascosto che accetta un riferimento alla classe esterna (spesso chiamato \texttt{this\$0}).
    
    \textbf{Il Pericolo:} Se passi l'oggetto \texttt{Inner} a un componente che vive a lungo (es. una cache o un listener statico), l'intero oggetto \texttt{Outer} rimarrà "vivo" in memoria, perché l'Inner ne detiene un riferimento forte. Il Garbage Collector non potrà pulire l'Outer finché l'Inner esiste.
    
    \textbf{Regola d'oro:} Se la classe interna non ha bisogno di accedere ai campi dell'esterna, dichiarala \textbf{sempre} \texttt{static}.
\end{deepdive}

\subsection{Local Class (Classi Locali)}
Classi definite \textbf{all'interno di un metodo}.
\begin{itemize}
    \item Visibili solo all'interno di quel metodo.
    \item Possono accedere alle variabili locali del metodo solo se sono \textbf{final} o \textbf{effectively final} (non vengono mai modificate dopo l'inizializzazione).
\end{itemize}

\begin{interview}{Perché le variabili locali devono essere Final?}
    \textbf{Domanda:} Perché una Local/Anonymous Class può usare una variabile del metodo che la contiene solo se è \texttt{final}?
    
    \textbf{Risposta:} Per una questione di \textit{Lifecycle}. Il metodo viene eseguito sullo \textbf{Stack} e le sue variabili muoiono quando il metodo termina. L'istanza della classe locale viene creata nell'\textbf{Heap} e può sopravvivere molto più a lungo.
    Java effettua una "cattura" (copia) del valore della variabile dentro l'oggetto nell'Heap. Se la variabile sullo Stack cambiasse valore dopo la copia, ci sarebbe disallineamento. Imponendo \texttt{final}, Java garantisce la coerenza.
\end{interview}

\subsection{Anonymous Inner Class}
Definisce e istanzia una classe "al volo" senza darle un nome. Usata storicamente per i Callback.

\begin{lstlisting}
// Vecchio stile (Java 7)
Runnable r = new Runnable() {
    @Override
    public void run() { 
        System.out.println("Anonymous!"); 
    }
};
\end{lstlisting}

Sebbene le \textbf{Lambda Expressions} (Java 8) abbiano sostituito questo pattern per le interfacce funzionali (metodo singolo), le Anonymous Class servono ancora quando:
\begin{enumerate}
    \item Devi fare override di \textbf{più metodi}.
    \item Devi aggiungere \textbf{campi di stato} (variabili) all'istanza.
    \item La classe da estendere non è un'interfaccia ma una classe astratta o concreta senza costruttori adatti alle lambda.
\end{enumerate}

\section{Enum: non sono semplici costanti}

In alcuni linguaggi (come C) un enum è solo un numero mascherato.
In Java, invece, un \texttt{enum} è una vera e propria \textbf{classe speciale}.

La differenza fondamentale è questa:

\begin{quote}
Una classe normale può avere infinite istanze create con \texttt{new}.  
Un enum, invece, ha un numero \textbf{fisso e limitato di istanze}, deciso a priori nel codice.
\end{quote}

Queste istanze:
\begin{itemize}
    \item vengono create automaticamente dalla JVM
    \item hanno un nome preciso (es: \texttt{CREATO}, \texttt{PAGATO}, \texttt{SPEDITO})
    \item non possono essere duplicate o create manualmente
\end{itemize}

\subsection{Caratteristiche principali degli Enum}
\begin{itemize}
    \item Non possono essere estesi (sono implicitamente \texttt{final})
    \item Possono avere \textbf{campi}, \textbf{costruttori} e \textbf{metodi}
    \item Rendono il codice più sicuro (\textit{Type Safety}): non puoi usare valori che non esistono nell'enum
\end{itemize}

\begin{lstlisting}[caption={Enum con stato (dati) e comportamento (metodi)}]
public enum StatoOrdine {

    CREATO(1),
    PAGATO(2),
    SPEDITO(3),
    CONSEGNATO(4);

    // Dato interno dell'enum
    private final int codice;

    // Costruttore (chiamato dalla JVM per ogni valore dell'enum)
    StatoOrdine(int codice) {
        this.codice = codice;
    }

    // Metodo: comportamento legato allo stato
    public boolean isCompletato() {
        return this == CONSEGNATO;
    }

    public int getCodice() {
        return codice;
    }
}

// Utilizzo
StatoOrdine s = StatoOrdine.PAGATO;

if (!s.isCompletato()) {
    System.out.println("Ordine in corso, codice: " + s.getCodice());
}
\end{lstlisting}

\begin{deepdive}{Singleton Pattern con Enum}
Joshua Bloch (autore di \textit{Effective Java}) suggerisce di usare un enum quando si vuole creare un vero \textbf{Singleton}.

Se un enum ha \textbf{un solo valore}, allora esisterà \textbf{una sola istanza} di quella classe in tutta l'applicazione.

\begin{lstlisting}
public enum DatabaseConnection {
    INSTANCE;

    public void connect() {
        // Logica di connessione
    }
}

// Uso
DatabaseConnection.INSTANCE.connect();
\end{lstlisting}

Questa è la versione più sicura possibile del Singleton perché:
\begin{enumerate}
    \item \textbf{Thread-safe:} la JVM crea l'istanza una sola volta in modo sicuro, anche con più thread.
    \item \textbf{Sicurezza con la serializzazione:} Java impedisce che vengano create copie durante la deserializzazione.
    \item \textbf{Sicurezza contro reflection:} non puoi forzare la creazione di nuove istanze di un enum.
\end{enumerate}
\end{deepdive}

\begin{interview}{Metodi automatici degli Enum}
La JVM aggiunge automaticamente due metodi statici utilissimi:
\begin{itemize}
    \item \texttt{values()} : restituisce un array con tutti i valori dell'enum
    \item \texttt{valueOf(String name)} : converte una stringa in un valore dell'enum (lancia un errore se non esiste)
\end{itemize}
\end{interview}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{I Pilastri della OOP}

L'Object Oriented Programming si regge su quattro pilastri. Conoscerli a memoria non basta; bisogna saper spiegare \textit{come} Java li implementa e quali limitazioni impone.

\section{I 4 Pilastri della Programmazione ad Oggetti (OOP)}

La Programmazione Orientata agli Oggetti (OOP) non è solo una sintassi particolare; è un \textbf{paradigma di pensiero}.
L'idea di base è modellare il software come se fosse il mondo reale: non più una lunga lista di istruzioni procedurali, ma un insieme di "Oggetti" che interagiscono tra loro scambiandosi messaggi.

Per definire un sistema OOP "puro", ci si basa su quattro concetti fondamentali, noti come i "Pilastri". Durante un colloquio, è essenziale saperli definire concettualmente, slegandosi dal codice.

\subsection{1. Astrazione (Abstraction)}
L'astrazione è l'arte di \textbf{semplificare la realtà}.
Nel mondo reale, ogni oggetto è infinitamente complesso. Quando programmiamo, non ci serve modellare ogni singolo atomo di un'automobile. Ci interessa modellare solo ciò che serve al nostro sistema (es. \textit{marca}, \textit{modello}, \textit{velocità}).

\begin{itemize}
    \item \textbf{Concetto:} Nascondere la complessità dei dettagli implementativi e mostrare solo le funzionalità essenziali all'utente.
    \item \textbf{Analogy:} Quando guidi un'auto, interagisci con il volante e i pedali (l'interfaccia astratta). Non hai bisogno di sapere come funziona l'iniezione elettronica o la combustione interna (i dettagli complessi) per poter guidare.
\end{itemize}

\subsection{2. Incapsulamento (Encapsulation)}
L'incapsulamento è un meccanismo di \textbf{protezione e controllo}.
Serve a raggruppare dati (variabili) e metodi (comportamenti) in un'unica unità (la Classe) e a limitarne l'accesso dall'esterno.

\begin{itemize}
    \item \textbf{Concetto:} Impedire che i dati interni di un oggetto vengano modificati arbitrariamente da altri oggetti. L'oggetto diventa una "Black Box": protegge il proprio stato e permette modifiche solo attraverso metodi controllati.
    \item \textbf{Analogy:} Pensa a un conto bancario. Non puoi entrare nel database della banca e modificare il tuo saldo a mano. Devi usare uno sportello o un'app (metodi pubblici) che verificano se hai i fondi prima di prelevare. L'incapsulamento garantisce l'integrità del saldo.
\end{itemize}

\subsection{3. Ereditarietà (Inheritance)}
L'ereditarietà è un meccanismo di \textbf{riutilizzo e gerarchia}.
Permette di creare nuove classi basandosi su classi esistenti, ereditandone caratteristiche e comportamenti senza dover riscrivere il codice.

\begin{itemize}
    \item \textbf{Concetto:} Stabilire una relazione "Is-A" (È-Un) tra concetti generali e concetti specifici. Evita la duplicazione del codice (principio DRY - Don't Repeat Yourself).
    \item \textbf{Analogy:} In biologia, un "Cane" eredita le caratteristiche di un "Mammifero", che a sua volta eredita da "Animale". Il cane ha tutte le proprietà dell'animale (respira, mangia) più le sue specificità (abbaia).
\end{itemize}

\subsection{4. Polimorfismo (Polymorphism)}
Il termine deriva dal greco "molte forme". È la capacità di oggetti di tipo diverso di rispondere allo stesso messaggio (metodo) in modi differenti. È il pilastro che garantisce la \textbf{flessibilità} del sistema.

\begin{itemize}
    \item \textbf{Concetto:} Un'unica interfaccia per molte implementazioni. Posso trattare un gruppo di oggetti diversi come se fossero lo stesso tipo generico, e lasciare che ognuno esegua l'azione a modo suo.
    \item \textbf{Analogy:} Prendi un telecomando universale col tasto "Play".
    \begin{itemize}
        \item Se lo punti verso un lettore DVD, il tasto "Play" fa girare il disco.
        \item Se lo punti verso un lettore MP3, il tasto "Play" avvia la musica digitale.
        \item Se lo punti verso una console, il tasto "Play" avvia il gioco.
    \end{itemize}
    L'azione (l'interfaccia "Play") è la stessa, ma il risultato (l'implementazione) cambia a seconda dell'oggetto che la riceve.
\end{itemize}

\begin{interview}{Come spiegheresti i 4 pilastri in 30 secondi?}
    \textbf{Domanda:} "Senza scrivere codice, riassumimi i vantaggi dell'OOP."
    
    \textbf{Risposta:}
    \begin{enumerate}
        \item \textbf{Astrazione:} Riduce la complessità concentrandosi su "Cosa fa" l'oggetto, non su "Come lo fa".
        \item \textbf{Incapsulamento:} Protegge i dati da modifiche non autorizzate, garantendo stabilità.
        \item \textbf{Ereditarietà:} Elimina la ridondanza organizzando il codice in gerarchie logiche.
        \item \textbf{Polimorfismo:} Rende il sistema estendibile, permettendo di aggiungere nuovi tipi di oggetti senza rompere il codice esistente che li utilizza.
    \end{enumerate}
\end{interview}

\section{Incapsulamento: Oltre i Getter e Setter}

L'incapsulamento non serve solo a "nascondere i dati", ma a \textbf{proteggere gli invarianti} della classe.
Un invariante è una condizione che deve essere sempre vera (es. \texttt{età >= 0}). Se il campo fosse \texttt{public}, chiunque potrebbe impostarlo a -1 rompendo la logica.

\begin{deepdive}{Defensive Copying (La copia difensiva)}
Un errore comune nei colloqui riguarda la gestione di oggetti mutabili nei getter/setter.

\begin{lstlisting}
public class Periodo {
    private Date fine;

    public Date getFine() {
        return fine; // ERRORE DI SICUREZZA!
    }
}
\end{lstlisting}
Poiché \texttt{Date} è mutabile, chi chiama \texttt{getFine()} riceve il riferimento all'oggetto originale e può cambiarne il valore (es. \texttt{p.getFine().setYear(1900)}), modificando lo stato interno di \texttt{Periodo} a sua insaputa.
\textbf{Soluzione:} Restituire sempre una copia (clone) o usare classi immutabili (es. \texttt{LocalDate} di Java 8).
\begin{lstlisting}
public Date getFine() {
    return new Date(fine.getTime()); // Copia difensiva
}
\end{lstlisting}
\end{deepdive}

\section{Ereditarietà: Single vs Multiple}

Java supporta l'\textbf{Ereditarietà Singola} per le classi (\texttt{extends}) ma l'\textbf{Ereditarietà Multipla} per le interfacce (\texttt{implements}).

\begin{interview}{Cos'è il Diamond Problem e come lo gestisce Java?}
\textbf{Problema:} Immagina una classe \texttt{C} che estende sia \texttt{A} che \texttt{B}. Entrambe (\texttt{A} e \texttt{B}) hanno un metodo \texttt{print()}. Se chiami \texttt{c.print()}, quale versione viene eseguita? Quella di A o di B? Questa ambiguità è il "Diamond Problem".

\textbf{Soluzione in Java:}
\begin{itemize}
    \item \textbf{Classi:} Java proibisce l'ereditarietà multipla di classi (\texttt{extends A, B} è illegale). Il problema è risolto alla radice.
    \item \textbf{Interfacce (Java 8+):} Con i \textit{Default Methods} (metodi delle interfacce che presentano un implementazione a patto di usare la key-word default), il problema è tornato. Se implementi due interfacce che hanno lo stesso metodo default, il compilatore genera un \textbf{errore di compilazione}.
    \item \textbf{Risoluzione:} Devi obbligatoriamente fare Override del metodo nella tua classe e specificare quale chiamare:
    \texttt{InterfaceA.super.print();}
\end{itemize}
\end{interview}

\section{Polimorfismo: Overloading vs Overriding}

\subsection{1. Overloading (Compile-time Polymorphism)}
Stesso nome metodo, parametri diversi (firma diversa). Risolto dal compilatore (Static Binding).
\textbf{Nota:} Cambiare solo il tipo di ritorno \textbf{non} è overloading valido.

\subsection{2. Overriding (Runtime Polymorphism)}
Stessa firma, implementazione diversa nella sottoclasse. Risolto dalla JVM a runtime (Dynamic Binding) basandosi sull'oggetto reale.

\begin{deepdive}{Regole dell'Overriding (Covarianza ed Eccezioni)}
Quando fai override di un metodo, devi rispettare il contratto del padre, ma con alcune libertà:
\begin{enumerate}
    \item \textbf{Access Modifier:} Non puoi essere più restrittivo (da \texttt{public} a \texttt{private}), ma puoi essere più permissivo.
    \item \textbf{Return Type (Covarianza):} Puoi restituire il tipo originale o una sua \textbf{sottoclasse}.
    \begin{itemize}
        \item Padre: \texttt{public Number getValore()}
        \item Figlio: \texttt{public Integer getValore()} $\to$ \textbf{Valido!}
    \end{itemize}
    \item \textbf{Exceptions:}
    \begin{itemize}
        \item Puoi non lanciare eccezioni.
        \item Puoi lanciare le stesse eccezioni (o sottoclassi).
        \item \textbf{NON} puoi lanciare nuove \textit{Checked Exceptions} non previste dal padre.
        \item Puoi lanciare qualsiasi \textit{Unchecked Exception}.
    \end{itemize}
\end{enumerate}
\end{deepdive}

\section{Astrazione: Classi Astratte vs Interfacce}

L'astrazione è uno dei pilastri della OOP, ma la distinzione tra Classi Astratte e Interfacce va ben oltre la sintassi. La scelta tra le due determina la flessibilità futura della tua applicazione.

\subsection{La differenza concettuale: "Chi sono" vs "Cosa so fare"}

\begin{itemize}
    \item \textbf{Classe Astratta (Is-A):} Definisce l'identità fondamentale dell'oggetto. Un \texttt{Cane} \textit{è un} \texttt{Animale}. Le classi astratte sono ideali per definire un \textbf{template} di base con una logica parzialmente implementata e, soprattutto, uno \textbf{stato} condiviso.
    \item \textbf{Interfaccia (Can-Do / Behavior):} Definisce una capacità o un contratto. Un \texttt{Cane} \textit{può essere} \texttt{Addestrabile}, ma anche un \texttt{Robot} può esserlo. Le interfacce disaccoppiano il comportamento dalla gerarchia delle classi.
\end{itemize}

\begin{deepdive}{Perché le Classi Astratte esistono ancora dopo Java 8?}
    Con l'introduzione dei \texttt{default methods} nelle interfacce (Java 8), molti si chiedono se le classi astratte siano obsolete. La risposta è \textbf{NO}.
    
    La differenza critica è lo \textbf{Stato (State)}.
    \begin{itemize}
        \item Le interfacce \textbf{non possono avere variabili d'istanza} (stato mutabile). Possono avere solo costanti (\texttt{static final}).
        \item Le classi astratte possono avere campi (\texttt{private}, \texttt{protected}) che mantengono lo stato dell'oggetto e costruttori per inizializzarlo.
    \end{itemize}
    Usa una classe astratta quando hai bisogno di condividere codice che manipola lo stato interno dell'oggetto.
\end{deepdive}

\subsection{Tabella Comparativa Aggiornata}

\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.3} % Aumenta spazio tra righe
\begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
\hline
\textbf{Classe Astratta} & \textbf{Interfaccia} \\
\hline
\textbf{Relazione:} Gerarchica stretta (Is-A). & \textbf{Relazione:} Contratto trasversale (Can-Do). \\
\hline
\textbf{Stato:} Può avere variabili d'istanza (non statiche, non final). & \textbf{Stato:} Solo costanti (\texttt{public static final}). Niente stato interno. \\
\hline
\textbf{Costruttori:} Sì, invocati dalle sottoclassi via \texttt{super()}. & \textbf{Costruttori:} No. \\
\hline
\textbf{Visibilità:} I metodi possono essere \texttt{public}, \texttt{protected}, \texttt{private}. & \textbf{Visibilità:} Default \texttt{public}. Da Java 9 supporta \texttt{private} per uso interno. \\
\hline
\textbf{Ereditarietà:} Singola. & \textbf{Ereditarietà:} Multipla (una classe può implementare N interfacce). \\
\hline
\end{tabular}
\end{table}

\subsection{Esempio Pratico: Il problema dello Stato}

Per capire perché non possiamo usare sempre e solo le interfacce, proviamo a modellare un videogioco.
Vogliamo che le nostre entità abbiano una \textbf{barra della vita (energia)} che diminuisce quando fanno azioni.

\begin{itemize}
    \item \textbf{Il problema:} Se definissimo \texttt{energia} in un'interfaccia, sarebbe implicitamente \texttt{public static final} (una costante). Non potremmo mai scrivere \texttt{energia -= 10}, perché le costanti non cambiano!
    \item \textbf{La soluzione:} Usiamo una \textbf{Classe Astratta} per contenere la variabile \texttt{energia} (lo Stato) e un'\textbf{Interfaccia} per definire abilità extra come \texttt{Volante} (il Comportamento).
\end{itemize}

\begin{lstlisting}[language=Java, caption=Gestione dello Stato: Classe Astratta vs Interfaccia]
// 1. CLASSE ASTRATTA: Gestisce lo STATO (Chi sono e come sto)
public abstract class Personaggio {
    // Questo è lo "Stato Interno". 
    // Un'interfaccia NON può avere questo campo modificabile.
    protected int energia = 100; 

    // Metodo concreto che manipola lo stato
    public void riposa() {
        this.energia = 100;
        System.out.println("Energia ripristinata.");
    }
}

// 2. INTERFACCIA: Gestisce il COMPORTAMENTO (Cosa so fare)
public interface Volante {
    void vola();
}

// 3. CLASSE CONCRETA
public class Drago extends Personaggio implements Volante {
    
    @Override
    public void vola() {
        // Posso accedere e modificare lo stato ereditato
        if (this.energia >= 10) {
            System.out.println("Il drago sta volando in alto!");
            this.energia -= 10; // MODIFICA DELLO STATO (Possibile solo grazie alla classe astratta)
        } else {
            System.out.println("Troppo stanco per volare.");
        }
    }
}
\end{lstlisting}

\begin{deepdive}{In sintesi}
    Se provassi a mettere \texttt{int energia = 100;} dentro l'interfaccia \texttt{Volante}, Java lo trasformerebbe automaticamente in una costante (\texttt{final}). 
    Alla riga \texttt{this.energia -= 10} riceveresti un errore di compilazione: \textit{"Cannot assign a value to final variable energy"}.
    Ecco perché per gestire dati che cambiano nel tempo (stato) serve una Classe (Astratta o no).
\end{deepdive}

\section{Evoluzione delle Interfacce (Java 8, 9, 17+)}

Le interfacce, in origine, erano semplici contratti: dichiaravano \textbf{cosa} fare, ma non \textbf{come} farlo.
Con Java 8, 9 e 17, le interfacce si sono evolute in strumenti molto più potenti, capaci di:

\begin{itemize}
    \item far evolvere le API senza rompere il codice esistente (\textit{Backward Compatibility})
    \item incorporare comportamento di base
    \item controllare precisamente chi può implementarle
\end{itemize}

\subsection{Default Methods (Java 8) e il Diamond Problem}

Prima di Java 8, aggiungere un nuovo metodo a un'interfaccia significava dover modificare \textbf{tutte} le classi che la implementavano.

Con l'introduzione dei \textbf{default methods}, un'interfaccia può fornire una implementazione di base:

\begin{lstlisting}[caption={Esempio semplice di Default Method}]
interface Veicolo {
    default void accendi() {
        System.out.println("Il veicolo si accende.");
    }
}
\end{lstlisting}

Se una classe implementa questa interfaccia ma non ridefinisce il metodo, utilizza automaticamente quello fornito.

\bigskip

\textbf{Il problema del diamante (Diamond Problem)}

Il problema nasce quando più interfacce forniscono un \textit{default method} con la stessa firma.

\begin{lstlisting}[caption={Conflitto tra default methods}]
interface Veicolo {
    default void accendi() {
        System.out.println("Il veicolo si accende.");
    }
}

interface Allarme {
    default void accendi() {
        System.out.println("L'allarme si attiva.");
    }
}

// ERRORE: ambiguità sui default methods
public class AutoBlindata implements Veicolo, Allarme {

    @Override
    public void accendi() {
        // Scelta esplicita: utilizzo il metodo dell'interfaccia Veicolo
        Veicolo.super.accendi();
        System.out.println("Sistemi di sicurezza attivi.");
    }
}
\end{lstlisting}

La classe è obbligata a risolvere il conflitto definendo quale metodo utilizzare.

\subsection{Regole di risoluzione dei Default Methods}

Quando esiste un conflitto tra più metodi con la stessa firma, Java applica le seguenti regole, in ordine:

\begin{enumerate}
    \item \textbf{Class wins:} Se la classe (o una superclasse) definisce il metodo, questa implementazione ha la priorità su qualsiasi default method.
    
    \item \textbf{Sub-interface wins:} Se un'interfaccia estende un'altra e ridefinisce il metodo, vince sempre l'interfaccia più specifica (la sottinterfaccia).
    
    \item \textbf{Ambiguità:} Se non esiste alcuna relazione tra le interfacce, la classe concreta deve fornire una propria implementazione ed esplicitare la scelta.
\end{enumerate}

\subsection{Metodi Statici e Privati (Java 8 \& 9)}

\paragraph{Metodi statici (Java 8)}

Un'interfaccia può contenere metodi \texttt{static}, utilizzabili senza creare un oggetto:

\begin{lstlisting}[caption={Metodo statico in un'interfaccia}]
interface Matematica {
    static int max(int a, int b) {
        return a > b ? a : b;
    }
}
\end{lstlisting}

Utilizzo:

\begin{lstlisting}
int valore = Matematica.max(4, 10);
\end{lstlisting}

Caratteristiche principali:

\begin{itemize}
    \item Non sono ereditati dalle classi
    \item Non sono sovrascrivibili (override)
    \item Servono come metodi di utilità o factory
\end{itemize}

Esempio reale: \texttt{Stream.of(...)} è un metodo \texttt{static} dell'interfaccia \texttt{Stream}.

\paragraph{Metodi private (Java 9)}

I metodi \texttt{private} all'interno di un'interfaccia servono per evitare duplicazione di codice tra più \textit{default methods}.

\begin{lstlisting}[caption={Metodo private in un'interfaccia}]
interface Logger {

    default void info(String msg) {
        stampa("INFO", msg);
    }

    default void error(String msg) {
        stampa("ERROR", msg);
    }

    private void stampa(String livello, String msg) {
        System.out.println("[" + livello + "] " + msg);
    }
}
\end{lstlisting}

Questi metodi:

\begin{itemize}
    \item Sono visibili solo all'interno dell'interfaccia
    \item Non sono accessibili dalle classi implementanti
    \item Non sono ereditati
\end{itemize}

\subsection{Sealed Interfaces (Java 17)}

Con Java 17 è possibile dichiarare un'interfaccia come \textbf{sealed} (sigillata), limitando esplicitamente quali classi possono implementarla.

\begin{lstlisting}[caption={Esempio di sealed interface}]
public sealed interface Forma permits Cerchio, Rettangolo {
    double calcolaArea();
}

final class Cerchio implements Forma { ... }
final class Rettangolo implements Forma { ... }

// ERRORE: non è permesso
// class Triangolo implements Forma { ... }
\end{lstlisting}

Questo meccanismo permette:

\begin{itemize}
    \item maggiore controllo sulla gerarchia
    \item maggiore sicurezza del dominio applicativo
    \item supporto a pattern matching avanzato negli \texttt{switch}
\end{itemize}

\subsection{Nota importante: uso di \texttt{extends} nelle interfacce}

Quando un'interfaccia eredita da un'altra (o più) interfaccia, utilizza sempre la parola chiave \textbf{\texttt{extends}}, non \texttt{implements}.

\begin{lstlisting}[caption={Interfaccia che estende altre interfacce}]
interface A {
    void metodoA();
}

interface B {
    void metodoB();
}

// Le interfacce utilizzano EXTENDS
interface C extends A, B {
    void metodoC();
}
\end{lstlisting}

Caratteristiche:

\begin{itemize}
    \item Un'interfaccia può estendere una o più interfacce
    \item Questo è un tipo sicuro di ereditarietà multipla
    \item Le classi invece usano \texttt{implements}
\end{itemize}

\bigskip

\textbf{Riassunto finale:}

\begin{itemize}
    \item Java 8 $\rightarrow$ \textit{default} e \textit{static methods}
    \item Java 9 $\rightarrow$ \textit{private methods}
    \item Java 17 $\rightarrow$ \textit{sealed interfaces}
    \item Le interfacce usano \texttt{extends}, le classi usano \texttt{implements}
\end{itemize}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Gestione dei Dati: Identità, Uguaglianza e Immutabilità}


In Java, ogni classe estende implicitamente \texttt{java.lang.Object}. Questo significa che non esistono oggetti "nudi": ogni istanza porta con sé un'eredità di metodi fondamentali che definiscono come l'oggetto si comporta nelle collezioni, nella sincronizzazione e nel debug.

Ignorare il funzionamento di questi metodi è la causa principale di memory leak nelle cache (es. HashMap) e di bug logici difficili da tracciare.

\section{La Classe java.lang.Object}

Prima di approfondire i contratti specifici, ecco una panoramica di tutti i metodi esposti da \texttt{Object}.
Durante i colloqui, una domanda frequente per testare la conoscenza della libreria standard è: \textit{"A parte equals e toString, quali altri metodi della classe Object conosci?"}.

\begin{center}
\rowcolors{2}{gray!10}{white}
\renewcommand{\arraystretch}{1.4}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{deepblue} \textbf{\textcolor{white}{Metodo}} & \textbf{\textcolor{white}{Descrizione}} \\
\hline
\texttt{equals(Object obj)} & Determina l'uguaglianza logica tra due oggetti. \\
\hline
\texttt{hashCode()} & Restituisce un intero rappresentativo, fondamentale per le Hash Tables. \\
\hline
\texttt{toString()} & Restituisce la rappresentazione stringa dell'oggetto. Essenziale per il logging e il debug. \\
\hline
\texttt{getClass()} & Restituisce l'oggetto \texttt{Class<?>} a runtime (Reflection). È un metodo \texttt{final}, quindi non sovrascrivibile. \\
\hline
\texttt{clone()} & Crea e restituisce una copia dell'oggetto. Spesso sconsigliato in favore dei costruttori di copia. \\
\hline
\texttt{wait()}, \texttt{notify()}, \texttt{notifyAll()} & Primitive di basso livello per la sincronizzazione dei Thread. \\
\hline
\texttt{finalize()} & \textbf{DEPRECATO} (da Java 9). Non usarlo mai per rilasciare risorse; non c'è garanzia che venga chiamato dal Garbage Collector. \\
\hline
\end{tabularx}
\end{center}

\section{Identità vs Uguaglianza}


Prima di scrivere codice, bisogna distinguere filosoficamente due concetti che spesso i principianti confondono:
\begin{enumerate}
    \item \textbf{Identità (Reference Equality):} Due variabili puntano allo stesso indirizzo di memoria fisico? Sono lo stesso oggetto?
    \item \textbf{Uguaglianza (Logical Equality):} Due oggetti, pur essendo distinti in memoria, contengono gli stessi dati significativi (es. stesso ID utente)?
\end{enumerate}

\begin{interview}{== vs .equals()}
    \textbf{Domanda:} "Qual è la differenza tra l'operatore \texttt{==} e il metodo \texttt{.equals()}?"
    
    \textbf{Risposta:}
    \begin{itemize}
        \item \textbf{\texttt{==}} controlla l'\textbf{Identità}. Restituisce \texttt{true} solo se i due riferimenti (puntatori) puntano esattamente alla stessa locazione di memoria nello Heap.
        \item \textbf{\texttt{.equals()}} controlla l'\textbf{Uguaglianza Logica}.
        \begin{itemize}
            \item L'implementazione di default in \texttt{Object} usa \texttt{==} (quindi controlla l'identità).
            \item Nelle classi Java standard (es. \texttt{String}, \texttt{Integer}) e nelle tue classi di dominio (DTO, Entity), deve essere sovrascritto per confrontare il \textbf{contenuto} (i campi interni).
        \end{itemize}
    \end{itemize}
\end{interview}

\begin{deepdive}{String Pool e l'inganno del ==}
    Le stringhe in Java sono speciali.
    \begin{itemize}
        \item \texttt{String a = "ciao";}
        \item \texttt{String b = "ciao";}
    \end{itemize}
    In questo caso \texttt{a == b} potrebbe restituire \texttt{true} grazie allo \textit{String Pool} (ottimizzazione della JVM che riusa le stringhe letterali).
    Tuttavia, se scrivi \texttt{String c = new String("ciao");}, allora \texttt{a == c} sarà \textbf{false}, mentre \texttt{a.equals(c)} sarà \textbf{true}.
    
    \textbf{Regola d'oro:} Per confrontare oggetti (incluse le Stringhe), usa \textbf{sempre} \texttt{.equals()}. Usa \texttt{==} solo per i tipi primitivi o per controllare se un riferimento è \texttt{null}.
\end{deepdive}

\section{Il Contratto HashCode e le Collezioni}

Se decidi di sovrascrivere \texttt{equals()}, firmi un contratto implicito ma vincolante: \textbf{DEVI sovrascrivere anche \texttt{hashCode()}}.

Le strutture dati più usate in Java (\texttt{HashMap}, \texttt{HashSet}, \texttt{Hashtable}) basano la loro efficienza su questo legame. Se lo rompi, le collezioni smettono di funzionare correttamente (perdono i dati), anche se il codice compila senza errori.

\subsection{Come funziona una HashMap (Dietro le quinte)}
Una HashMap non è magia: è essenzialmente un \textbf{Array} di liste (o alberi, da Java 8). Ogni posizione dell'array è chiamata \textbf{Bucket} (Secchio).

Il processo di inserimento/ricerca segue questi step:
\begin{enumerate}
    \item \textbf{Hashing:} Viene invocato \texttt{key.hashCode()}. Il risultato viene trasformato in un indice dell'array (es. \texttt{hash \% arrayLength}).
    \item \textbf{Individuazione:} Si va al bucket corrispondente.
    \item \textbf{Confronto:}
    \begin{itemize}
        \item Se il bucket è vuoto: inserisce l'oggetto.
        \item Se c'è già qualcosa (\textbf{Collisione}): scorre la lista di oggetti presenti usando \texttt{equals()} per vedere se la chiave esiste già (aggiornamento) o se è nuova (aggiunta in coda).
    \end{itemize}
\end{enumerate}

\begin{center}
\begin{tikzpicture}[
    scale=0.9, transform shape,
    font=\small\sffamily,
    bucket/.style={rectangle, draw=deepblue, fill=white, minimum width=3cm, minimum height=1.2cm, align=center, rounded corners, line width=0.8pt},
    arrow/.style={->, >=stealth, thick, deepblue}
]

    % Array di Buckets
    \node[bucket, label=left:\textbf{Idx 0}] (b0) at (0, 4.5) {\textit{Empty}};
    \node[bucket, label=left:\textbf{Idx 1}] (b1) at (0, 2.5) {\textbf{COLLISIONE!}\\ \texttt{[Key A] $\to$ [Key B]}};
    \node[bucket, label=left:\textbf{Idx 2}] (b2) at (0, 0.5) {\texttt{Key C}};
    
    % Logica
    \node[right=3cm of b0] (obj) {\textbf{Oggetto "Key B"}};
    
    % Frecce logiche
    \draw[arrow] (obj) -- node[right = 0.5 cm, align=left, font=\footnotesize] {1. \texttt{hashCode()} calcola\\Indice 1} (b1.east);
    
    % Spiegazione testuale laterale
    \node[below=2cm of obj, text width=6cm, align=left, font=\footnotesize, draw=gray, dashed, inner sep=5pt, rounded corners] {
        \textbf{Flusso di Inserimento Key B:}
        \begin{enumerate}
            \item Calcolo Hash $\to$ Indice 1.
            \item Il Bucket 1 non è vuoto (c'è Key A).
            \item \texttt{KeyB.equals(KeyA)} è \texttt{false}.
            \item Java accoda Key B alla lista linkata.
        \end{enumerate}
    };

\end{tikzpicture}
\end{center}

\begin{deepdive}{Le 3 Regole del Contratto HashCode}
    Secondo la specifica Java, un'implementazione corretta deve rispettare queste regole:
    
    \begin{enumerate}
        \item \textbf{Coerenza (Consistency):} Se chiamo \texttt{hashCode()} più volte sullo stesso oggetto (senza modificarne i campi), deve restituire sempre lo stesso numero.
        \item \textbf{Uguaglianza implica Hash uguale:} Se \texttt{a.equals(b)} è \texttt{true}, allora \texttt{a.hashCode()} DEVE essere uguale a \texttt{b.hashCode()}. \textit{(Questa è la regola più violata).}
        \item \textbf{Hash uguale NON implica Uguaglianza:} Se \texttt{a.hashCode() == b.hashCode()}, non è detto che \texttt{equals} sia true. Questo fenomeno si chiama \textbf{Collisione} ed è gestito dalla HashMap, ma troppe collisioni degradano le performance da $O(1)$ a $O(n)$.
    \end{enumerate}
\end{deepdive}

\begin{interview}{Il bug della HashMap silenziosa}
    \textbf{Scenario:} Hai una classe \texttt{Utente} con campo \texttt{id}. Fai l'override solo di \texttt{equals} (dicendo che due utenti sono uguali se hanno lo stesso ID).
    
    \begin{itemize}
        \item Inserisci: \texttt{map.put(new Utente(1), "Dati");}
        \item Cerchi: \texttt{map.get(new Utente(1));}
    \end{itemize}
    
    \textbf{Domanda:} Cosa restituisce la mappa?
    
    \textbf{Risposta:} Restituisce \texttt{null}.
    \textbf{Perché?} Non avendo sovrascritto \texttt{hashCode}, i due oggetti (pur avendo ID 1) hanno hashcode nativi diversi (basati sull'indirizzo di memoria). La HashMap guarda nel "secchio" sbagliato e non trova l'oggetto, senza nemmeno provare a chiamare \texttt{equals}.
\end{interview}

\section{Immutabilità}

Una classe si definisce \textbf{Immutabile} quando il suo stato non può essere modificato in alcun modo dopo che l'oggetto è stato costruito.
Esempi classici nel JDK sono \texttt{String}, \texttt{Integer}, \texttt{BigDecimal}.

\subsection{Perché è fondamentale?}
Ci sono due motivi principali per cui i DTO (Data Transfer Objects) e le Value Classes dovrebbero essere immutabili:

\begin{enumerate}
    \item \textbf{Thread Safety:} Un oggetto immutabile è automaticamente thread-safe. Può essere letto da mille thread contemporaneamente senza bisogno di sincronizzazione, perché nessuno può cambiarne lo stato.
    \item \textbf{Chiavi delle HashMap:} Questa è la regola d'oro. \textbf{Le chiavi di una Mappa non devono mai cambiare.}
\end{enumerate}

\begin{interview}{Il problema delle chiavi mutabili}
    \textbf{Domanda:} "Cosa succede se uso un oggetto mutabile come chiave di una HashMap e poi ne modifico un campo?"
    
    \textbf{Risposta:} Perdi l'oggetto.
    \begin{itemize}
        \item Quando inserisci l'oggetto, viene calcolato l'hash (es. 10) e l'oggetto finisce nel Bucket 10.
        \item Se modifichi un campo dell'oggetto, il suo \texttt{hashCode()} cambia (es. diventa 55).
        \item Quando cerchi l'oggetto, la Map calcola il nuovo hash (55), guarda nel Bucket 55, ma l'oggetto è fisicamente rimasto nel Bucket 10!
        \item Risultato: \texttt{get()} restituisce \texttt{null}, anche se l'oggetto è dentro la mappa. Si crea un memory leak.
    \end{itemize}
\end{interview}

\subsection{Come creare una Classe Immutabile (La Checklist)}
Per rendere una classe immutabile, non basta togliere i setter. Bisogna seguire una ricetta precisa per garantire la "Deep Immutability".

\begin{enumerate}
    \item Dichiarare la classe \texttt{final} (per impedire che una sottoclasse malevola sovrascriva i metodi e aggiunga stato mutabile).
    \item Rendere tutti i campi \texttt{private} e \texttt{final} (devono essere assegnati nel costruttore).
    \item Non fornire nessun metodo \textbf{Setter}.
    \item \textbf{Defensive Copying:} Se la classe contiene campi che sono oggetti mutabili (come \texttt{Date} o \texttt{List}), non bisogna mai restituire o assegnare il riferimento diretto.
\end{enumerate}

\begin{deepdive}{Deep Dive: Defensive Copying}
    Molti candidati cadono su questo punto.
    Se la tua classe ha un campo \texttt{private final Date data;}, il campo è final (il riferimento non cambia), ma l'oggetto \texttt{Date} interno è mutabile (ha il metodo \texttt{setTime()}).
    
    Se restituisci \texttt{return this.data;} nel getter, chi chiama il metodo può modificare la data interna del tuo oggetto "immutabile"!
    
    \textbf{Soluzione:}
    \begin{itemize}
        \item \textbf{In Ingresso (Costruttore):} Crea una copia dei dati ricevuti.
        \item \textbf{In Uscita (Getter):} Restituisci una copia dei dati interni.
    \end{itemize}
\end{deepdive}

\begin{lstlisting}[language=Java, caption=Immutabilità Corretta con Defensive Copy]
public final class ImmutableUser {
    private final String username;    // String è immutabile, ok.
    private final Date registration;  // Date è MUTABILE! Attenzione.

    public ImmutableUser(String username, Date registration) {
        this.username = username;
        // COPY IN: Se il chiamante modifica la sua variabile 'date' dopo
        // aver chiamato il costruttore, noi non ne risentiamo.
        this.registration = new Date(registration.getTime());
    }

    public String getUsername() {
        return username;
    }

    public Date getRegistration() {
        // COPY OUT: Se il chiamante usa setTime() sulla data ricevuta,
        // modifica la sua copia, non il nostro stato interno.
        return new Date(this.registration.getTime());
    }
}
\end{lstlisting}

\section{Java Records (Modern Java)}

Fino a Java 14, creare una semplice classe immutabile per trasportare dati (DTO) richiedeva decine di righe di codice ripetitivo (\textit{boilerplate}): campi privati, costruttore, getter, \texttt{equals}, \texttt{hashCode} e \texttt{toString}.

Java 14 (diventato standard in Java 16) ha introdotto i \textbf{Record}.
Un Record è una classe speciale il cui scopo principale è essere un "\textit{trasportatore trasparente di dati immutabili}".

\subsection{Sintassi e Funzionalità}
Con una sola riga di codice, il compilatore genera tutto ciò che serve.

\begin{lstlisting}[language=Java, caption=Definizione di un Record]
// Sintassi concisa: definisce campi e costruttore in una riga
public record UserRecord(String username, int age) {}
\end{lstlisting}

Dietro le quinte, il compilatore trasforma quella riga in una classe \texttt{final} con:
\begin{itemize}
    \item Due campi \texttt{private final} (\texttt{username}, \texttt{age}).
    \item Un \textbf{Costruttore Canonico} che inizializza tutti i campi.
    \item Metodi di accesso (senza prefisso \texttt{get}, es. \texttt{.username()}, \texttt{.age()}).
    \item Implementazioni corrette e performanti di \texttt{equals()}, \texttt{hashCode()} e \texttt{toString()}.
\end{itemize}

\begin{interview}{Record vs Classi Tradizionali}
    \textbf{Domanda:} "Posso aggiungere metodi o logica a un Record?"
    
    \textbf{Risposta:} Sì, ma con limitazioni strutturali per preservare l'immutabilità.
    \begin{itemize}
        \item Puoi aggiungere metodi statici o di istanza per logica di business leggera.
        \item Puoi implementare interfacce.
        \item \textbf{NON} puoi estendere altre classi (il Record estende già implicitamente \texttt{java.lang.Record}).
        \item \textbf{NON} puoi aggiungere campi di istanza extra che non siano elencati nella dichiarazione del record.
    \end{itemize}
\end{interview}

\subsection{Validazione: Il Compact Constructor}
Un dubbio comune è: \textit{"Se il costruttore è automatico, come faccio a validare che l'username non sia null?"}.
I Record supportano una sintassi speciale chiamata \textbf{Compact Constructor}.

Non devi ripetere i parametri e le assegnazioni (\texttt{this.x = x}). Scrivi solo la logica di controllo.

\begin{lstlisting}[language=Java, caption=Compact Constructor per la validazione]
public record UserRecord(String username, int age) {
    
    // Niente parentesi con argomenti qui!
    public UserRecord {
        Objects.requireNonNull(username, "L'username è obbligatorio");
        
        if (age < 0) {
            throw new IllegalArgumentException("L'età non può essere negativa");
        }
        
        // Non serve scrivere this.age = age; lo fa Java in automatico alla fine.
    }
}
\end{lstlisting}

\begin{deepdive}{Record vs Lombok}
    Molti progetti usano la libreria \textbf{Lombok} (\texttt{@Data}, \texttt{@Value}) per ridurre il codice.
    Tuttavia, i Record sono ora la scelta preferibile perché:
    \begin{enumerate}
        \item Sono \textbf{Nativi}: Non richiedono plugin nell'IDE o dipendenze nel \texttt{pom.xml}.
        \item Sono \textbf{Semantici}: Java sa che un Record è solo dati. Questo permette ottimizzazioni future e serializzazione sicura.
    \end{enumerate}
\end{deepdive}

\section{Copia degli Oggetti}

In Java, l'operatore di assegnazione \texttt{=} non crea mai una copia dell'oggetto, ma copia solo il \textbf{riferimento}.
\begin{verbatim}
User u1 = new User("Mario");
User u2 = u1; // u2 e u1 puntano allo STESSO oggetto in memoria
\end{verbatim}
Se modifichi \texttt{u2}, modifichi anche \texttt{u1}.
Quando serve duplicare un oggetto (es. per il pattern Defensive Copy), abbiamo due strade: il metodo \texttt{clone()} o i Costruttori di Copia.

\subsection{Perché evitare clone()}
Il metodo \texttt{clone()} e l'interfaccia \texttt{Cloneable} sono considerati un errore di design nelle prime versioni di Java (persino da Joshua Bloch, autore di \textit{Effective Java}).

I problemi principali sono:
\begin{enumerate}
    \item \textbf{Contratto confuso:} \texttt{Cloneable} è un'interfaccia vuota (Marker Interface), ma se non la implementi, il metodo \texttt{clone()} lancia un'eccezione controllata (\texttt{CloneNotSupportedException}).
    \item \textbf{Shallow Copy (Copia Superficiale):} Questa è la trappola mortale. L'implementazione di default di \texttt{clone()} copia i valori dei campi bit-per-bit.
\end{enumerate}

\begin{deepdive}{Shallow Copy vs Deep Copy}
    Immagina un oggetto \texttt{Manager} che contiene una lista di \texttt{Impiegati}.
    
    \begin{itemize}
        \item \textbf{Shallow Copy (clone standard):} Crea un nuovo oggetto \texttt{Manager}, ma copia il \textit{riferimento} alla lista degli impiegati.
        \textit{Risultato:} Il clone e l'originale condividono la \textbf{stessa} lista. Se il clone aggiunge un impiegato, questo appare anche nella lista dell'originale. Disastroso.
        
        \item \textbf{Deep Copy (Copia Profonda):} Crea un nuovo \texttt{Manager} E crea anche una \textbf{nuova} lista di impiegati, copiando i dati uno a uno.
        \textit{Risultato:} I due oggetti sono totalmente disaccoppiati.
    \end{itemize}
\end{deepdive}

\subsection{La Soluzione: Copy Constructor}
L'approccio standard e sicuro nell'industria è ignorare \texttt{clone()} e creare un costruttore che accetta un'istanza della stessa classe.
Questo ti dà il controllo totale sulla profondità della copia.

\begin{lstlisting}[language=Java, caption=Copy Constructor (Best Practice)]
public class Project {
    private String name;
    private List<String> tasks; // Oggetto mutabile!

    // Costruttore standard
    public Project(String name, List<String> tasks) {
        this.name = name;
        this.tasks = new ArrayList<>(tasks);
    }

    // COPY CONSTRUCTOR
    public Project(Project other) {
        this.name = other.name; // String è immutabile, ok copiare il riferimento
        
        // DEEP COPY manuale della lista
        // Creiamo una NUOVA lista contenente gli stessi elementi
        this.tasks = new ArrayList<>(other.tasks);
        
        // Nota: Se la lista contenesse oggetti complessi (non String),
        // dovremmo ciclare e clonare anche quelli!
    }
}
\end{lstlisting}

\begin{interview}{Librerie per la Deep Copy}
    \textbf{Domanda:} "Se ho un oggetto molto complesso con 50 campi annidati, devo scrivere il Copy Constructor a mano?"
    
    \textbf{Risposta:} No. In produzione si usano spesso scorciatoie basate sulla serializzazione:
    \begin{enumerate}
        \item \textbf{JSON:} Serializzi l'oggetto in una stringa JSON e lo deserializzi subito in un nuovo oggetto (usando Jackson o Gson). È lento ma sicuro.
        \item \textbf{Librerie:} Usare \texttt{Apache Commons Lang} (\texttt{SerializationUtils.clone()}).
    \end{enumerate}
\end{interview}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Java Core Essentials}

In questo capitolo analizziamo i mattoni fondamentali del linguaggio. Non si tratta semplici contenitori di dati, ma di classi con comportamenti di memoria e performance specifici.
Ogni sviluppatore Senior deve conoscere cosa succede "sotto il cofano" di Stringhe, Wrapper e Array per evitare colli di bottiglia e bug silenziosi.

\section{Stringhe: Architettura e Memoria}

In Java, la classe \texttt{String} è speciale. Pur essendo un oggetto (Reference Type), gode di un supporto linguistico dedicato (letterali tra virgolette, operatore \texttt{+}).
Tuttavia, la sua gestione della memoria è unica nel suo genere.

\subsection{Anatomia Interna: Compact Strings (Java 9+)}
Molti pensano ancora che una Stringa sia un array di \texttt{char}. Sebbene vero fino a Java 8, la struttura è cambiata per ottimizzare la RAM.

\begin{deepdive}{Da char[] a byte[]}
    In Java, un \texttt{char} occupa sempre \textbf{2 byte} (UTF-16). Questo significava che una stringa ASCII come "CIAO" occupava 8 byte, di cui 4 erano zeri inutili.
    
    Da \textbf{Java 9} in poi, la JVM usa le \textbf{Compact Strings}:
    \begin{itemize}
        \item Internamente usa un \texttt{byte[]} (1 byte per slot) + un flag \texttt{coder}.
        \item Se la stringa contiene solo caratteri Latin-1 (ISO-8859-1), usa \textbf{1 byte} per carattere.
        \item Se contiene caratteri speciali (es. Emoji, Kanji), il \texttt{coder} cambia e usa \textbf{2 byte} (UTF-16).
    \end{itemize}
    \textbf{Impatto:} Risparmio medio del 10-15\% di Heap Memory nelle applicazioni Enterprise.
\end{deepdive}

\subsection{Perché la Stringa è Immutabile?}
L'immutabilità non è un caso, ma una scelta architetturale precisa per quattro motivi:

\begin{enumerate}
    \item \textbf{String Pool:} Se le stringhe fossero mutabili, modificare una variabile cambierebbe il valore per tutte le altre referenze che puntano alla stessa stringa nel Pool. Sarebbe il caos.
    \item \textbf{HashCode Caching:} Le stringhe sono le chiavi più usate nelle \texttt{HashMap}. Essendo immutabili, il loro \texttt{hashCode()} viene calcolato \textbf{una volta sola} (alla prima chiamata) e salvato in una variabile interna \texttt{hash}. Questo rende i lookup nelle mappe istantanei.
    \item \textbf{Sicurezza:} Le stringhe sono usate per caricare classi, aprire file e connessioni database. Se fossero mutabili, un attaccante potrebbe modificare il path del file dopo i controlli di sicurezza ma prima della lettura.
    \item \textbf{Thread-Safety:} Un oggetto immutabile è automaticamente thread-safe.
\end{enumerate}

\subsection{Lo String Constant Pool}
Per risparmiare memoria, la JVM mantiene un'area speciale dello Heap (o nel Metaspace in vecchie versioni) chiamata \textbf{String Pool}.

\begin{lstlisting}[language=Java, caption=Pool vs Heap]
String s1 = "Java";             // Va nel POOL
String s2 = "Java";             // Riusa l'oggetto nel POOL
String s3 = new String("Java"); // Crea un NUOVO oggetto nello HEAP

System.out.println(s1 == s2); // true (Stesso indirizzo)
System.out.println(s1 == s3); // false (Indirizzi diversi)
\end{lstlisting}

\begin{deepdive}{Il metodo intern()}
    È possibile spostare manualmente una stringa nel pool invocando \texttt{s3.intern()}.
    Questo metodo cerca se la stringa esiste già nel pool:
    \begin{itemize}
        \item Se sì, restituisce il riferimento del pool.
        \item Se no, aggiunge la stringa al pool e ne restituisce il riferimento.
    \end{itemize}
    Utile per la \textbf{deduplicazione} quando si caricano milioni di stringhe ripetitive da DB o file CSV.
\end{deepdive}

\subsection{Concatenazione: Performance}

\begin{interview}{String vs StringBuilder vs StringBuffer}
    \textbf{Domanda:} "Qual è la differenza e quando usare quale?"
    
    \textbf{Risposta:}
    \begin{enumerate}
        \item \textbf{String:} Immutabile. Ogni \texttt{+} crea un nuovo oggetto. Lento nei loop.
        \item \textbf{StringBuffer:} Mutabile e \textbf{Synchronized}. Thread-safe ma lento a causa dei lock. Legacy (da non usare quasi mai).
        \item \textbf{StringBuilder:} Mutabile e \textbf{Non-Synchronized}. Veloce. È lo standard per manipolare testo.
    \end{enumerate}
    
    \textbf{Attenzione ai Loop:}
    Concatenare con \texttt{+} dentro un ciclo \texttt{for} ha complessità $O(n^2)$ perché ricopia l'array ad ogni iterazione. Usare \texttt{StringBuilder} porta la complessità a $O(n)$.
\end{interview}

\section{Wrapper Classes e Autoboxing}

Java non è un linguaggio a oggetti "puro" (come Ruby o Smalltalk) perché mantiene i \textbf{tipi primitivi} (\texttt{int}, \texttt{boolean}, \texttt{double}) per motivi di performance.
Tuttavia, i Generics di Java (\texttt{List<T>}, \texttt{Map<K,V>}) non supportano i primitivi. Non puoi scrivere \texttt{List<int>}.

Per colmare questo divario, Java fornisce le \textbf{Wrapper Classes} (\texttt{Integer}, \texttt{Boolean}, \texttt{Double}, ecc.), che sono oggetti che "avvolgono" il valore primitivo.

\subsection{Autoboxing e Unboxing}
Dalla versione 5, Java esegue la conversione automatica tra primitivo e wrapper.

\begin{itemize}
    \item \textbf{Autoboxing:} Conversione da primitivo a oggetto.
    \texttt{Integer a = 10;} $\xrightarrow{\text{compila in}}$ \texttt{Integer a = Integer.valueOf(10);}
    
    \item \textbf{Unboxing:} Conversione da oggetto a primitivo.
    \texttt{int b = a;} $\xrightarrow{\text{compila in}}$ \texttt{int b = a.intValue();}
\end{itemize}

\begin{deepdive}{Il rischio NullPointerException (NPE)}
    L'Unboxing nasconde un'insidia mortale.
    \begin{lstlisting}[language=Java, basicstyle=\ttfamily\small]
Integer a = null;
// Sembra un'assegnazione sicura, ma lancia NPE!
int b = a; 
    \end{lstlisting}
    Poiché l'unboxing invoca \texttt{a.intValue()}, se \texttt{a} è \texttt{null}, l'applicazione va in crash. Questo è un bug frequente quando si lavora con database che ammettono valori NULL su colonne numeriche.
\end{deepdive}

\subsection{La Trappola della Integer Cache}
Questa è una domanda da colloquio "filtro". Serve a capire se il candidato conosce la gestione della memoria o va a caso.

\begin{interview}{Perché 128 diverso da 128?}
    \textbf{Domanda:} "Analizza questo codice. Cosa viene stampato e perché?"
    \begin{lstlisting}[language=Java]
Integer a = 100;
Integer b = 100;
System.out.println(a == b); // Stampa TRUE

Integer c = 1000;
Integer d = 1000;
System.out.println(c == d); // Stampa FALSE
    \end{lstlisting}
    
    \textbf{Risposta:}
    \begin{itemize}
        \item \textbf{Il caso 100:} Java mantiene una \textbf{Cache} interna per gli oggetti \texttt{Integer} piccoli (da \textbf{-128 a 127}). Quando scrivi \texttt{Integer a = 100}, Java vede che 100 è nel range e ti restituisce l'istanza già esistente nella cache. Quindi \texttt{a} e \texttt{b} puntano allo stesso oggetto fisico.
        \item \textbf{Il caso 1000:} 1000 è fuori dal range di cache. Java è costretto a creare due \textbf{nuovi} oggetti nello Heap. Quindi \texttt{c} e \texttt{d} hanno indirizzi di memoria diversi.
    \end{itemize}
    
    \textbf{Lezione:} Mai usare \texttt{==} per confrontare Wrapper Objects. Usa sempre \texttt{.equals()}, che funziona per tutti i valori.
\end{interview}

\subsection{Costo in Memoria: Primitivi vs Wrapper}
Usare i Wrapper ha un costo significativo in termini di RAM (Footprint).

\begin{itemize}
    \item \textbf{\texttt{int}:} Occupa \textbf{4 byte} sullo Stack (o nel corpo dell'oggetto).
    \item \textbf{\texttt{Integer}:} È un oggetto completo.
    \begin{itemize}
        \item 16 byte di Header (su 64-bit JVM).
        \item 4 byte per il valore int.
        \item Padding per allineamento.
        \item \textbf{Totale:} Circa \textbf{24 byte} + il riferimento (4-8 byte).
    \end{itemize}
\end{itemize}

\textbf{Conclusione:} Un \texttt{int[]} di 1 milione di elementi occupa $\approx$ 4 MB. Un \texttt{Integer[]} (o \texttt{ArrayList<Integer>}) ne occupa oltre 24 MB. Nelle applicazioni ad alte performance, preferire array di primitivi o librerie come \textit{Eclipse Collections} che offrono liste di primitivi.

\section{Enums: Molto più di costanti}

In linguaggi come C o C++, un'enumerazione è poco più di una lista di interi glorificata.
In Java, \texttt{enum} è una \textbf{Classe} vera e propria (che estende implicitamente \texttt{java.lang.Enum}).

Questo significa che le Enum possono avere:
\begin{itemize}
    \item \textbf{Campi di istanza} (stato).
    \item \textbf{Costruttori} (sempre privati).
    \item \textbf{Metodi} (concreti o astratti).
    \item Possono implementare \textbf{Interfacce}.
\end{itemize}

\subsection{Enum con Stato e Comportamento}
Un caso d'uso tipico nel backend è mappare codici di stato del database o codici di errore HTTP.

\begin{lstlisting}[language=Java, caption=Enum Avanzata]
public enum OrderStatus {
    PENDING(1, "In attesa di pagamento"),
    SHIPPED(2, "Spedito"),
    DELIVERED(3, "Consegnato"),
    CANCELLED(99, "Annullato");

    // Campi final (Best Practice: le enum dovrebbero essere immutabili)
    private final int dbCode;
    private final String description;

    // Costruttore (Implicitamente private)
    OrderStatus(int dbCode, String description) {
        this.dbCode = dbCode;
        this.description = description;
    }

    // Metodo di utility per lookup inverso (da DB a Enum)
    public static OrderStatus fromCode(int code) {
        for (OrderStatus status : values()) {
            if (status.dbCode == code) return status;
        }
        throw new IllegalArgumentException("Codice non valido: " + code);
    }
}
\end{lstlisting}

\subsection{Il Singleton Pattern con Enum}
Questa è una delle domande "Senior" più apprezzate.

\begin{interview}{Qual è il modo più sicuro per creare un Singleton?}
    \textbf{Domanda:} "Come implementi un Singleton che sia Thread-Safe e resistente alla Serializzazione?"
    
    \textbf{Risposta:} Non usare il \textit{Double-Checked Locking} o la \textit{Lazy Initialization} manuale. Usa una \textbf{Enum a singolo elemento}.
    
    \begin{lstlisting}[language=Java]
public enum DatabaseConnection {
    INSTANCE; // L'unica istanza esistente
    
    public void executeQuery(String sql) {
        // Logica di connessione...
    }
}
    \end{lstlisting}
    
    \textbf{Perché è migliore?}
    \begin{enumerate}
        \item \textbf{Thread-Safety Gratuita:} La JVM garantisce che le istanze delle Enum vengano create una volta sola, in modo atomico, al caricamento della classe.
        \item \textbf{Serializzazione Sicura:} Se serializzi e deserializzi un Singleton classico, potresti creare una seconda istanza. Le Enum sono protette nativamente dalla JVM contro questo problema (e anche contro gli attacchi via Reflection).
    \end{enumerate}
\end{interview}

\subsection{Enum e il Polimorfismo (Strategy Pattern)}
Le Enum possono avere metodi astratti. Questo permette a ogni costante di definire un comportamento diverso. È un modo molto elegante di implementare lo \textbf{Strategy Pattern} senza creare decine di file separati.

\begin{lstlisting}[language=Java, caption=Enum con Metodi Astratti]
public enum Operation {
    PLUS   { double apply(double x, double y) { return x + y; } },
    MINUS  { double apply(double x, double y) { return x - y; } },
    TIMES  { double apply(double x, double y) { return x * y; } },
    DIVIDE { double apply(double x, double y) { return x / y; } };

    // Ogni costante DEVE implementare questo metodo
    abstract double apply(double x, double y);
}

// Uso:
double result = Operation.PLUS.apply(2, 3); // 5.0
\end{lstlisting}

\section{Array: Basso livello}

Gli array sono la struttura dati più semplice e vicina all'hardware. In Java, sono oggetti a dimensione fissa che memorizzano elementi dello stesso tipo in modo sequenziale in memoria.
Nonostante la comodità delle `ArrayList`, gli array sono ancora imbattibili per performance pura.

\subsection{Efficienza in Memoria: Primitivi vs Oggetti}
La differenza di layout in memoria tra un array di primitivi e uno di oggetti è drammatica.

\begin{itemize}
    \item \textbf{\texttt{int[]}:} Contiene i valori grezzi (es. 10, 20, 30) stoccati in un blocco di memoria \textbf{contiguo}. La CPU li adora perché può caricarli nella Cache L1 in blocco, massimizzando la velocità di iterazione.
    \item \textbf{\texttt{Integer[]}:} È un array di \textbf{riferimenti} (puntatori).
    \begin{itemize}
        \item L'array contiene solo indirizzi di memoria.
        \item Gli oggetti \texttt{Integer} reali sono sparsi ("scattered") casualmente nello Heap.
        \item Iterare su questo array causa continui salti di memoria (\textit{Cache Miss}), rallentando drasticamente l'esecuzione.
    \end{itemize}
\end{itemize}

\subsection{Il trabocchetto della Covarianza}
Questa è una domanda teorica avanzata che mette in crisi molti sviluppatori.

\begin{interview}{Array Covarianti vs Generics Invarianti}
    \textbf{Domanda:} "Perché questo codice compila ma fallisce a runtime?"
    \begin{lstlisting}[language=Java]
Object[] objArr = new String[10]; // Compila!
objArr[0] = 100; // Lancia ArrayStoreException a Runtime
    \end{lstlisting}
    
    \textbf{Risposta:}
    \begin{itemize}
        \item Gli \textbf{Array sono Covarianti:} Se \texttt{String} è sottotipo di \texttt{Object}, allora \texttt{String[]} è considerato sottotipo di \texttt{Object[]}. Java ti permette di trattarlo come un array generico, ma a runtime controlla ogni inserimento. Se provi a mettere un \texttt{Integer} in un array che fisicamente è di \texttt{String}, la JVM lancia un'eccezione.
        \item I \textbf{Generics (\texttt{List<T>}) sono Invarianti:} \texttt{List<String>} \textbf{NON} è sottotipo di \texttt{List<Object>}.
        Il compilatore blocca subito il codice:
        \texttt{List<Object> l = new ArrayList<String>(); // ERRORE DI COMPILAZIONE}
        Questo garantisce la \textbf{Type Safety} a tempo di compilazione, che è molto più sicura.
    \end{itemize}
\end{interview}

\subsection{Utility Class: java.util.Arrays}
Mai reinventare la ruota. La classe \texttt{Arrays} offre algoritmi altamente ottimizzati.

\begin{itemize}
    \item \textbf{\texttt{sort()}}:\\
    Usa \textbf{Dual-Pivot Quicksort} per i primitivi (veloce, $O(n \log n)$, instabile).\\
    Usa \textbf{Timsort} (MergeSort + InsertionSort) per gli oggetti (stabile, garantisce che oggetti uguali mantengano l'ordine relativo).
    
    \item \textbf{\texttt{binarySearch()}}:\\
    Esegue una ricerca logaritmica ($O(\log n)$) su array \textbf{già ordinati}. Se l'array non è ordinato, il risultato è indefinito.
\end{itemize}

\begin{deepdive}{La trappola di Arrays.asList()}
    Il metodo \texttt{Arrays.asList(1, 2, 3)} restituisce una \texttt{List}, ma non è una \texttt{java.util.ArrayList} standard!
    È una classe interna (\texttt{Arrays\$ArrayList}) che fa da "wrapper" (vista) sull'array originale.
    
    \textbf{Conseguenze:}
    \begin{itemize}
        \item La lista è a \textbf{dimensione fissa}.
        \item \texttt{get()} e \texttt{set()} funzionano (modificano l'array sottostante).
        \item \textbf{\texttt{add()} e \texttt{remove()} lanciano \texttt{UnsupportedOperationException}.}
    \end{itemize}
    
    \textbf{Soluzione:} Se vuoi una lista modificabile, avvolgila:
    \texttt{new ArrayList<>(Arrays.asList(...))}.
\end{deepdive}

\section{Date e Tempo (Java Time API)}

Fino a Java 7, la gestione del tempo era affidata alle classi \texttt{java.util.Date} e \texttt{java.util.Calendar}. Queste classi sono note per essere \textbf{problematiche} sotto ogni punto di vista.
Java 8 ha introdotto il package \texttt{java.time} (basato su Joda-Time), che risolve definitivamente questi problemi.

\subsection{Perché java.util.Date è "il male"?}
Se un intervistatore ti chiede perché non usi \texttt{Date}, ecco i motivi tecnici:

\begin{enumerate}
    \item \textbf{Mutabilità:} \texttt{Date} è mutabile. Se passi una data a un metodo, quel metodo può cambiarla (usando \texttt{setTime()}) influenzando il chiamante. Questo rompe l'incapsulamento e crea bug di concorrenza.
    \item \textbf{Non Thread-Safe:} La classe \texttt{SimpleDateFormat} (usata per il parsing) non è thread-safe. Se condivisa in una variabile statica tra più thread, fallisce miseramente lanciando eccezioni strane.
    \item \textbf{Design Confuso:} Gli anni partono da 1900 (quindi l'anno 2023 è 123), i mesi partono da 0 (Gennaio = 0).
\end{enumerate}

\subsection{La Rivoluzione di Java 8: java.time}
Le nuove classi sono \textbf{Immutabili}, \textbf{Thread-Safe} e semanticamente chiare.
Bisogna scegliere la classe giusta in base al contesto.

\begin{table}[h]
\centering
\rowcolors{2}{gray!10}{white}
\renewcommand{\arraystretch}{1.3}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{deepblue} \textbf{\textcolor{white}{Classe}} & \textbf{\textcolor{white}{Cosa Rappresenta}} \\
\hline
\texttt{LocalDate} & Solo una data (Anno-Mese-Giorno). Senza orario, senza fuso orario. \textit{Esempio: Compleanno, Scadenza fattura.} \\
\hline
\texttt{LocalTime} & Solo un orario (Ore-Minuti-Secondi). Senza data. \textit{Esempio: Orario di apertura negozio.} \\
\hline
\texttt{LocalDateTime} & Data + Orario. Senza fuso orario. \textit{Esempio: Un evento nel calendario personale.} \\
\hline
\texttt{ZonedDateTime} & Data + Orario + Fuso Orario. \textit{Esempio: Una riunione internazionale (zoom call).} \\
\hline
\texttt{Instant} & Un punto preciso sulla linea temporale (Timestamp UTC). Rappresenta i secondi passati dal 1970 (Epoch). \textit{Uso: Log di sistema, salvataggio su DB.} \\
\hline
\end{tabularx}
\end{table}

\subsection{Aritmetica delle Date: Period vs Duration}
Poiché le classi sono immutabili, ogni operazione di modifica restituisce una \textbf{nuova istanza} (stile \texttt{String}).

\begin{lstlisting}[language=Java, caption=Manipolazione Date]
LocalDate oggi = LocalDate.now(); 
// Chaining fluente
LocalDate scadenza = oggi.plusDays(30).plusMonths(1);

// Parsing Thread-Safe
DateTimeFormatter fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate data = LocalDate.parse("25/12/2023", fmt);
\end{lstlisting}

\begin{interview}{Period vs Duration}
    \textbf{Domanda:} "Come calcolo la differenza tra due date?"
    
    \textbf{Risposta:} Dipende se vuoi ragionare in termini "umani" o "macchina".
    \begin{itemize}
        \item \textbf{Period:} Misura il tempo in Anni, Mesi e Giorni (Human Time). Tiene conto delle irregolarità (anni bisestili, mesi di 30/31 giorni).
        \textit{Esempio: Tra oggi e il prossimo compleanno.}
        \item \textbf{Duration:} Misura il tempo in Secondi e Nanosecondi (Machine Time). È una misura fisica esatta.
        \textit{Esempio: Quanto tempo è durata l'esecuzione di questo metodo?}
    \end{itemize}
\end{interview}

\section{Optional e Null Safety}

Il \texttt{NullPointerException} (NPE) è stato definito dal suo inventore, Tony Hoare, come il suo "errore da un miliardo di dollari".
Prima di Java 8, l'unico modo per evitare crash era riempire il codice di controlli difensivi (\texttt{if (x != null)}).

Java 8 ha introdotto \texttt{java.util.Optional<T>}, un contenitore che può contenere un valore non-null oppure essere vuoto.
L'obiettivo non è eliminare il \texttt{null} dal linguaggio, ma permettere alle API di esprimere chiaramente l'intento: \textit{"Questo metodo potrebbe non restituire nulla, gestiscilo!"}.

\subsection{L'approccio Funzionale (The Right Way)}
L'errore del principiante è usare \texttt{Optional} come se fosse un normale controllo null (usando \texttt{isPresent()} e \texttt{get()}).
L'approccio corretto è usare la catena funzionale.

\begin{lstlisting}[language=Java, caption=Vecchio Stile vs Optional]
// VECCHIO STILE (Prono a errori)
User user = repo.findById(1);
String city = "Sconosciuta";
if (user != null) {
    Address addr = user.getAddress();
    if (addr != null) {
        city = addr.getCity();
    }
}

// STILE MODERNO (Optional)
String city = repo.findById(1) // Ritorna Optional<User>
    .map(User::getAddress)     // Se c'è user, prendi address. Se no, salta.
    .map(Address::getCity)     // Se c'è address, prendi city.
    .orElse("Sconosciuta");    // Se qualcosa mancava, usa default.
\end{lstlisting}

\subsection{Best Practices e Anti-Patterns}
L'\texttt{Optional} va usato con disciplina.

\begin{deepdive}{Dove NON usare Optional}
    \begin{enumerate}
        \item \textbf{Mai come parametro di un metodo:}
        \texttt{void method(Optional<String> s)} è sbagliato. Obbliga il chiamante a wrappare i dati e non ti salva dal fatto che l'\texttt{Optional} stesso potrebbe essere \texttt{null}. Usa l'overloading dei metodi.
        \item \textbf{Mai come campo di una classe:}
        \texttt{Optional} non è serializzabile. Se lo metti in un DTO o in una Entity JPA, avrai problemi di serializzazione e spreco di memoria. Usa \texttt{null} per i campi privati e \texttt{Optional} solo nel getter pubblico (se necessario).
        \item \textbf{Mai nelle Collezioni:}
        \texttt{List<Optional<String>>} è un abominio. Non mettere valori assenti in una lista; semplicemente non aggiungerli.
    \end{enumerate}
    \textbf{Regola:} Usa \texttt{Optional} quasi esclusivamente come \textbf{valore di ritorno} di un metodo.
\end{deepdive}

\subsection{Performance: orElse() vs orElseGet()}
Questa è una domanda sottile sulle performance.

\begin{interview}{Differenza tra orElse e orElseGet}
    Entrambi forniscono un valore di default se l'Optional è vuoto.
    
    \begin{itemize}
        \item \textbf{\texttt{orElse(T other)}:} Il valore di default viene valutato (istanziato) \textbf{sempre}, anche se l'Optional è pieno.
        \item \textbf{\texttt{orElseGet(Supplier<? extends T> s)}:} Il valore di default viene valutato \textbf{lazy} (solo se l'Optional è effettivamente vuoto).
    \end{itemize}
    
    \textbf{Esempio:}
    \begin{verbatim}
    // "Calcolo pesante..." viene eseguito SEMPRE, anche se opt è pieno!
    opt.orElse(metodoPesante()); 

    // "Calcolo pesante..." viene eseguito SOLO se opt è vuoto.
    opt.orElseGet(() -> metodoPesante());
    \end{verbatim}
    
    \textbf{Consiglio:} Se il default è una stringa costante (""), usa \texttt{orElse}. Se è una chiamata a DB o un oggetto da istanziare, usa \texttt{orElseGet}.
\end{interview}

\subsection{Metodi da conoscere}
\begin{itemize}
    \item \texttt{ifPresent(Consumer)}: Esegui un'azione solo se c'è un valore (es. loggare).
    \item \texttt{orElseThrow()}: Restituisci il valore o lancia un'eccezione (preferibile a \texttt{get()}, che lancia \texttt{NoSuchElementException} senza un messaggio chiaro).
    \item \texttt{filter(Predicate)}: Se il valore c'è ma non soddisfa la condizione, l'Optional diventa vuoto.
\end{itemize}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Persistenza su File System}

Sebbene i Database Relazionali siano lo standard per i dati strutturati e relazionali, il File System rimane la scelta primaria per:
\begin{itemize}
    \item \textbf{Configurazioni:} (es. \texttt{application.properties}, XML, YAML).
    \item \textbf{Dati Non Strutturati (BLOB):} Immagini, PDF, Video. Salvarli nel DB è spesso un anti-pattern; meglio salvare il percorso (path) nel DB e il file fisico su disco (o su Cloud Storage come S3).
    \item \textbf{Log:} Registrazione eventi e monitoraggio.
    \item \textbf{Data Exchange:} CSV per l'import/export massivo.
\end{itemize}

Java ha subito una profonda evoluzione nella gestione dei file. Dobbiamo distinguere tra il vecchio mondo (\texttt{java.io}) e il nuovo mondo (\texttt{java.nio}).

\section{Java IO(Legacy): Stream}
Quando leggiamo o scriviamo su file, non carichiamo (quasi) mai tutto in blocco. Usiamo gli \textbf{Stream} (flussi).
Immagina un tubo dell'acqua: i dati scorrono byte dopo byte.

La distinzione fondamentale in Java è tra \textbf{Byte} e \textbf{Caratteri}.

\begin{center}
\begin{tikzpicture}[
    level 1/.style={sibling distance=6cm},
    level 2/.style={sibling distance=3cm},
    edge from parent/.style={draw, -latex},
    box/.style={rectangle, draw=deepblue, rounded corners, fill=white, align=center, minimum height=0.8cm}
]
    \node[box, fill=gray!10] {\textbf{Java I/O}}
        child { node[box] {\textbf{Byte Oriented}\\(Immagini, Video, Audio)}
            child { node[box] {\texttt{InputStream}}}
            child { node[box] {\texttt{OutputStream}}}
        }
        child { node[box] {\textbf{Character Oriented}\\(Testo: .txt, .json, .xml)}
            child { node[box] {\texttt{Reader}}}
            child { node[box] {\texttt{Writer}}}
        };
\end{tikzpicture}
\end{center}

\begin{interview}{Perché esistono Reader e Writer?}
\textbf{Domanda:} "Perché non usiamo sempre InputStream anche per i file di testo?"

\textbf{Risposta:} A causa dell'\textbf{Encoding} (UTF-8, ISO-8859-1).
Un carattere (come una lettera accentata o un simbolo speciale) può occupare più di 1 byte.
\begin{itemize}
    \item \texttt{InputStream} legge byte crudi (01010100). Non sa cosa sia una lettera.
    \item \texttt{Reader} è un wrapper intelligente: legge i byte, decodifica il Charset e ti restituisce caratteri \texttt{char} o \texttt{String} leggibili.
\end{itemize}
\end{interview}

\section{Il Grande Divario: IO vs NIO}

La differenza principale sta nel modo in cui i dati vengono movimentati.

\subsection{Java IO (Legacy): Stream Oriented}
Il pacchetto \texttt{java.io} (es. \texttt{FileInputStream}) è basato sugli \textbf{Stream}.
\begin{itemize}
    \item \textbf{Flusso Continuo:} Leggi un byte alla volta. Non puoi andare avanti e indietro nel file (a meno di non chiudere e riaprire).
    \item \textbf{Blocking:} Quando chiedi di leggere un dato, il thread si blocca finché il dato non arriva. Se la rete è lenta o il disco è occupato, il thread rimane "appeso", sprecando risorse.
\end{itemize}

\subsection{Java NIO (New IO): Block Oriented}
Introdotto per alta scalabilità, \texttt{java.nio} gestisce i dati a \textbf{Blocchi}.
\begin{itemize}
    \item \textbf{Buffer e Channel:} I dati vengono letti da un canale (Channel) e scaricati in un blocco di memoria (Buffer). Puoi muoverti avanti e indietro nel buffer liberamente.
    \item \textbf{Non-Blocking:} Un thread può chiedere al canale di leggere dati e, intanto che aspetta, fare altro.
\end{itemize}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Caratteristica} & \textbf{Java IO (Stream)} & \textbf{Java NIO (Buffer)} \\
\hline
Unità di dati & Byte o Caratteri singoli & Blocchi di dati \\
Navigazione & Sequenziale (Solo avanti) & Casuale (Avanti/Indietro nel Buffer) \\
Modello Thread & Bloccante (Wait) & Non Bloccante (Selector) \\
Utilizzo & File piccoli, semplicità & Server ad alto traffico, File enormi \\
\hline
\end{tabular}
\caption{Confronto architetturale IO vs NIO}
\end{table}

\section{Le Interfacce Chiave di NIO}

Mentre in IO usavamo solo Stream, in NIO abbiamo tre componenti che lavorano insieme:

\begin{enumerate}
    \item \textbf{Channel (Il Canale):} 
    È l'equivalente moderno dello Stream, ma bidirezionale. Immaginalo come una galleria ferroviaria che collega il tuo programma al file (o al socket). Un \texttt{FileChannel} può sia leggere che scrivere.
    
    \item \textbf{Buffer (Il Vagone):}
    È un contenitore di memoria (un array wrapper). Il Channel scarica i dati qui dentro. Tu non leggi mai direttamente dal Channel, leggi dal Buffer.
    Esistono \texttt{ByteBuffer}, \texttt{CharBuffer}, ecc.
    
    \item \textbf{Selector (Il Controllore):}
    Permette a un singolo thread di monitorare molteplici Channel. È fondamentale nei server (es. Tomcat, Netty), meno nell'uso semplice dei file su disco.
\end{enumerate}

\section{L'API Moderna: java.nio.file (NIO.2)}

Per lo sviluppatore che deve "solo salvare un file", usare direttamente Channel e Buffer è complesso. Java 7 ha introdotto NIO.2, che nasconde la complessità offrendo API di alto livello basate su \texttt{Path}.

\subsection{Path vs File}
\begin{itemize}
    \item \textbf{File (Legacy):} Rappresentava un percorso ma aveva metodi limitati. Se un'operazione falliva, spesso restituiva \texttt{false} senza dire perché.
    \item \textbf{Path (Moderno):} È l'interfaccia che sostituisce \texttt{File}. È immutabile, più flessibile e supporta i collegamenti simbolici.
\end{itemize}

\begin{lstlisting}[language=Java, caption={Esempio: Operazioni con NIO.2}]
// Creazione del path (indipendente dal sistema operativo)
Path path = Paths.get("dati", "export.csv");

// Verifica esistenza
if (Files.notExists(path)) {
    try {
        // Crea file (lancia eccezione dettagliata se fallisce!)
        Files.createFile(path); 
        
        // Copia
        Path backup = path.resolveSibling("export_bkp.csv");
        Files.copy(path, backup, StandardCopyOption.REPLACE_EXISTING);
        
    } catch (IOException e) {
        // Qui sappiamo ESATTAMENTE cosa è andato storto (es. AccessDenied)
        e.printStackTrace();
    }
}
\end{lstlisting}

\section{Performance: Buffered vs Unbuffered}

Questa è la distinzione più importante per le performance di I/O.
Spesso vedrai usare \texttt{FileReader} (standard) o \texttt{BufferedReader}. Qual è la differenza?

\subsection{Reader/Writer Standard (Unbuffered)}
Ogni chiamata a \texttt{read()} o \texttt{write()} invoca direttamente il Sistema Operativo.
Se devi scrivere 1000 caratteri:
\begin{itemize}
    \item Il tuo programma chiama la JVM.
    \item La JVM chiama il Kernel (System Call).
    \item Il Kernel scrive 1 byte sul disco.
\end{itemize}
Risultato: \textbf{1000 System Call}. Lento e inefficiente.

\subsection{BufferedReader/BufferedWriter (Buffered)}
Queste classi usano un'area di memoria interna (buffer, solitamente 8KB) come "zona di sosta".
Quando scrivi 1000 caratteri:
\begin{itemize}
    \item Il carattere viene copiato nel buffer in RAM (velocissimo).
    \item Solo quando il buffer è pieno (o fai \texttt{flush()}), la JVM chiama il Kernel \textbf{una sola volta} per scaricare tutto.
\end{itemize}
Risultato: \textbf{1 System Call}.

\begin{deepdive}{System Call Overhead}
Passare dallo spazio Utente allo spazio Kernel (Context Switch) è costoso per la CPU. Usare i Buffer riduce questi viaggi, migliorando le performance anche di 100 volte.
\end{deepdive}

\begin{lstlisting}[language=Java, caption={Best Practice: Lettura Bufferizzata con NIO}]
Path logPath = Path.of("server.log");

// Files.newBufferedReader crea un Reader bufferizzato efficiente
try (BufferedReader reader = Files.newBufferedReader(logPath)) {
    
    String line;
    // Leggiamo riga per riga (impossibile con FileReader base)
    while ((line = reader.readLine()) != null) {
        if (line.contains("ERROR")) {
            System.out.println("Trovato errore: " + line);
        }
    }
} catch (IOException e) {
    e.printStackTrace();
}
\end{lstlisting}

\begin{interview}{Quando NON usare i Buffer?}
\textbf{Domanda:} "Esiste un caso in cui è meglio non usare il buffering?"

\textbf{Risposta:} Sì, ma raro.
Se devi scrivere un sistema di log Real-Time critico (es. scatola nera aerea) dove i dati devono essere su disco istantaneamente. Se usi il buffer e l'app crasha prima del \texttt{flush()}, perdi gli ultimi dati rimasti in RAM.
In questi casi si usa \texttt{FileChannel.force(true)} per obbligare la scrittura fisica immediata.
\end{interview}

\section{Scrittura Rapida (Java 11+)}
Per casi semplici (file di configurazione, piccoli JSON), Java 11 ha introdotto metodi che gestiscono buffer e chiusura internamente:

\begin{lstlisting}[language=Java]
Path p = Path.of("config.json");
// Scrive tutto in un colpo solo (usa buffer internamente)
Files.writeString(p, "{ \"version\": 1 }"); 

// Legge tutto in memoria
String content = Files.readString(p);
\end{lstlisting}

\section{Gestione delle Risorse e Locking}

Quando lavoriamo con i file, stiamo toccando risorse del Sistema Operativo. Due concetti sono vitali:

\begin{enumerate}
    \item \textbf{Chiusura (Close):} I "file handles" (descrittori di file) sono limitati. Se non chiudi gli stream, il file rimane bloccato (su Windows non potrai cancellarlo) e alla fine l'app crasherà con l'errore "Too many open files". Usa sempre il pattern \textbf{try-with-resources}.
    
    \item \textbf{File Locking:} Se due processi Java (o Java e un editor di testo esterno) provano a scrivere lo stesso file contemporaneamente, i dati si corrompono. Java NIO offre il \texttt{FileLock} per bloccare un file a livello di OS.
\end{enumerate}

\begin{lstlisting}[language=Java, caption={Locking di un file}]
// Apre il canale e tenta di acquisire il lock esclusivo
try (FileChannel channel = FileChannel.open(path, StandardOpenOption.WRITE);
     FileLock lock = channel.lock()) { // Blocca finché non ottiene accesso
     
    // Qui scriviamo in sicurezza...
    System.out.println("Ho il controllo esclusivo del file!");
    
} // Il lock viene rilasciato automaticamente qui
\end{lstlisting}

\section{Serializzazione Java}

La serializzazione è il meccanismo che permette di convertire lo stato di un oggetto (i valori delle sue variabili di istanza) in un flusso di byte. Questo stream può essere:
\begin{itemize}
    \item Salvato su disco (persistenza).
    \item Inviato attraverso una rete (es. RMI, socket).
    \item Memorizzato in cache o in un database.
\end{itemize}

Per rendere una classe serializzabile, essa deve implementare l'interfaccia "marker" (senza metodi) \texttt{java.io.Serializable}.

\subsection{Esempio di implementazione}
Ecco come avviene la scrittura (serializzazione) e la lettura (deserializzazione) utilizzando gli stream di I/O:

\begin{lstlisting}
// Scrittura su file (Serializzazione)
try (ObjectOutputStream oos = new ObjectOutputStream(
        new FileOutputStream("user.ser"))) {
    User user = new User("Alessandro", "passwordSegreta");
    oos.writeObject(user);
}

// Lettura da file (Deserializzazione)
try (ObjectInputStream ois = new ObjectInputStream(
        new FileInputStream("user.ser"))) {
    User userCaricato = (User) ois.readObject();
    // Nota: Il costruttore NON viene invocato durante la deserializzazione!
}
\end{lstlisting}

\begin{interview}{A cosa serve esattamente \texttt{serialVersionUID}?}
    È un identificativo univoco di versione per la classe \texttt{Serializable}. La JVM lo usa per verificare che il mittente e il destinatario abbiano caricato classi compatibili per quell'oggetto.
    
    \textbf{Il problema:} Se non lo dichiari, Java ne calcola uno automaticamente basandosi su metodi, campi e nome della classe. Se cambi anche solo una virgola o aggiungi un metodo, l'hash cambia.
    
    \textbf{Lo scenario di errore:}
    \begin{enumerate}
        \item Serializzi un oggetto \texttt{User} su file.
        \item Aggiungi un campo \texttt{private String email} alla classe \texttt{User}.
        \item Provi a leggere il file vecchio.
    \end{enumerate}
    Senza un UID esplicito, otterrai una \texttt{java.io.InvalidClassException}.
    
    \textbf{La soluzione:}
    Definendo \texttt{private static final long serialVersionUID = 1L;}, dici alla JVM: "Fidati, questa classe è compatibile con la versione precedente", permettendo la deserializzazione (i nuovi campi assumeranno il valore di default).
\end{interview}

\subsection{La keyword \texttt{transient}}
Se un campo contiene dati sensibili (come password) o riferimenti a oggetti che non possono essere serializzati (come thread, stream aperti o connessioni al DB), deve essere marcato come \texttt{transient}.

Durante il processo di serializzazione, i campi \texttt{transient} vengono ignorati.

\begin{lstlisting}
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String username;
    private transient String password; // Non finisce nel flusso di byte
    
    // Al momento della deserializzazione:
    // username -> avra' il valore salvato.
    // password -> sara' null (o il default per il tipo primitivo).
}
\end{lstlisting}

\begin{deepdive}{Perché la Serializzazione Java è "Deprecated" nell'industria?}
    Sebbene sia ancora parte del JDK, la serializzazione nativa è sconsigliata nei nuovi progetti per due motivi principali:
    
    \begin{enumerate}
        \item \textbf{Sicurezza (Deserialization Vulnerabilities):} È uno dei vettori di attacco più gravi. Se un attaccante riesce a manipolare il flusso di byte in ingresso, può istanziare classi arbitrarie presenti nel classpath, portando spesso a \textit{Remote Code Execution} (RCE).
        \item \textbf{Performance e Accoppiamento:} Il formato binario di Java è verboso, lento e lega strettamente i client al linguaggio Java.
    \end{enumerate}
    
    \textbf{Alternative moderne:} Oggi si preferisce serializzare in formati testuali agnostici come \textbf{JSON} (usando librerie come Jackson o Gson) o formati binari efficienti come \textbf{Protocol Buffers} o \textbf{Avro}.
\end{deepdive}


\part{Java Avanzato e Moderno}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Exception Handling}

Gestire gli errori non significa solo evitare che l'applicazione vada in crash. Significa fornire informazioni utili per il debug e garantire che lo stato del sistema rimanga coerente anche dopo un fallimento.

\section{Gerarchia: Checked vs Unchecked Errors}

Tutto parte dalla classe madre \texttt{java.lang.Throwable}. Da qui si diramano due rami principali:

\begin{enumerate}
    \item \textbf{Error:} Problemi gravi della JVM (es. \texttt{OutOfMemoryError}, \texttt{StackOverflowError}). L'applicazione non può recuperarli. \textbf{Non vanno mai catchati}.
    \item \textbf{Exception:} Problemi che l'applicazione potrebbe gestire. Si dividono in:
    \begin{itemize}
        \item \textbf{Checked Exceptions (Compile-time):} Estendono \texttt{Exception} (ma non \texttt{RuntimeException}). Il compilatore \textbf{obbliga} a gestirle (\texttt{try-catch} o \texttt{throws}). Rappresentano errori esterni previsti (es. File non trovato, Network down).
        \item \textbf{Unchecked Exceptions (Runtime):} Estendono \texttt{RuntimeException}. Il compilatore non impone nulla. Rappresentano errori di logica del programmatore (es. \texttt{NullPointerException}, \texttt{IndexOutOfBounds}).
    \end{itemize}
\end{enumerate}

\begin{interview}{Spring e le Checked Exceptions}

In Java esistono due grandi categorie di eccezioni: \textit{Checked} e \textit{Unchecked}.  
Le \textit{Checked Exceptions} (come \texttt{SQLException}) sono obbligatorie da gestire: il compilatore forza chi scrive il codice a usare un \texttt{try/catch} oppure a dichiararle con \texttt{throws}.  

Questo comportamento, però, crea un effetto a catena: se un metodo lancia una Checked Exception, anche tutti i metodi che lo chiamano devono dichiararla, anche quando non sono in grado di gestirla realmente. Questo porta a:

\begin{itemize}
    \item firme dei metodi piene di \texttt{throws}
    \item codice più rumoroso e meno leggibile
    \item livelli dell'applicazione che conoscono dettagli che non dovrebbero conoscere
\end{itemize}

In altre parole, le Checked Exceptions tendono a \textbf{sporcare il codice} e a \textbf{rompere l'incapsulamento}, perché costringono livelli come Service e Controller a sapere che sotto esiste, ad esempio, un database SQL.

Per questo motivo, framework moderni come Spring e Hibernate convertono le \textit{Checked Exceptions} in \textit{Unchecked Exceptions}.  
Ad esempio, una \texttt{SQLException} viene trasformata in una \texttt{DataAccessException}, che è una \texttt{RuntimeException}.

Questo approccio permette di:

\begin{itemize}
    \item mantenere le firme dei metodi pulite
    \item rispettare l'incapsulamento tra i livelli
    \item centralizzare la gestione degli errori in un punto più appropriato
\end{itemize}

L'errore non viene nascosto: continua a propagarsi, ma senza imporre vincoli artificiali a tutto il codice circostante.

\end{interview}

\begin{deepdive}{Il Costo delle Eccezioni}
Lanciare un'eccezione è un'operazione \textbf{costosa} in termini di performance.
La parte più pesante non è la creazione dell'oggetto, ma il metodo \texttt{fillInStackTrace()}, che deve scansionare lo stack dei thread per costruire la traccia dell'errore.
\textbf{Consiglio:} Non usare le eccezioni per il controllo del flusso (es. uscire da un loop). Usa le eccezioni solo per situazioni davvero eccezionali.
\end{deepdive}

\section{Best Practices: Throw early, catch late}

Questa è la filosofia d'oro per un codice robusto.

\subsection{1. Throw Early (Fallire presto)}
Valida gli input all'inizio del metodo. Se i dati non sono validi, lancia subito un'eccezione. Evita di eseguire metà logica per poi fallire.
\begin{lstlisting}
public void processa(String input) {
    if (input == null) {
        throw new IllegalArgumentException("Input non puo' essere null");
    }
    // ... logica ...
}
\end{lstlisting}

\subsection{2. Catch Late (Gestire tardi)}
Non catturare un'eccezione se non sai come gestirla. È meglio lasciarla risalire fino a un livello superiore (es. un \texttt{@ControllerAdvice} in Spring) che può loggarla correttamente e mostrare un errore sensato all'utente.
\textbf{Anti-Pattern (Swallowing):}
\begin{lstlisting}
try {
    // code
} catch (Exception e) {
    e.printStackTrace(); // MAI FARLO IN PRODUZIONE! Logga su StdOut e perde il contesto.
    // Oppure peggio: blocco vuoto. L'errore viene "ingoiato".
}
\end{lstlisting}

\subsection{3. Exception Chaining (Incapsulamento)}
Quando catturi un'eccezione di basso livello per lanciarne una di alto livello, \textbf{passa sempre l'eccezione originale} nel costruttore. Altrimenti perdi lo stack trace originale (Root Cause).

\begin{lstlisting}
try {
    fileReader.read();
} catch (IOException e) {
    // Corretto: 'e' viene passata come 'cause'
    throw new DatabaseException("Errore lettura config", e);
}
\end{lstlisting}

\section{Try-with-resources e AutoCloseable}

Fino a Java 6, la chiusura delle risorse (Stream, Connessioni DB) si faceva nel blocco \texttt{finally}, portando a codice verboso e rischio di leak se il programmatore dimenticava la chiusura.

Da Java 7, esiste il \textbf{Try-with-resources}. Qualsiasi oggetto che implementa l'interfaccia \texttt{AutoCloseable} può essere dichiarato tra le parentesi tonde del \texttt{try}.

\begin{lstlisting}[caption=Gestione Risorse Moderna]
// La risorsa viene chiusa AUTOMATICAMENTE alla fine del blocco
try (BufferedReader br = new BufferedReader(new FileReader(path))) {
    return br.readLine();
} catch (IOException e) {
    logger.error("Errore I/O", e);
}
// Non serve il finally per il close()
\end{lstlisting}

\begin{deepdive}{Suppressed Exceptions}
Cosa succede se il blocco \texttt{try} lancia un'eccezione E1, e poi la chiusura automatica (\texttt{close()}) lancia un'altra eccezione E2?
Nel vecchio blocco finally, E2 avrebbe sovrascritto E1, nascondendo la vera causa dell'errore.
Nel \textit{try-with-resources}, E1 viene lanciata, e E2 viene aggiunta come \textbf{Suppressed Exception} (eccezione soppressa) a E1. Puoi recuperarla con \texttt{e.getSuppressed()}.
\end{deepdive}

\section{Custom Exceptions}

Creare eccezioni personalizzate (es. \texttt{UserNotFoundException}) migliora la leggibilità.
\textbf{Regola:} Estendi \texttt{RuntimeException} (Unchecked) per errori di business, estendi \texttt{Exception} (Checked) solo se vuoi forzare il client a tentare un'azione di recupero specifica.

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Generics}

Le Collection sono il cuore della gestione dati in memoria. Scegliere la struttura dati sbagliata può trasformare un'applicazione veloce in un sistema lento e non scalabile.

\section{Generics: Type Safety e Flessibilità}

I Generics, introdotti in Java 5, non sono semplice "zucchero sintattico", ma un meccanismo fondamentale per garantire la \textbf{Compile-time Type Safety} (sicurezza dei tipi a tempo di compilazione).

\section{L'Era pre-Generics e i Raw Types}

Prima dell'avvento dei Generics, le collezioni in Java lavoravano sui \texttt{Object}. Questo approccio, noto come utilizzo di \textbf{Raw Types}, delegava interamente al programmatore la responsabilità di inserire i tipi corretti.

\begin{lstlisting}[language=Java, caption=Il problema dei Raw Types]
List lista = new ArrayList(); // Raw Type (sconsigliato)
lista.add("Ciao");
lista.add(10);      // Il compilatore accetta tutto (e' Object)

// Il problema emerge SOLO a runtime
String s = (String) lista.get(1); // ClassCastException!
\end{lstlisting}

I difetti di questo approccio sono evidenti:
\begin{enumerate}
    \item \textbf{Casting Esplicito:} Ogni operazione di lettura richiede un cast manuale.
    \item \textbf{Insicurezza:} Gli errori di tipo vengono scoperti solo durante l'esecuzione (Runtime), causando crash dell'applicazione.
\end{enumerate}

\section{Il Concetto di Type Parameter}

Con i Generics, spostiamo il controllo dei tipi dal Runtime al \textbf{Compile-time}. Dichiarando \texttt{List<String>}, informiamo il compilatore che quella lista deve contenere esclusivamente stringhe.

\begin{lstlisting}[language=Java]
List<String> nomi = new ArrayList<>();
nomi.add("Anna");
// nomi.add(10); // ERRORE DI COMPILAZIONE: "incompatible types"
\end{lstlisting}

La sintassi \texttt{<T>} definisce un \textbf{Type Parameter}. È un segnaposto che verrà sostituito da un tipo concreto al momento dell'utilizzo.

\begin{lstlisting}[language=Java]
// Definizione generica
public class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}

// Utilizzo concreto
Box<Integer> intBox = new Box<>(); // T diventa Integer
Box<String> strBox = new Box<>();  // T diventa String
\end{lstlisting}

\section{Type Erasure: La Magia Sotto il Cofano}

Una delle domande tecniche più frequenti riguarda l'implementazione interna dei Generics. Java utilizza la \textbf{Type Erasure} (Cancellazione del Tipo) per mantenere la retro-compatibilità con le versioni precedenti a Java 5.

\textbf{Cosa succede realmente?}
Il compilatore esegue i controlli di tipo e poi \textbf{rimuove} le informazioni generiche dal bytecode generato.

\begin{itemize}
    \item \texttt{List<String>} diventa \texttt{List} (Raw type).
    \item \texttt{T} viene sostituito dal suo bound più alto (solitamente \texttt{Object}).
    \item Il compilatore inserisce automaticamente i \textbf{Cast} necessari nel bytecode.
\end{itemize}

A Runtime, la JVM non sa la differenza tra \texttt{List<String>} e \texttt{List<Integer>}: per lei sono entrambe solo \texttt{List}.

\begin{deepdive}{Limitazioni della Type Erasure}
Poiché \texttt{T} non esiste a Runtime, alcune operazioni sono vietate:

\begin{enumerate}
    \item \textbf{Istanziazione:} \texttt{new T()} è illegale. La JVM non saprebbe quale costruttore chiamare.
    \item \textbf{Array Generici:} \texttt{new T[10]} è illegale.
    \item \textbf{Instanceof:} \texttt{if (obj instanceof T)} è illegale.
\end{enumerate}

\textbf{Workaround:} Se devi istanziare un tipo generico, devi passare esplicitamente l'oggetto \texttt{Class<T>} a runtime e usare la Reflection:
\begin{lstlisting}
public Box(Class<T> clazz) {
    this.value = clazz.getDeclaredConstructor().newInstance();
}
\end{lstlisting}
\end{deepdive}

\section{Invarianza e Wildcards}

A differenza degli array, i Generics in Java sono \textbf{Invarianti}.

\begin{quote}
Anche se \texttt{Integer} estende \texttt{Number}, \texttt{List<Integer>} \textbf{NON} è un sottotipo di \texttt{List<Number>}.
\end{quote}

Se Java permettesse la covarianza implicita, si romperebbe la Type Safety:
\begin{lstlisting}[language=Java]
List<Integer> interi = new ArrayList<>();
List<Number> numeri = interi; // SE fosse legale...
numeri.add(3.14); // ...inserirei un Double in una lista di Integer!
\end{lstlisting}

Per gestire casi in cui serve flessibilità, Java introduce le \textbf{Wildcards} (\texttt{?}).

\subsection{Bounded Wildcards}

\begin{enumerate}
    \item \textbf{Upper Bounded (? extends T):} Accetta T o qualsiasi sua sottoclasse.
    \item \textbf{Lower Bounded (? super T):} Accetta T o qualsiasi sua superclasse.
\end{enumerate}

\begin{interview}{Il Principio PECS (Producer Extends - Consumer Super)}
Per ricordare quale wildcard usare, memorizza l'acronimo \textbf{PECS}:

\begin{itemize}
    \item \textbf{Producer Extends:} Se la tua collezione \textbf{Produce} dati (devi solo leggerli), usa \texttt{? extends T}.
    \begin{itemize}
        \item \textit{Puoi leggere:} Sì (come T).
        \item \textit{Puoi scrivere:} No (non sai il tipo specifico).
    \end{itemize}
    
    \item \textbf{Consumer Super:} Se la tua collezione \textbf{Consuma} dati (devi scriverci dentro), usa \texttt{? super T}.
    \begin{itemize}
        \item \textit{Puoi leggere:} Solo come \texttt{Object}.
        \item \textit{Puoi scrivere:} Sì (istanze di T e sottoclassi).
    \end{itemize}
\end{itemize}
\end{interview}

\begin{lstlisting}[language=Java, caption=Esempio Pratico PECS]
// PRODUCER: Leggo numeri (Number o figli)
public double somma(List<? extends Number> list) {
    double sum = 0;
    for (Number n : list) sum += n.doubleValue();
    // list.add(10); // ERRORE! Non posso scrivere
    return sum;
}

// CONSUMER: Scrivo interi (Integer o padri)
public void riempi(List<? super Integer> list) {
    list.add(10); // OK
    list.add(20); // OK
    // Integer n = list.get(0); // ERRORE! Ottengo solo Object
}
\end{lstlisting}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Collections Framework}

\section{Architettura e Fondamenta}

Prima di analizzare le singole implementazioni (come ArrayList o HashMap), è essenziale comprendere il disegno architettonico del Java Collections Framework (JCF). Il framework non è solo un insieme di classi, ma una gerarchia rigorosa di interfacce.

\subsection{La Gerarchia: Iterable, Collection vs Map}

Il mondo delle collezioni in Java è diviso in due grandi imperi distinti. Un errore comune è pensare che tutto erediti da un unico padre. Non è così.

\subsubsection{L'albero di Collection (java.util.Collection)}
Alla base di Liste, Set e Code c'è l'interfaccia \texttt{Iterable}.

\begin{itemize}
    \item \textbf{\texttt{Iterable<T>}}: È l'interfaccia "nonno". Definisce un solo metodo: \texttt{iterator()}. Qualsiasi classe la implementi può essere usata nel "for-each loop" di Java.
    \item \textbf{\texttt{Collection<T>}}: Estende \texttt{Iterable}. Definisce il contratto base per un gruppo di oggetti (add, remove, size, contains).
\end{itemize}

Sotto \texttt{Collection} troviamo le tre sotto-interfacce principali:
\begin{enumerate}
    \item \textbf{\texttt{List}}: Ordine sequenziale, indici, duplicati ammessi.
    \item \textbf{\texttt{Set}}: Unicità matematica, nessun duplicato.
    \item \textbf{\texttt{Queue}}: Code (FIFO) e Pile, pensate per l'elaborazione (hold elements prior to processing).
\end{enumerate}

\subsubsection{L'impero di Map (java.util.Map)}
Le Mappe \textbf{NON} estendono \texttt{Collection}. Sono un ramo parallelo.

\begin{interview}{Perché Map non estende Collection?}
\textbf{Domanda:} Sarebbe stato logico dire che una Map è una "collezione di coppie". Perché in Java sono separate?

\textbf{Risposta:}
Perché i contratti sono incompatibili sintatticamente e semanticamente.
\begin{itemize}
    \item \texttt{Collection} lavora su singoli elementi: \texttt{add(E element)}.
    \item \texttt{Map} lavora su coppie: \texttt{put(K key, V value)}.
\end{itemize}
Se \texttt{Map} estendesse \texttt{Collection}, come implementerebbe il metodo \texttt{add(E element)}? Dovrebbe accettare solo chiavi? O solo valori? O oggetti Entry? Questa ambiguità ha portato i progettisti di Java a separare le due gerarchie.
Tuttavia, le Mappe forniscono delle "viste" che sono Collezioni:
\begin{itemize}
    \item \texttt{keySet()} $\rightarrow$ Restituisce un \texttt{Set<K>}.
    \item \texttt{values()} $\rightarrow$ Restituisce una \texttt{Collection<V>}.
    \item \texttt{entrySet()} $\rightarrow$ Restituisce un \texttt{Set<Map.Entry<K,V>>}.
\end{itemize}
\end{interview}

\subsection{Concetti Chiave: Mutabilità e Iteratori}

\subsubsection{Mutabilità vs Immutabilità}
Fino a Java 8, le collezioni erano quasi sempre mutabili. Da Java 9 in poi, è cruciale distinguere:
\begin{itemize}
    \item \textbf{Mutable:} \texttt{new ArrayList<>()}. Posso aggiungere/rimuovere elementi sempre.
    \item \textbf{Immutable:} \texttt{List.of("A", "B")}. Creata una volta, non cambia più. Tentare di modificarla lancia \texttt{UnsupportedOperationException}.
    \item \textbf{Unmodifiable View:} \texttt{Collections.unmodifiableList(list)}. È solo un guscio protettivo. Se la lista originale sotto cambia, cambia anche la view!
\end{itemize}

\subsubsection{Null Safety}
Non tutte le collezioni accettano \texttt{null}.
\begin{itemize}
    \item \textbf{ArrayList, LinkedList, HashSet:} Accettano \texttt{null}.
    \item \textbf{TreeSet, TreeMap:} Non accettano \texttt{null} (perché non saprebbero come ordinarlo rispetto agli altri elementi).
    \item \textbf{ArrayDeque, PriorityQueue:} Non accettano \texttt{null}.
    \item \textbf{Hashtable, ConcurrentHashMap:} Non accettano \texttt{null} né come chiave né come valore (scelta di design per la concorrenza).
\end{itemize}

\subsubsection{Fail-Fast vs Fail-Safe Iterators}
Questo è il concetto più tecnico relativo agli iteratori.

\begin{deepdive}{Fail-Fast e la ConcurrentModificationException}
Le collezioni standard (ArrayList, HashMap) hanno iteratori \textbf{Fail-Fast}.
Internamente mantengono un contatore chiamato \texttt{modCount} (modification count).
\begin{enumerate}
    \item Quando crei l'iteratore, esso si salva il valore attuale di \texttt{modCount}.
    \item Ogni volta che chiami \texttt{next()}, l'iteratore verifica: \textit{"Il modCount attuale è uguale a quello che ho salvato?"}
    \item Se qualcun altro (o lo stesso thread in modo sbagliato) ha aggiunto/rimosso un elemento direttamente dalla collezione, il \texttt{modCount} cambia.
    \item L'iteratore se ne accorge e lancia immediatamente \texttt{ConcurrentModificationException}.
\end{enumerate}

\textbf{Eccezione alla regola:} L'unico modo sicuro per rimuovere un elemento mentre si itera è usare il metodo \texttt{iterator.remove()}, che aggiorna sincronizzando i contatori.
\end{deepdive}

\subsection{Reference: Tabella della Complessità (Big O)}
Questa tabella riassume i costi temporali delle operazioni principali. Tienila come riferimento per scegliere la struttura dati adatta.

\begin{center}
\renewcommand{\arraystretch}{1.5}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|c|c|c|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Implementazione}} & \textcolor{white}{\textbf{Accesso}} & \textcolor{white}{\textbf{Inserimento}} & \textcolor{white}{\textbf{Rimozione}} & \textcolor{white}{\textbf{Struttura Sottostante}} \\
    \hline
    \textbf{ArrayList} & $O(1)$ & $O(1)^*$ & $O(n)$ & Array ridimensionabile \\
    \hline
    \textbf{LinkedList} & $O(n)$ & $O(1)$ & $O(1)$ & Lista doppiamente concatenata \\
    \hline
    \textbf{ArrayDeque} & $O(1)$ & $O(1)$ & $O(1)$ & Array circolare (No Nulls) \\
    \hline
    \textbf{PriorityQueue} & $O(1)$ (peek) & $O(\log n)$ & $O(\log n)$ & Binary Heap (Array) \\
    \hline
    \textbf{HashMap} & $O(1)$ & $O(1)$ & $O(1)$ & Array di Bucket + LinkedList/R.B. Tree \\
    \hline
    \textbf{TreeMap} & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ & Red-Black Tree \\
    \hline
\end{tabularx}
\end{center}
\textit{\footnotesize * $O(1)$ ammortizzato. Nel caso peggiore (quando l'array deve essere ridimensionato), l'inserimento costa $O(n)$.}

\section{Le Liste (List Interface): Sequenzialità e Memoria}

La \texttt{List} è la struttura più comune: una collezione ordinata che permette duplicati e controllo posizionale preciso. Tuttavia, la scelta tra le implementazioni non è stilistica, ma architetturale.

\subsection{ArrayList: L'implementazione di default}
L'\texttt{ArrayList} deve essere la tua scelta nel 90\% dei casi.
È un wrapper attorno a un array primitivo:
\begin{lstlisting}[language=Java]
transient Object[] elementData; // non-private to simplify nested class access
private int size;
\end{lstlisting}

\subsubsection{Algoritmo di Ridimensionamento (Resizing)}
Poiché gli array in Java hanno dimensione fissa, l'ArrayList simula la crescita dinamica.
Quando l'array è pieno e si invoca \texttt{add()}:
\begin{enumerate}
    \item Viene calcolata una nuova capacità. La formula nel JDK (metodo \texttt{grow}) è:
    \[ \text{newCapacity} = \text{oldCapacity} + (\text{oldCapacity} \gg 1) \]
    L'operatore \texttt{>> 1} è uno shift bitwise a destra (divide per 2). Quindi l'array cresce del \textbf{50\%} circa.
    \item Viene creato un nuovo array.
    \item I dati vengono copiati massivamente usando il metodo nativo \texttt{System.arraycopy()} (molto veloce perché lavora a basso livello sulla memoria).
\end{enumerate}

\begin{deepdive}{CPU Cache Locality: Il vantaggio segreto}
Perché \texttt{ArrayList} è spesso più veloce di \texttt{LinkedList} anche negli inserimenti, contro la teoria classica?
La risposta è nell'hardware: \textbf{CPU Cache Lines}.

Gli elementi di un array sono contigui in memoria fisica. Quando la CPU carica un elemento nella cache L1/L2, carica anche i suoi vicini. Scorrere un ArrayList è un'operazione fulminea.
Una \texttt{LinkedList}, invece, ha nodi sparsi ovunque nello Heap. Questo causa continui \textit{Cache Miss}, costringendo la CPU a costose letture dalla RAM principale.
\end{deepdive}

\subsection{LinkedList: L'alternativa collegata}
Implementa sia \texttt{List} che \texttt{Deque}. È una lista \textbf{doppiamente concatenata}.
Ogni elemento è racchiuso in un oggetto \texttt{Node}:

\begin{lstlisting}[language=Java]
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
}
\end{lstlisting}

\subsubsection{Il costo nascosto della memoria}
Questo è un punto cruciale per l'analisi delle performance.

\begin{deepdive}{Analisi Memory Overhead}
Immagina di voler salvare un semplice Integer (es. 4 byte).
\begin{itemize}
    \item \textbf{ArrayList:} Occupa lo spazio per il riferimento all'Integer nell'array + l'oggetto Integer stesso. (Poco overhead).
    \item \textbf{LinkedList:} Per ogni elemento, deve istanziare un oggetto \texttt{Node}.
    Su una JVM a 64 bit standard:
    \begin{itemize}
        \item Node Header: 12 byte (approx)
        \item Reference to item: 4/8 byte
        \item Reference to next: 4/8 byte
        \item Reference to prev: 4/8 byte
    \end{itemize}
\end{itemize}
\textbf{Risultato:} Una LinkedList consuma \textbf{4 o 5 volte più memoria} di un ArrayList per salvare gli stessi dati.
\end{deepdive}

\begin{interview}{ArrayList vs LinkedList}
\textbf{Domanda:} Quando useresti veramente una LinkedList?

\textbf{Risposta:}
Solo in scenari molto specifici:
\begin{enumerate}
    \item Quando devo aggiungere/rimuovere elementi \textbf{in testa} alla lista frequentemente (stack/queue behavior), anche se per questo preferisco \texttt{ArrayDeque}.
    \item Quando uso pesantemente gli \texttt{Iterator} per inserire/rimuovere elementi nel mezzo della lista durante l'iterazione ($O(1)$ una volta che l'iteratore è posizionato).
    \item Quando non ho vincoli di memoria ma devo evitare assolutamente il "singhiozzo" di latenza causato dal resizing dell'ArrayList (copia dell'array).
\end{enumerate}
\end{interview}

\subsection{Vector e Stack: Il passato (Legacy)}
Potresti trovarli in codice vecchio, ma non dovresti mai usarli in codice nuovo.

\begin{itemize}
    \item \textbf{Vector:} Simile a ArrayList, ma \textbf{tutti} i suoi metodi sono \texttt{synchronized}. Questo lo rende lento in contesti single-thread e non sufficientemente granulare in contesti multi-thread moderni.
    \begin{itemize}
        \item \textit{Sostituto:} \texttt{ArrayList} (non thread-safe) o \texttt{CopyOnWriteArrayList} (thread-safe).
    \end{itemize}
    \item \textbf{Stack:} Estende \texttt{Vector}. È un errore di design (una Pila non dovrebbe essere un Vettore e permettere accesso per indice).
    \begin{itemize}
        \item \textit{Sostituto:} \texttt{ArrayDeque} (più veloce, API più pulita).
    \end{itemize}
\end{itemize}

\section{Le Mappe (Map Interface): Hashing e Internals}

Le Mappe sono strutture dati che associano chiavi uniche a valori. Sebbene l'interfaccia sia semplice (\texttt{put}, \texttt{get}), la complessità ingegneristica che si nasconde dietro è notevole.

\subsection{HashMap: The Deep Dive}
La \texttt{HashMap} è basata sul principio dell'\textbf{Hashing}. Non itera sugli elementi per trovarli, ma calcola la loro posizione.

\subsubsection{Struttura Interna: Bucket e Nodi}
Internamente, una HashMap mantiene un array:
\begin{lstlisting}[language=Java]
transient Node<K,V>[] table;
\end{lstlisting}
Ogni cella di questo array è chiamata \textbf{bucket}. Un bucket non contiene un solo elemento, ma è la testa di una struttura dati (una lista concatenata o un albero) che gestisce gli elementi che "cadono" in quel preciso indice.

\subsubsection{Dalla Chiave all'Indice}
Quando esegui \texttt{map.put("Key", "Value")}, avvengono tre passaggi fondamentali:

\begin{enumerate}
    \item \textbf{Hashing:} Viene chiamato \texttt{key.hashCode()}. Questo restituisce un intero a 32 bit (che può essere negativo).
    \item \textbf{Smearing (Perturbazione):} Per proteggersi da funzioni di hash scritte male, Java applica uno XOR bitwise: \texttt{(h = key.hashCode()) \^{} (h >>> 16)}. Questo mescola i bit alti con quelli bassi.
    \item \textbf{Indexing:} L'hash deve essere mappato su un indice valido dell'array (da 0 a \texttt{n-1}).
    Java non usa l'operatore modulo (\%), ma un'operazione bitwise molto più veloce:
    \[ \text{index} = (n - 1) \ \& \ \text{hash} \]
    \textit{Nota:} Questo funziona solo perché la capacità della tabella ($n$) è forzata a essere sempre una \textbf{potenza di 2}.
\end{enumerate}

\begin{deepdive}{Java 8 Revolution: Treeify (Da Lista ad Albero)}
Cosa succede se molte chiavi finiscono nello stesso bucket (Collisione)?
\begin{itemize}
    \item \textbf{Fino a Java 7:} Gli elementi venivano accodati in una LinkedList. Se un attaccante inviava chiavi studiate per collidere (HashDoS attack), la ricerca degradava a $O(n)$, bloccando la CPU.
    \item \textbf{Da Java 8 in poi:} Esiste una soglia \texttt{TREEIFY\_THRESHOLD = 8}.
    Se un bucket contiene più di 8 nodi, la LinkedList viene convertita dinamicamente in un \textbf{Red-Black Tree}.
\end{itemize}
\textbf{Impatto:} Il caso peggiore passa da $O(n)$ a $O(\log n)$.
\end{deepdive}

\begin{interview}{Il Contratto hashCode ed equals}
\textbf{Domanda:} Cosa succede se due oggetti restituiscono lo stesso \texttt{hashCode} ma \texttt{equals} ritorna \texttt{false}? E viceversa?

\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Stesso hash, equals false:} È una \textbf{collisione} legittima. Gli oggetti finiscono nello stesso bucket e vengono gestiti (lista/albero). La mappa funziona, ma rallenta leggermente.
    \item \textbf{Diverso hash, equals true:} \textbf{Disastro.} Hai violato il contratto.
    Se inserisci l'oggetto, esso finisce nel bucket A. Quando provi a cercarlo, anche se usi un oggetto "uguale", il calcolo dell'hash potrebbe puntare al bucket B. Risultato: La mappa restituisce \texttt{null} anche se l'oggetto esiste.
\end{itemize}
\end{interview}

\subsubsection{Performance Tuning: Load Factor}
Due parametri governano le performance:
\begin{itemize}
    \item \textbf{Initial Capacity:} Dimensione iniziale dell'array (default 16).
    \item \textbf{Load Factor:} Soglia di riempimento (default 0.75).
\end{itemize}
Quando \texttt{size > capacity * loadFactor}, avviene il \textbf{Re-hashing}: la dimensione dell'array raddoppia e \textit{tutti} gli elementi vengono ricalcolati e riposizionati. È un'operazione costosa che va evitata inizializzando la mappa con la dimensione corretta se nota a priori.

\subsection{LinkedHashMap: Ordine e Cache}
Estende \texttt{HashMap}. Oltre alla struttura a bucket standard, mantiene una \textbf{Doubly Linked List} che attraversa \textit{tutte} le entry.

\begin{itemize}
    \item \textbf{Insertion Order (Default):} Itera gli elementi nell'ordine in cui sono stati inseriti.
    \item \textbf{Access Order:} Se configurata nel costruttore (\texttt{accessOrder = true}), ogni volta che un elemento viene letto (\texttt{get}) viene spostato in fondo alla lista.
\end{itemize}

\textbf{Use Case Senior:} Implementare una \textbf{LRU Cache} (Least Recently Used) è banale estendendo LinkedHashMap e sovrascrivendo il metodo \texttt{removeEldestEntry()}.

\subsection{TreeMap: Navigable e Ordinata}
Implementa \texttt{NavigableMap}. Mantiene le chiavi \textbf{sempre ordinate} (Natural Order o Comparator).
\begin{itemize}
    \item \textbf{Struttura:} Red-Black Tree (albero binario bilanciato).
    \item \textbf{Performance:} $O(\log n)$ per \texttt{get}, \texttt{put}, \texttt{remove}. Più lenta di HashMap.
    \item \textbf{Funzionalità uniche:} \texttt{firstKey()}, \texttt{lastKey()}, \texttt{subMap(from, to)}.
\end{itemize}

\subsection{Mappe Specializzate}

\subsubsection{EnumMap}
Se la chiave è un \texttt{Enum}, usa sempre questa.
Non usa hashing. Internamente usa un semplice \textbf{Array} indicizzato dall'\texttt{ordinal()} dell'enum.
Estremamente veloce e compatta in memoria (nessun oggetto Entry wrapper, nessuna collisione possibile).

\subsubsection{WeakHashMap}
Le chiavi sono memorizzate come \textbf{WeakReference}.
Se una chiave non è più referenziata da nessun'altra parte nell'applicazione, il Garbage Collector la eliminerà alla prima occasione e la \texttt{WeakHashMap} rimuoverà automaticamente l'entry corrispondente.
\textbf{Use Case:} Cache di metadati associati a oggetti temporanei.

\subsubsection{IdentityHashMap}
Viola volutamente le specifiche di Map. Per confrontare le chiavi usa l'uguaglianza referenziale (\texttt{k1 == k2}) invece dell'uguaglianza logica (\texttt{k1.equals(k2)}).
Utile in framework di serializzazione o per gestire topologie di oggetti (grafi) dove istanze diverse con lo stesso contenuto devono essere distinte.

\section{I Set (Insiemi): Unicità}

L'interfaccia \texttt{Set} modella l'astrazione matematica di insieme: una collezione che non può contenere duplicati.

\subsection{La verità architetturale: I Set sono Mappe}
In Java, non esiste un motore di gestione dei Set scritto da zero. Tutte le implementazioni standard sono \textbf{wrapper} attorno alle rispettive implementazioni di \texttt{Map}.

\begin{deepdive}{HashSet Internals: Il trucco del Valore Dummy}
Quando istanzi un \texttt{HashSet}, internamente stai creando una \texttt{HashMap}.
\begin{lstlisting}[language=Java]
// Dal codice sorgente del JDK
private transient HashMap<E,Object> map;
private static final Object PRESENT = new Object();

public boolean add(E e) {
    return map.put(e, PRESENT) == null;
}
\end{lstlisting}
\begin{itemize}
    \item \textbf{Chiave:} L'elemento che inserisci nel Set.
    \item \textbf{Valore:} Un oggetto statico condiviso (\texttt{PRESENT}).
\end{itemize}
\textbf{Implicazione Memory:} Un \texttt{HashSet} consuma la stessa memoria di una \texttt{HashMap}. C'è un leggero spreco poiché ogni entry ha un riferimento a questo oggetto dummy, ma permette il riutilizzo totale del codice della mappa.
\end{deepdive}

\subsection{Le tre implementazioni principali}
\begin{enumerate}
    \item \textbf{HashSet:} Basato su \texttt{HashMap}. Non garantisce alcun ordine. È il più veloce ($O(1)$).
    \item \textbf{LinkedHashSet:} Basato su \texttt{LinkedHashMap}. Mantiene l'\textbf{ordine di inserimento}. Utile se devi rimuovere duplicati da una lista mantenendo la sequenza originale.
    \item \textbf{TreeSet:} Basato su \texttt{TreeMap}. Mantiene gli elementi \textbf{ordinati} (Natural o Comparator). Implementa \texttt{NavigableSet}. Costo operazioni: $O(\log n)$.
\end{enumerate}

\subsection{Operazioni Insiemistiche (Algebra dei Set)}
Spesso ignorate, queste operazioni "bulk" sono potentissime e ottimizzate:
\begin{itemize}
    \item \textbf{Unione:} \texttt{setA.addAll(setB)} $\rightarrow$ $A \cup B$
    \item \textbf{Intersezione:} \texttt{setA.retainAll(setB)} $\rightarrow$ $A \cap B$ (Mantiene in A solo ciò che esiste anche in B).
    \item \textbf{Differenza Asimmetrica:} \texttt{setA.removeAll(setB)} $\rightarrow$ $A - B$ (Rimuove da A tutto ciò che è in B).
\end{itemize}

\section{Code e Code Prioritarie (Queue \& Deque)}

Le code sono fondamentali per disaccoppiare la produzione di dati dalla loro elaborazione.

\subsection{PriorityQueue: Il Binary Heap}
La \texttt{PriorityQueue} non segue il FIFO (First-In-First-Out). L'elemento in testa è sempre il "minimo" (secondo il \texttt{Comparable} o \texttt{Comparator}).

\textbf{Attenzione:} Se iteri su una PriorityQueue con un for-each, \textbf{non} otterrai gli elementi in ordine ordinato! L'ordine è garantito solo estraendo gli elementi (\texttt{poll()}).

\subsubsection{Struttura Interna: Heap su Array}
Non usa puntatori o alberi di oggetti. Usa un singolo array che simula un albero binario completo.
Dato un nodo all'indice $k$:
\begin{itemize}
    \item \textbf{Figlio Sinistro:} $2k + 1$
    \item \textbf{Figlio Destro:} $2k + 2$
    \item \textbf{Genitore:} $(k - 1) / 2$
\end{itemize}

\begin{interview}{Complessità PriorityQueue}
\textbf{Domanda:} Perché l'inserimento non è $O(1)$?
\textbf{Risposta:}
Quando inserisci un elemento (\texttt{offer}), esso viene messo alla fine dell'array. Poi deve "risalire" (Bubbling Up) scambiandosi col genitore finché la regola dell'Heap non è ripristinata. Questo richiede di percorrere l'altezza dell'albero: $O(\log n)$.
\begin{itemize}
    \item \textbf{Peek (Testa):} $O(1)$
    \item \textbf{Offer (Inserimento):} $O(\log n)$
    \item \textbf{Poll (Rimozione testa):} $O(\log n)$
    \item \textbf{Contains (Ricerca):} $O(n)$ (Deve scansionare l'array, non è ottimizzato per la ricerca!)
\end{itemize}
\end{interview}

\subsection{ArrayDeque: La Pila Moderna}
L'interfaccia \texttt{Deque} (Double Ended Queue) permette inserimenti e rimozioni da entrambi i lati.
\texttt{ArrayDeque} è l'implementazione da usare sempre al posto della vecchia classe \texttt{Stack}.

\subsubsection{Circular Buffer (Ring Buffer)}
Internamente usa un array trattato come se fosse circolare. Mantiene due puntatori interi: \texttt{head} e \texttt{tail}.
Quando la \texttt{tail} raggiunge la fine dell'array, riparte dall'indice 0 (se c'è spazio).

\textbf{Vantaggi rispetto a LinkedList:}
\begin{itemize}
    \item \textbf{Cache Locality:} Essendo un array, è amico della CPU cache.
    \item \textbf{No Garbage:} Non crea nodi wrapper per ogni inserimento.
\end{itemize}
\textbf{Limitazione:} Non accetta valori \texttt{null}.

\section{Ordinamento e Comparazione}

Le collezioni come \texttt{TreeSet} o gli algoritmi di \texttt{Collections.sort()} hanno bisogno di un criterio per stabilire se l'oggetto A viene prima dell'oggetto B. Java fornisce due meccanismi distinti.

\subsection{Comparable: L'Ordinamento Naturale}
L'interfaccia \texttt{Comparable<T>} viene implementata \textbf{dentro} la classe di dominio. Definisce "cosa sono io rispetto a un altro".

\begin{lstlisting}[language=Java, title={Implementazione Comparable corretta}]
public class Utente implements Comparable<Utente> {
    private Integer id;
    private String nome;

    @Override
    public int compareTo(Utente altro) {
        // Ritorna negativo se this < altro
        // Zero se uguali
        // Positivo se this > altro
        return this.id.compareTo(altro.id);
    }
}
\end{lstlisting}

\begin{interview}{Il bug della sottrazione}
\textbf{Domanda:} Perché è rischioso implementare \texttt{compareTo} facendo semplicemente \texttt{return this.valore - altro.valore}?

\textbf{Risposta:}
Per il rischio di \textbf{Integer Overflow}.
Se \texttt{this.valore} è un numero positivo molto grande e \texttt{altro.valore} è un numero negativo molto grande (es. -2 miliardi), la sottrazione matematicamente darebbe un risultato positivo enorme, ma in Java i bit "girano" (overflow) e il risultato diventa negativo. L'ordinamento risulterebbe errato.
\textbf{Soluzione:} Usare sempre i metodi statici helper: \texttt{Integer.compare(a, b)}.
\end{interview}

\subsection{Comparator: L'Ordinamento Esterno}
Se non puoi modificare la classe originale (es. classe di libreria) o se vuoi ordinare in modi diversi (es. per nome, poi per data), usi \texttt{Comparator<T>}.

Da Java 8, la sintassi è estremamente pulita grazie alle lambda e ai method reference:

\begin{lstlisting}[language=Java]
// Ordinamento a catena (Fluent API)
Comparator<Utente> byNameThenId = Comparator
    .comparing(Utente::getNome)
    .thenComparing(Utente::getId)
    .reversed(); // Inverte l'ordine totale

utenti.sort(byNameThenId);
\end{lstlisting}

\section{Modern Java: Immutabilità (Java 9 - 21)}

Fino a Java 8, creare liste immutabili era verboso e spesso inefficiente. Java 9 ha introdotto i \textbf{Collection Factory Methods} (\texttt{List.of}, \texttt{Set.of}, \texttt{Map.of}).

\subsection{Unmodifiable View vs True Immutability}
È fondamentale capire la differenza tra "non modificabile" e "immutabile".

\begin{enumerate}
    \item \textbf{Unmodifiable View (Java 8):}
    \texttt{Collections.unmodifiableList(originalList)} crea solo un guscio protettivo.
    Se qualcuno mantiene il riferimento a \texttt{originalList} e aggiunge un elemento, la "view" vedrà quel nuovo elemento! Non è una vera immutabilità, è solo una finestra bloccata.
    
    \item \textbf{True Immutability (Java 9+):}
    \texttt{List.of("A", "B")} crea una struttura dati completamente distaccata e autonoma. Non c'è nessuna lista "sotto" che può cambiare.
\end{enumerate}

\subsection{Internals: Ottimizzazione della Memoria}
Perché \texttt{List.of} è meglio di \texttt{new ArrayList} seguito da un blocco?

\begin{deepdive}{Space Efficiency in List.of}
Le implementazioni restituite da \texttt{List.of} sono altamente ottimizzate per risparmiare memoria.
\begin{itemize}
    \item \textbf{Array Fisso:} Non hanno bisogno dei campi \texttt{capacity} o di logiche di ridimensionamento.
    \item \textbf{Classi Specializzate:} Per liste piccolissime (1 o 2 elementi), Java 9+ non crea nemmeno un array interno! Usa classi dedicate con campi fissi (es. \texttt{List12} con campi \texttt{e0}, \texttt{e1}) per evitare l'overhead dell'oggetto array.
    \item \textbf{No Nulls:} Le collezioni di Java 9 non accettano \texttt{null}. Questo semplifica i controlli interni e previene errori logici.
\end{itemize}
\end{deepdive}

\begin{interview}{Arrays.asList vs List.of}
\textbf{Domanda:} Che differenza c'è tra \texttt{Arrays.asList(1, 2)} e \texttt{List.of(1, 2)}?

\textbf{Risposta:}
\begin{itemize}
    \item \textbf{\texttt{Arrays.asList}:} Restituisce una lista a \textbf{dimensione fissa}, ma i cui elementi sono \textbf{mutabili}. Posso fare \texttt{list.set(0, 99)}! Inoltre, accetta \texttt{null}. È "backed" dall'array originale.
    \item \textbf{\texttt{List.of}:} Restituisce una lista \textbf{completamente immutabile}. Non posso aggiungere, rimuovere, né settare elementi. Lancia \texttt{UnsupportedOperationException} se ci provi. Non accetta \texttt{null}.
\end{itemize}
\end{interview}

\section{Concurrency: Thread-Safe Collections (Livello Senior)}

Quando più thread accedono e modificano la stessa collezione simultaneamente, le implementazioni standard (\texttt{ArrayList}, \texttt{HashMap}) falliscono.
Possono lanciare \texttt{ConcurrentModificationException} o, peggio, corrompere silenziosamente i dati (race condition) lasciando la struttura in uno stato inconsistente (es. un loop infinito dentro una LinkedList).

\subsection{L'Approccio Legacy: Synchronized Wrappers}
La prima soluzione offerta da Java è stata "avvolgere" la collezione in un guscio sincronizzato.

\begin{lstlisting}[language=Java]
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
Map<K,V> syncMap = Collections.synchronizedMap(new HashMap<>());
\end{lstlisting}

\textbf{Il Problema Architetturale:}
Questi wrapper usano un \textbf{singolo lock globale} (mutex) su tutto l'oggetto.
Se il Thread A sta scrivendo, il Thread B non può nemmeno leggere. In sistemi ad alto traffico, questo crea un collo di bottiglia (bottleneck) devastante. È come avere un'autostrada a una sola corsia.

\subsection{ConcurrentHashMap: Il Capolavoro di Ingegneria}
Questa è probabilmente la classe più sofisticata del JDK.

\subsubsection{Read Operations (Letture)}
Le letture (\texttt{get}) sono quasi sempre \textbf{Lock-Free}.
Non acquisiscono lock. Leggono i valori direttamente dalla memoria (sfruttando la visibilità garantita dai campi \texttt{volatile}). Sono veloci quanto una HashMap non sincronizzata.

\subsubsection{Write Operations (Scritture) - Java 8+}
Qui avviene la magia. Invece di bloccare tutta la mappa, si usa un approccio ibrido:

\begin{enumerate}
    \item \textbf{Bucket Vuoto (CAS):}
    Se il thread vuole scrivere in un bucket ancora vuoto, usa l'istruzione CPU \textbf{CAS (Compare-And-Swap)}.
    \textit{"Se la cella è null, scrivi il mio nodo. Se nel frattempo è cambiata, avvisami e riprovo."}
    È un'operazione atomica hardware, velocissima e senza lock.
    
    \item \textbf{Collisione (Synchronized Block):}
    Solo se il bucket è già occupato, il thread acquisisce un lock \texttt{synchronized}, ma \textbf{SOLO sul primo nodo} di quel specifico bucket.
    Mentre un thread scrive nel bucket 5, un altro può scrivere liberamente nel bucket 10.
\end{enumerate}

\begin{interview}{ConcurrentHashMap vs Hashtable}
\textbf{Domanda:} Perché \texttt{Hashtable} è deprecata in favore di \texttt{ConcurrentHashMap}?

\textbf{Risposta:}
\texttt{Hashtable} usa un lock su tutta la mappa per ogni operazione (come i synchronized wrappers). \texttt{ConcurrentHashMap} blocca solo porzioni microscopiche (bucket stripping) o usa CAS. La scalabilità è incomparabile.
Inoltre, \texttt{Hashtable} non accetta \texttt{null}, mentre \texttt{ConcurrentHashMap} non accetta \texttt{null} (scelta di design per evitare ambiguità in concorrenza: se \texttt{get} torna null, non sapresti se la chiave manca o se il valore è null).
\end{interview}

\subsection{CopyOnWriteArrayList}
Una lista thread-safe molto particolare, pensata per scenari \textbf{Read-Heavy} (tante letture, pochissime scritture).

\textbf{Funzionamento:}
\begin{itemize}
    \item \textbf{Lettura:} Nessun lock. I thread leggono l'array corrente.
    \item \textbf{Scrittura:} Non modifica l'array esistente. Crea una \textbf{nuova copia} dell'intero array, aggiunge l'elemento, e sposta il riferimento alla nuova copia.
\end{itemize}
\textbf{Use Case:} Lista di Event Listeners (i listener vengono aggiunti raramente all'avvio, ma notificati spessissimo). Non usare mai per cache o dati che cambiano spesso!

\subsection{BlockingQueue: Il cuore dei sistemi asincroni}
Queste code gestiscono nativamente l'attesa tra thread Produttori e Consumatori.

\begin{itemize}
    \item \textbf{put(e):} Inserisce. Se la coda è piena, \textbf{blocca} il thread finché non si libera spazio.
    \item \textbf{take():} Preleva. Se la coda è vuota, \textbf{blocca} il thread finché non arriva un dato.
\end{itemize}

\subsubsection{Implementazioni a confronto}

\begin{deepdive}{ArrayBlockingQueue vs LinkedBlockingQueue}
\begin{itemize}
    \item \textbf{ArrayBlockingQueue:} Basata su array a dimensione fissa. Usa un \textbf{singolo lock} per proteggere sia la testa che la coda. Produttori e consumatori competono per lo stesso lock. Minore throughput.
    \item \textbf{LinkedBlockingQueue:} Basata su nodi. Usa \textbf{due lock distinti} (\texttt{putLock} e \texttt{takeLock}). Un thread può inserire mentre un altro preleva simultaneamente. Migliore scalabilità.
\end{itemize}
\end{deepdive}

\subsubsection{SynchronousQueue}
Una coda strana: ha \textbf{capacità zero}.
Non mantiene elementi. Ogni operazione di inserimento (\texttt{put}) deve attendere che un altro thread faccia una \texttt{take} contestuale. È un meccanismo di "hand-off" (passaggio di mano) diretto.
È la coda di default usata da \texttt{Executors.newCachedThreadPool()} per passare task ai thread senza accumularli.

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Funzionale e Moderno (Java 8 - 21)}

Java 8 ha introdotto il più grande cambiamento sintattico nella storia del linguaggio, spostandolo verso un paradigma ibrido (OOP + Funzionale). Le versioni successive (fino alla 21) hanno lavorato per ridurre la verbosità ("Boilerplate").

\section{Programmazione Funzionale: Lambda e Streams}

Java 8 ha introdotto il più grande cambiamento paradigmatico nella storia del linguaggio, portandolo da un approccio puramente imperativo a uno ibrido funzionale. Questo capitolo analizza come la JVM gestisce queste astrazioni a basso livello.

\section{Lambda Expressions e Functional Interfaces}

Una \textbf{Lambda Expression} non è altro che una sintassi concisa per implementare una \textbf{Functional Interface}.

\subsection{Definizione: SAM Type}
Una Functional Interface è un'interfaccia che rispetta la regola \textbf{SAM (Single Abstract Method)}: possiede esattamente un metodo astratto.

\begin{lstlisting}[language=Java]
@FunctionalInterface // Annotation opzionale ma raccomandata
public interface Calcolatore {
    int elabora(int a, int b); // L'unico metodo astratto
    
    // I metodi default o static non contano
    default void reset() { ... }
}
\end{lstlisting}

La Lambda \texttt{(a, b) $\rightarrow$ a + b} fornisce l'implementazione del metodo \texttt{elabora} al volo, eliminando il boilerplate delle Classi Anonime.

\begin{deepdive}{Sotto il cofano: invokeDynamic vs Classi Anonime}
È un errore comune pensare che le Lambda siano solo "zucchero sintattico" che il compilatore trasforma in Classi Anonime (\texttt{new Interface() \{ ... \}}).

\textbf{Differenza Architetturale:}
\begin{enumerate}
    \item \textbf{Classi Anonime:} Il compilatore genera un file \texttt{.class} fisico separato su disco (es. \texttt{Main\$1.class}) per ogni classe anonima. Questo aumenta la dimensione del JAR e il carico sul ClassLoader.
    \item \textbf{Lambda Expressions:} Non generano classi al momento della compilazione. Il compilatore emette un'istruzione bytecode chiamata \textbf{\texttt{invokedynamic}} (introdotta in Java 7).
\end{enumerate}

La creazione dell'oggetto reale è delegata alla JVM a \textbf{Runtime}. Questo permette alla JVM di ottimizzare la creazione (es. riutilizzando l'istanza se la lambda non cattura variabili) e riduce l'occupazione di memoria (Metaspace).
\end{deepdive}

\subsection{Cheat Sheet: Le Interfacce Funzionali Standard}
Non serve creare ogni volta la tua interfaccia \texttt{Calcolatore}. Il package \texttt{java.util.function} copre il 90\% dei casi d'uso comuni, specialmente negli Stream.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Interfaccia} & \textbf{Input} & \textbf{Output} & \textbf{Metodo Astratto} \\
\hline
\texttt{Predicate<T>} & \texttt{T} & \texttt{boolean} & \texttt{boolean test(T t)} \\
\textit{Uso:} & \multicolumn{3}{l|}{\texttt{stream.filter(x $\rightarrow$ x > 10)}} \\
\hline
\texttt{Function<T, R>} & \texttt{T} & \texttt{R} & \texttt{R apply(T t)} \\
\textit{Uso:} & \multicolumn{3}{l|}{\texttt{stream.map(user $\rightarrow$ user.getName())}} \\
\hline
\texttt{Consumer<T>} & \texttt{T} & \texttt{void} & \texttt{void accept(T t)} \\
\textit{Uso:} & \multicolumn{3}{l|}{\texttt{stream.forEach(System.out::println)}} \\
\hline
\texttt{Supplier<R>} & \texttt{None} & \texttt{R} & \texttt{R get()} \\
\textit{Uso:} & \multicolumn{3}{l|}{\texttt{Optional.orElseGet(() $\rightarrow$ new User())}} \\
\hline
\texttt{UnaryOperator<T>} & \texttt{T} & \texttt{T} & (estende Function) \\
\textit{Uso:} & \multicolumn{3}{l|}{\texttt{list.replaceAll(s $\rightarrow$ s.toUpperCase())}} \\
\hline
\end{tabular}
\caption{Interfacce Funzionali Standard di Java 8}
\end{table}

\section{Method References: L'operatore ::}

Le Method References sono una sintassi abbreviata per le Lambda Expression che chiamano un metodo esistente. Rendono il codice estremamente leggibile.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Tipo} & \textbf{Lambda} & \textbf{Method Reference} \\
\hline
Static Method & \texttt{x $\rightarrow$ Math.abs(x)} & \texttt{Math::abs} \\
\hline
Instance Method (oggetto specifico) & \texttt{str $\rightarrow$ System.out.println(str)} & \texttt{System.out::println} \\
\hline
Instance Method (oggetto arbitrario) & \texttt{(s1, s2) $\rightarrow$ s1.compareTo(s2)} & \texttt{String::compareTo} \\
\hline
Constructor & \texttt{() $\rightarrow$ new ArrayList<>()} & \texttt{ArrayList::new} \\
\hline
\end{tabular}
\caption{Tipi di Method References}
\end{table}

\begin{interview}{Quando usare \texttt{String::compareTo} vs \texttt{str::compareTo}?}
È una domanda sottile.
\begin{itemize}
    \item \textbf{\texttt{String::compareTo}} (Class::instanceMethod): Il primo parametro della lambda diventa il target del metodo (es. \texttt{s1.compareTo(s2)}).
    \item \textbf{\texttt{myString::compareTo}} (instance::instanceMethod): Il metodo viene chiamato su un oggetto specifico già esistente (\texttt{myString}), ignorando il parametro della lambda come target.
\end{itemize}
\end{interview}

\section{Variable Capture: "Effectively Final"}

Le Lambda possono accedere alle variabili dello scope esterno (Closure), ma con una restrizione fondamentale: le variabili devono essere \textbf{Effectively Final}.

\begin{lstlisting}[language=Java]
int fattore = 10;
// fattore = 5; // Se decommenti questa riga, la lambda sotto non compila!

Stream.of(1, 2, 3).map(n -> n * fattore).forEach(System.out::println);
\end{lstlisting}

\textbf{Perché?} Le variabili locali vivono nello Stack, mentre la Lambda (che è un oggetto) vive nello Heap e potrebbe essere eseguita da un altro thread molto dopo che il metodo originale è terminato (e lo stack distrutto). Java passa alla lambda una \textbf{copia} del valore. Se il valore cambiasse, la copia sarebbe inconsistente.

\section{Stream API: Elaborazione Dichiarativa}

Introdotte in Java 8, le Stream rappresentano un cambio di paradigma da \textit{imperativo} (come fare, es. cicli for) a \textit{dichiarativo} (cosa voglio ottenere).
Una \texttt{Stream} non è una struttura dati, ma una \textbf{pipeline} che trasporta dati da una sorgente, applica trasformazioni e produce un risultato, senza mai modificare la sorgente originale (immutabilità).

Il ciclo di vita è rigoroso:
\[ \text{Sorgente} \rightarrow \text{Operazioni Intermedie (Lazy)} \rightarrow \text{Operazione Terminale (Eager)} \]

\subsection{Legenda delle Operazioni}

È fondamentale distinguere le operazioni. Una stream senza operazione terminale è come un rubinetto chiuso: l'acqua (i dati) non scorre.

\subsubsection{Operazioni Intermedie (Lazy)}
    Restituiscono sempre una nuova \texttt{Stream<T>}. Non eseguono nulla immediatamente, ma "configurano" la pipeline.
    \begin{itemize}
        \item \texttt{filter(Predicate)}: Mantiene gli elementi che soddisfano la condizione.
        \item \texttt{map(Function)}: Trasforma ogni elemento (1:1).
        \item \texttt{flatMap(Function)}: Trasforma ogni elemento in una Stream e appiattisce il risultato (1:N).
        \item \texttt{sorted(Comparator)}: Ordina gli elementi (Stateful: richiede di vedere tutti i dati).
        \item \texttt{distinct()}: Rimuove i duplicati (usa \texttt{equals()}).
        \item \texttt{limit(n) / skip(n)}: Taglia o salta elementi (Short-circuiting).
        \item \texttt{peek(Consumer)}: Esegue un'azione senza modificare lo stream (utile per debug).
    \end{itemize}

\subsubsection{Operazioni Terminali (Eager)}
    Avviano l'elaborazione, producono un risultato (o void) e \textbf{chiudono} la stream. Dopo questo punto la stream non è più riutilizzabile.
    \begin{itemize}
        \item \texttt{collect(Collector)}: Accumula i risultati in una List, Map, Set, etc.
        \item \texttt{forEach(Consumer)}: Itera su ogni elemento (ritorna \texttt{void}).
        \item \texttt{reduce(BinaryOperator)}: Combina gli elementi in un unico valore (es. somma).
        \item \texttt{count()}: Conta gli elementi.
        \item \texttt{anyMatch / allMatch / noneMatch}: Restituiscono booleani (Short-circuiting).
        \item \texttt{findFirst / findAny}: Restituiscono un \texttt{Optional<T>}.
    \end{itemize}


\subsection{Lazy Evaluation e Loop Fusion}

La JVM è estremamente intelligente nell'ottimizzare le stream. Grazie alla \textit{Lazy Evaluation}, le operazioni non vengono eseguite una per volta sull'intera collezione.

\begin{deepdive}{Cos'è il Loop Fusion?}
Invece di iterare la lista 3 volte per 3 operazioni diverse (filtro, mappa, limite), la JVM fonde le istruzioni in un \textbf{singolo passaggio} sui dati. Inoltre, grazie allo \textit{Short-Circuiting}, si ferma appena ha ottenuto il risultato necessario.
\end{deepdive}

\begin{lstlisting}[caption={Dimostrazione di Lazy Evaluation e Short-Circuiting}]
List<String> nomi = Arrays.asList("Anna", "Bob", "Alice", "Carlo");

// Qui stiamo solo DEFINENDO la pipeline. Nessun dato viene toccato.
Stream<String> stream = nomi.stream()
    .filter(s -> {
        System.out.println("Filter: " + s);
        return s.startsWith("A");
    })
    .map(s -> {
        System.out.println("Map: " + s);
        return s.toUpperCase();
    })
    .limit(1); // Mi serve solo il primo risultato!

System.out.println("--- Inizio Esecuzione ---");
// L'esecuzione parte SOLO ora (collect è terminale)
List<String> risultato = stream.collect(Collectors.toList()); 
System.out.println("Risultato: " + risultato);

/* OUTPUT CONSOLE:
--- Inizio Esecuzione ---
Filter: Anna       <-- Trovato match!
Map: Anna          <-- Trasformato subito
Risultato: [ANNA]  <-- Stop! Bob, Alice e Carlo non sono stati nemmeno letti.
*/
\end{lstlisting}

\subsection{Il pericolo dei Parallel Stream}

Il metodo \texttt{.parallelStream()} suddivide lo stream in più chunk ed elabora ogni pezzo su un thread diverso, ricomponendo poi i risultati. Sembra una bacchetta magica per le performance, ma nasconde un grave pericolo architetturale.

\begin{interview}{Perché evitare Parallel Stream per operazioni I/O?}
È una domanda da Senior. La risposta sta nel \textbf{Thread Pool}.
Tutti i parallel stream all'interno di una JVM (a meno di configurazioni complesse) condividono lo stesso thread pool globale: il \textbf{Common ForkJoinPool}.
La dimensione di questo pool è fissa e limitata:
\[ \text{Pool Size} = \text{Numero Core CPU} - 1 \]

\textbf{Scenario Disastroso:}
Immagina di usare \texttt{parallelStream()} per fare chiamate HTTP o query al Database (I/O Blocking).
I thread del ForkJoinPool si bloccheranno in attesa della risposta del server/DB. Bastano poche richieste concorrenti per \textbf{saturare completamente} il pool globale.

\textbf{Conseguenza:}
L'intera applicazione si blocca o rallenta drasticamente ("Starvation"), perché nessun altro parallel stream (anche in parti completamente diverse del codice) può trovare un thread libero per essere eseguito.

\textbf{Best Practice:}
Usa i parallel stream \textbf{SOLO} per calcoli puri (CPU-intensive) su dataset enormi già presenti in memoria, dove non c'è attesa di I/O.
\end{interview}


\section{Optional: Evitare NullPointerException}

\texttt{Optional<T>} è un contenitore che può contenere un valore non nullo oppure essere vuoto. Serve a rendere esplicito nel ritorno di un metodo che "il valore potrebbe non esserci".

\textbf{Anti-Pattern da evitare:}
\begin{lstlisting}
Optional<String> opt = trovaUtente();
if (opt.isPresent()) {  // Non farlo! E' uguale a if (x != null)
    System.out.println(opt.get());
}
\end{lstlisting}

\textbf{Approccio Funzionale (Best Practice):}
\begin{lstlisting}
trovaUtente()
    .map(String::toUpperCase)
    .ifPresent(System.out::println);
    
// Oppure lanciare eccezione se manca
String user = trovaUtente().orElseThrow(() -> new UserNotFoundException());
\end{lstlisting}

\textbf{Nota Tecnica:} \texttt{Optional} non è \texttt{Serializable}. Non usarlo mai come campo di una classe (Entity o DTO), ma solo come tipo di ritorno dei metodi.

\section{Reflection API e Annotations: Come funzionano i Framework}

Questo è il prerequisito per capire Spring.

\begin{itemize}
    \item \textbf{Reflection:} Permette a un programma Java di ispezionare e modificare il proprio comportamento a runtime (accedere a metodi privati, istanziare classi dato il nome stringa). È potente ma lenta (disabilita le ottimizzazioni JIT).
    \item \textbf{Annotations (\texttt{@Override}, \texttt{@Entity}):} Sono metadati. Di per sé \textbf{non fanno nulla}.
\end{itemize}

\begin{interview}{Come fa Spring a sapere che una classe è un Bean?}
Spring usa la Reflection all'avvio:
\begin{enumerate}
    \item Scansiona tutte le classi nel classpath (È una lista di percorsi, non un contenitore di classi). Quindi va a guardare, una per una, tutte le classi che si trovano in tutte le cartelle e in tutti i .jar elencati nel classpath.
    \item Controlla se la classe ha l'annotazione \texttt{@Component} (o derivate).
    \item Se sì, usa \texttt{Class.newInstance()} (o costruttori) per crearne un'istanza e gestirla.
\end{enumerate}
Senza Reflection, framework come Spring, Hibernate o JUnit non potrebbero esistere.
\end{interview}

\section{Novità recenti (Java 14 - 21)}

Per dimostrare di essere aggiornati, citare queste feature è essenziale.

\subsection{1. Records (Java 16)}
Classi immutabili "data-carrier". Sostituiscono i DTO pieni di boilerplate.
\begin{lstlisting}
public record Point(int x, int y) {} 
// Genera automaticamente: costruttore, equals, hashCode, toString e getters.
\end{lstlisting}

\subsection{2. Pattern Matching per instanceof (Java 16)}
Basta cast manuali.
\begin{lstlisting}
if (obj instanceof String s) { // Crea variabile 's' automaticamente castata
    System.out.println(s.length());
}
\end{lstlisting}

\subsection{3. Sealed Classes (Java 17)}
Permettono di controllare chi può estendere una classe (gerarchie chiuse). Ottimo per il Domain Modeling sicuro.
\begin{lstlisting}
public abstract sealed class Shape permits Circle, Square { ... }
\end{lstlisting}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Multithreading e Concorrenza}

Scrivere codice che esegue più operazioni simultaneamente è essenziale per sfruttare le moderne CPU multi-core e mantenere le applicazioni reattive. Tuttavia, la concorrenza introduce classi di bug complesse (Race Conditions, Deadlocks) e richiede una comprensione profonda di come la JVM interagisce con il Sistema Operativo sottostante.

\section{Processi vs Threads e Ciclo di Vita}

Per capire veramente come funziona un Thread in Java, dobbiamo scendere un gradino sotto il linguaggio e osservare l'architettura del Sistema Operativo.

\subsection{Architettura: User Space, Kernel e System Calls}
La memoria di un computer gestito da un Sistema Operativo moderno (Linux, Windows, macOS) è divisa in due zone di sicurezza rigorosamente separate:

\begin{enumerate}
    \item \textbf{User Space (Spazio Utente):} È la zona "non privilegiata" dove girano le applicazioni standard, inclusa la JVM. Qui il codice ha accesso alla memoria allocata per il programma (Heap Java), ma \textbf{non ha accesso diretto all'hardware} (Disco, Scheda di Rete, Thread della CPU).
    \item \textbf{Kernel Space (Spazio Kernel):} È il "cuore" del sistema operativo. Ha privilegi totali e controlla l'hardware. Gestisce lo scheduling dei processi e l'I/O.
\end{enumerate}

\begin{deepdive}{Cos'è una System Call?}
    Quando un thread Java vuole fare un'operazione "reale" (es. leggere un file, aprire una connessione Socket, o creare un nuovo thread), non può farlo da solo perché gira in User Space.
    Deve chiedere il permesso al Kernel.
    
    Questa richiesta si chiama \textbf{System Call (SysCall)}.
    
    Il flusso è costoso:
    \begin{enumerate}
        \item Il programma in User Space invoca una funzione di libreria.
        \item Viene scatenata un'interruzione software.
        \item La CPU esegue un \textbf{Context Switch}: salva lo stato del programma corrente, cambia modalità in \textit{Kernel Mode} ed esegue l'operazione.
        \item Il risultato viene copiato dallo spazio Kernel allo spazio User.
        \item La CPU torna in \textit{User Mode} e riprende il programma.
    \end{enumerate}
    Questo costo (overhead) è il motivo per cui creare migliaia di thread nativi è sconsigliato.
\end{deepdive}

\begin{center}
\begin{tikzpicture}[
    node distance=0cm,
    box/.style={rectangle, draw=black, minimum width=8cm, minimum height=1.5cm, align=center, font=\sffamily},
    arrow/.style={->, >=stealth, thick}
]
    % Zones
    \node[box, fill=deepblue!10, draw=deepblue] (user) {\textbf{User Space}\\(JVM, La tua App)};
    \node[box, fill=javared!10, draw=javared, below=1cm of user] (kernel) {\textbf{Kernel Space}\\(Drivers, CPU Scheduler, I/O)};

    % Arrows
    \draw[arrow, deepblue] ([xshift=-2cm]user.south) -- node[left, font=\scriptsize] {System Call (Richiesta)} ([xshift=-2cm]kernel.north);
    \draw[arrow, javared] ([xshift=2cm]kernel.north) -- node[right, font=\scriptsize] {Return (Risultato)} ([xshift=2cm]user.south);

    % Divider
    \draw[dashed, thick, gray] (-5, -0.5) -- (5, -0.5) node[right] {Boundary};

\end{tikzpicture}
\end{center}

\subsection{Processo vs Thread}
Spesso confusi, hanno differenze strutturali enormi:

\begin{itemize}
    \item \textbf{Processo:} È un'istanza di un programma in esecuzione (es. l'intero processo \texttt{java.exe}).
    \begin{itemize}
        \item Ha un proprio spazio di indirizzamento memoria \textbf{isolato}. Se un processo crasha, non influenza gli altri.
        \item La comunicazione tra processi (IPC) è lenta e complessa.
    \end{itemize}
    \item \textbf{Thread:} È l'unità più piccola di esecuzione all'interno di un processo.
    \begin{itemize}
        \item I thread di uno stesso processo \textbf{condividono la memoria} (lo Heap).
        \item Hanno però un proprio \textbf{Stack} privato (per le variabili locali e la catena delle chiamate).
        \item Sono "leggeri" rispetto ai processi, ma "pesanti" in termini assoluti (circa 1-2MB di RAM riservata per lo stack di ogni thread).
    \end{itemize}
\end{itemize}

\subsection{User Threads vs Daemon Threads}
In Java, i thread non sono tutti uguali. Esiste una proprietà chiamata "Daemon" che cambia il modo in cui la JVM decide quando spegnersi.

\begin{itemize}
    \item \textbf{User Thread (Default):} Sono i thread "lavoratori" o "protagonisti". La JVM \textbf{resta in vita} finché esiste almeno un User Thread attivo (anche se il metodo \texttt{main} è terminato).
    \item \textbf{Daemon Thread:} Sono thread di "servizio" o "background" (es. il Garbage Collector, o un thread che invia statistiche di monitoraggio). La loro esistenza dipende dagli User Thread.
    \textbf{Regola:} Se tutti gli User Thread terminano, la JVM uccide istantaneamente tutti i Daemon Thread rimasti e si chiude.
\end{itemize}

\begin{lstlisting}[language=Java, caption=Creazione di un Daemon Thread]
Thread backgroundTask = new Thread(() -> {
    while(true) {
        System.out.println("Pulizia cache in background...");
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
    }
});

// FONDAMENTALE: Va settato PRIMA di chiamare start()
// Se lo fai dopo, lancia IllegalThreadStateException.
backgroundTask.setDaemon(true); 

backgroundTask.start();
System.out.println("Main terminato");
// Risultato: La JVM si chiude subito dopo questa riga.
// Il thread 'backgroundTask' viene ucciso immediatamente,
// probabilmente prima di stampare "Pulizia...".
\end{lstlisting}

\subsection{I Metodi Fondamentali (API Lifecycle)}
Oltre a \texttt{start()}, la classe \texttt{Thread} espone metodi critici per orchestrare l'esecuzione e la cooperazione tra thread. È vitale distinguere tra metodi \textbf{statici} (che agiscono sempre sul thread \textit{corrente}) e metodi \textbf{di istanza} (che agiscono sul thread rappresentato dall'oggetto).

\begin{enumerate}
    \item \textbf{\texttt{static void sleep(long millis)}}:
    Mette in pausa il thread \textbf{corrente} per un tempo determinato.
    Lo stato del thread passa da \textit{RUNNABLE} a \textit{TIMED\_WAITING}.
    \textbf{Nota:} Non rilascia i lock o i monitor che il thread possiede!
    
    \item \textbf{\texttt{void join()}}:
    Permette a un thread di "aspettare" la fine di un altro.
    Se il Thread A chiama \texttt{B.join()}, il Thread A si blocca (entra in \textit{WAITING}) finché il Thread B non termina la sua esecuzione. È essenziale per coordinare risultati.

    \item \textbf{\texttt{static void yield()}}:
    È un suggerimento allo Scheduler del Sistema Operativo. Il thread corrente dice: \textit{"Ho finito la mia fase critica, se c'è qualcun altro che vuole usare la CPU, mi faccio da parte"}.
    \textbf{Attenzione:} Lo scheduler può ignorare questo suggerimento. Non garantisce nulla.
    
    \item \textbf{\texttt{void interrupt()}}:
    Invia un segnale di interruzione al thread target. Non ferma il thread brutalmente (come il deprecato \texttt{stop()}), ma setta solo un flag booleano interno. Sta al codice del thread controllare questo flag e terminare gentilmente.
\end{enumerate}

\begin{interview}{Start() vs Run()}
    \textbf{Domanda:} "Qual è la differenza tra chiamare \texttt{t.start()} e \texttt{t.run()}?"
    
    \textbf{Risposta:} È la differenza tra "Concorrenza" e "Chiamata di metodo sequenziale".
    \begin{itemize}
        \item \textbf{\texttt{t.run()}}: Esegue il corpo del metodo \texttt{run} nel \textbf{thread corrente} (es. main). Non viene creato nessun nuovo stack, non c'è parallelismo. È una semplice chiamata di funzione.
        \item \textbf{\texttt{t.start()}}: Fa una System Call al sistema operativo per allocare un nuovo Thread nativo, crea un nuovo Stack, e istruisce lo scheduler OS di eseguire il metodo \texttt{run} in quel nuovo contesto.
    \end{itemize}
\end{interview}

\begin{interview}{Differenza tra sleep() e wait()}
    Questa è una delle domande più frequenti in assoluto. Entrambi mettono in pausa il thread, ma con una differenza enorme nella gestione della sincronizzazione.
    
    \begin{itemize}
        \item \textbf{\texttt{Thread.sleep()}}:
        \begin{itemize}
            \item È un metodo statico di \texttt{Thread}.
            \item \textbf{Mantiene i Lock:} Se il thread ha acquisito un lock (è dentro un \texttt{synchronized}), va a dormire \textit{tenendosi le chiavi in tasca}. Nessun altro può entrare in quella sezione critica.
            \item Usato per: attese temporali.
        \end{itemize}
        
        \item \textbf{\texttt{Object.wait()}}:
        \begin{itemize}
            \item È un metodo di \texttt{Object} (ogni oggetto ce l'ha).
            \item \textbf{Rilascia il Lock:} Il thread rilascia il monitor e va in attesa. Altri thread possono entrare nel blocco \texttt{synchronized}.
            \item Usato per: comunicazione inter-thread (notify).
        \end{itemize}
    \end{itemize}
\end{interview}

\begin{deepdive}{Interrupt: I tre metodi della confusione}
    Gestire l'interruzione è complicato perché ci sono tre metodi con nomi simili:
    
    \begin{enumerate}
        \item \texttt{interrupt()} (Istanza): "Bussa alla porta". Setta il flag \textit{interrupted status} a \texttt{true}.
        \item \texttt{isInterrupted()} (Istanza): Controlla il flag senza modificarlo. Restituisce \texttt{true/false}.
        \item \texttt{Thread.interrupted()} (Statico): Controlla il flag del thread corrente e \textbf{lo resetta a false}!
        \textit{Perché resettarlo?} È utile se vuoi "consumare" l'interruzione e continuare a lavorare pulito, ma è fonte di molti bug se usato per sbaglio al posto di \texttt{isInterrupted()}.
    \end{enumerate}
\end{deepdive}

\section{Problemi di Concorrenza: Race Condition e Deadlock}

La programmazione concorrente introduce una classe di bug subdoli legati alla gestione dello \textit{stato condiviso mutabile}.
Se due thread operano sugli stessi dati senza coordinamento, il risultato diventa dipendente dalla tempistica di esecuzione (interleaving).

\subsection{Race Condition (Condizione di Corsa)}
Una Race Condition si verifica quando la correttezza di un calcolo dipende dalla sequenza temporale relativa o dall'ordine di esecuzione di più thread.
Il caso più classico è l'operazione \textbf{Read-Modify-Write} non atomica.

\begin{lstlisting}[language=Java, caption=Esempio di Race Condition (Il Contatore)]
public class UnsafeCounter {
    private int count = 0;

    // QUESTO METODO NON E' THREAD-SAFE!
    public void increment() {
        count++; 
    }
    
    public int getCount() { return count; }
}
\end{lstlisting}

Se lanciamo due thread che chiamano \texttt{increment()} 1000 volte ciascuno, ci aspettiamo che il risultato finale sia 2000. Spesso, invece, otteniamo un numero inferiore (es. 1998, 1850). Perché?

\begin{deepdive}{Anatomia di count++}
    Agli occhi del programmatore Java, \texttt{count++} sembra un'unica istruzione.
    Agli occhi della CPU (e del Bytecode), sono \textbf{tre} istruzioni distinte:
    
    \begin{enumerate}
        \item \textbf{READ:} Leggi il valore corrente di \texttt{count} dalla memoria in un registro locale (es. valore 10).
        \item \textbf{MODIFY:} Incrementa il valore nel registro (10 + 1 = 11).
        \item \textbf{WRITE:} Scrivi il nuovo valore (11) nella memoria principale.
    \end{enumerate}
    
    \textbf{Lo scenario del disastro:}
    \begin{itemize}
        \item \textbf{Thread A} legge 10.
        \item \textit{Context Switch! Il sistema operativo mette in pausa A e avvia B.}
        \item \textbf{Thread B} legge 10 (perché A non ha ancora scritto 11).
        \item \textbf{Thread B} calcola 11 e scrive 11.
        \item \textit{Context Switch! Torna A.}
        \item \textbf{Thread A} (che aveva già calcolato 11 nel suo registro) scrive 11.
    \end{itemize}
    \textbf{Risultato:} Due incrementi effettuati, ma il contatore è salito solo di 1. L'aggiornamento di B è stato sovrascritto ("Lost Update").
\end{deepdive}

\subsection{Deadlock (Stallo)}
Il Deadlock è una situazione in cui due o più thread sono bloccati per sempre, in attesa l'uno dell'altro. Nessuno può progredire.
Accade spesso quando si usano più lock annidati.

\begin{lstlisting}[language=Java, caption=Esempio classico di Deadlock]
public class DeadlockDemo {
    private final Object lockA = new Object();
    private final Object lockB = new Object();

    public void thread1() {
        synchronized(lockA) {
            System.out.println("T1: Preso Lock A");
            try { Thread.sleep(100); } catch (Exception e){}
            
            synchronized(lockB) { // T1 vuole B, ma ce l'ha T2
                System.out.println("T1: Preso Lock B");
            }
        }
    }

    public void thread2() {
        synchronized(lockB) {
            System.out.println("T2: Preso Lock B");
            try { Thread.sleep(100); } catch (Exception e){}
            
            synchronized(lockA) { // T2 vuole A, ma ce l'ha T1
                System.out.println("T2: Preso Lock A");
            }
        }
    }
}

public class MainDeadlock {
    public static void main(String[] args) {
        DeadlockDemo demo = new DeadlockDemo();

        // **Creazione dei Thread**
        Thread t1 = new Thread(() -> demo.thread1(), "Thread-1");
        Thread t2 = new Thread(() -> demo.thread2(), "Thread-2");

        // **Avvio dei Thread**
        t1.start();
        t2.start();

        System.out.println("Avviati Thread-1 e Thread-2");
    }
}
\end{lstlisting}

In questo scenario:
\begin{itemize}
    \item T1 possiede A e aspetta B.
    \item T2 possiede B e aspetta A.
    \item È un abbraccio mortale (Circular Wait).
\end{itemize}

\begin{interview}{Come prevenire e diagnosticare un Deadlock?}
    \textbf{Domanda:} "Come fai a evitare i deadlock nel tuo codice?"
    
    \textbf{Risposta:}
    \begin{enumerate}
        \item \textbf{Lock Ordering (Ordine Globale):} È la soluzione matematica. Se tutti i thread acquisiscono i lock nello stesso ordine (es. Sempre prima A, poi B), il deadlock circolare diventa impossibile.
        \item \textbf{Timeouts:} Usare \texttt{ReentrantLock.tryLock(timeout)} invece di \texttt{synchronized}. Se non riesco a prendere il lock entro 1 secondo, rinuncio e torno indietro (evitando di bloccarmi per sempre).
        \item \textbf{Diagnosi:} Se un'applicazione Java si blocca in produzione, uso il comando \texttt{jstack <pid>}. Il dump mostrerà chiaramente: \textit{"Found one Java-level deadlock"}.
    \end{enumerate}
\end{interview}

\section{Sincronizzazione e Lock Base}

Per risolvere le Race Condition, dobbiamo introdurre dei meccanismi di controllo per gestire l'accesso allo stato condiviso.
Java offre strumenti nativi per garantire due proprietà fondamentali:
\begin{enumerate}
    \item \textbf{Atomicità (Mutual Exclusion):} Solo un thread alla volta può eseguire un blocco di codice.
    \item \textbf{Visibilità (Memory Consistency):} Le modifiche fatte da un thread devono essere immediatamente visibili agli altri thread (bypassando le cache della CPU).
\end{enumerate}

\subsection{La keyword \texttt{synchronized}}
È il meccanismo di locking più antico e semplice di Java. Si basa sul concetto di \textbf{Monitor Lock} (o Intrinsic Lock): in Java, \textit{ogni oggetto} può fungere da lucchetto.

\begin{itemize}
    \item Quando un thread entra in un blocco \texttt{synchronized}, acquisisce il lock dell'oggetto.
    \item Se un altro thread prova a entrare, trova il lock occupato e viene messo in stato \textbf{BLOCKED} (sospeso dal sistema operativo) finché il primo non esce.
    \item Garantisce sia \textbf{Atomicità} che \textbf{Visibilità}.
\end{itemize}

\begin{lstlisting}[language=Java, caption=Rendere il contatore Thread-Safe]
public class SafeCounter {
    private int count = 0;
    // Lock implcito: 'this' (l'istanza corrente)
    public synchronized void increment() {
        count++; 
    }
    // Anche le letture devono essere sincronizzate per garantire la visibilità!
    public synchronized int getCount() {
        return count;
    }
}
\end{lstlisting}

\subsection{La keyword \texttt{volatile}}
Spesso fraintesa, \texttt{volatile} è una forma di sincronizzazione "leggera".
\textbf{Garantisce solo la Visibilità, NON l'Atomicità.}

\begin{deepdive}{Il problema della Cache CPU}
    Le CPU moderne hanno cache (L1, L2, L3) velocissime.
    Se il Thread A modifica una variabile \texttt{flag = true}, potrebbe scrivere questo valore solo nella sua Cache L1 locale, senza aggiornare subito la RAM principale.
    Il Thread B (che gira su un altro Core) continua a leggere \texttt{flag = false} dalla sua cache.
    
    Dichiarando \texttt{private volatile boolean flag}, obblighi la JVM a:
    \begin{enumerate}
        \item Scrivere immediatamente le modifiche in \textbf{Main Memory (RAM)}.
        \item Invalidare le cache degli altri core per quella variabile.
    \end{enumerate}
\end{deepdive}

\begin{interview}{Volatile e i++}
    \textbf{Domanda:} "Se dichiaro \texttt{volatile int count = 0}, l'operazione \texttt{count++} diventa thread-safe?"
    
    \textbf{Risposta:} \textbf{NO.}
    \texttt{volatile} garantisce che tutti vedano l'ultimo valore scritto, ma non protegge la sequenza "Leggi-Modifica-Scrivi". Due thread potrebbero ancora leggere lo stesso valore contemporaneamente e sovrascriversi.
    Usa \texttt{volatile} solo per flag di stato (es. \texttt{isRunning}) o variabili scritte da un solo thread e lette da molti.
\end{interview}

\subsection{Variabili Atomiche e CAS (Compare-And-Swap)}
Usare \texttt{synchronized} è costoso perché blocca i thread (Context Switch).
Per operazioni semplici (contatori, accumumulatori), Java fornisce il pacchetto \texttt{java.util.concurrent.atomic}.
Queste classi non usano lock, ma si basano su una strategia \textbf{Optimistic} supportata dall'hardware.

\begin{lstlisting}[language=Java, caption=AtomicInteger]
private AtomicInteger count = new AtomicInteger(0);

public void increment() {
    // Thread-safe, veloce e non-bloccante
    count.incrementAndGet(); 
}
\end{lstlisting}

\begin{deepdive}{Deep Dive: Come funziona il CAS?}
    Il \textbf{Compare-And-Swap (CAS)} è un'istruzione di basso livello della CPU.
    Accetta tre parametri:
    \begin{enumerate}
        \item \textbf{M:} Indirizzo di memoria.
        \item \textbf{E:} Valore Atteso (Expected).
        \item \textbf{N:} Nuovo Valore (New).
    \end{enumerate}
    
    L'algoritmo atomico eseguito dalla CPU è:
    \textit{"Guarda l'indirizzo M. Se contiene E, scrivi N e ritorna true. Altrimenti (qualcun altro ha cambiato il valore nel frattempo), non fare nulla e ritorna false."}
    
    Java usa questo in un ciclo (spinlock) finché non ha successo:
    \begin{small}
    \begin{verbatim}
    int current, next;
    do {
        current = get();      // Leggo il valore attuale (es. 10)
        next = current + 1;   // Calcolo il prossimo (11)
        // Provo a scrivere atomically. Se nel frattempo è diventato 12,
        // il CAS fallisce e il ciclo si ripete rileggendo 12.
    } while (!compareAndSet(current, next));
    \end{verbatim}
    \end{small}
\end{deepdive}

\section{Strumenti di Sincronizzazione Avanzata}

Sebbene la keyword \texttt{synchronized} sia semplice da usare, è rigida: il blocco è implicito, non si può interrompere un thread in attesa del lock e non si può tentare di acquisire il lock con un timeout.
Il pacchetto \texttt{java.util.concurrent.locks} offre primitive più potenti e flessibili.

\subsection{ReentrantLock: Il Lock Esplicito}
Il \texttt{ReentrantLock} è un'implementazione dell'interfaccia \texttt{Lock} che offre le stesse garanzie di atomicità e visibilità di \texttt{synchronized}, ma con controllo manuale.
Si chiama "Reentrant" perché lo stesso thread può riacquisire il lock più volte (ricorsivamente) senza bloccarsi su se stesso.

\begin{interview}{Synchronized vs ReentrantLock}
    \textbf{Domanda:} "Perché dovrei complicarmi la vita con \texttt{ReentrantLock} invece di usare \texttt{synchronized}?"
    
    \textbf{Risposta:} Ci sono tre casi d'uso dove \texttt{synchronized} fallisce:
    \begin{enumerate}
        \item \textbf{Timeout (Prevenzione Deadlock):} Con \texttt{synchronized}, se il lock è occupato, aspetti in eterno. Con \texttt{lock.tryLock(1, TimeUnit.SECONDS)}, se non ottieni il lock entro un secondo, puoi rinunciare e fare altro.
        \item \textbf{Fairness (Equità):} \texttt{synchronized} è "ingiusto": se 100 thread aspettano, ne sceglie uno a caso (rischio Starvation). \texttt{ReentrantLock(true)} gestisce una coda FIFO: chi arriva prima, entra prima.
        \item \textbf{Interruptibility:} Un thread bloccato su \texttt{synchronized} non può essere interrotto. Con \texttt{lock.lockInterruptibly()}, puoi svegliarlo.
    \end{enumerate}
\end{interview}

\begin{lstlisting}[language=Java, caption=Pattern Try-Finally (Obbligatorio)]
private final ReentrantLock lock = new ReentrantLock();

public void safeMethod() {
    lock.lock(); // 1. Acquisisco il lock
    try {
        // Sezione Critica: Eseguo operazioni rischiose
        doCriticalWork();
    } finally {
        // 2. FONDAMENTALE: Rilascio nel finally
        // Se il codice sopra lancia un'eccezione, il lock DEVE essere rilasciato
        // altrimenti avremo un Deadlock globale.
        lock.unlock(); 
    }
}
\end{lstlisting}

\subsection{Semaphore: Gestione dei Permessi (Throttling)}
Mentre un Lock è un meccanismo di \textbf{Mutua Esclusione} (accesso 1 a 1), un \texttt{Semaphore} gestisce un set di \textbf{permessi} (Permits). È utile per limitare il carico (Throttling) su una risorsa che può gestire più richieste contemporanee, ma non infinite.

\textit{Analogia:} Immagina un parcheggio con 5 posti.
\begin{itemize}
    \item Se arrivano 5 auto, entrano tutte (il contatore scende a 0).
    \item La 6° auto si ferma alla sbarra (\texttt{acquire()}) e aspetta.
    \item Quando un'auto esce (\texttt{release()}), la sbarra si alza per chi aspetta.
\end{itemize}

\begin{lstlisting}[language=Java, caption=Semaphore per limitare connessioni DB]
public class ConnectionPool {
    // Solo 5 thread possono accedere simultaneamente
    private final Semaphore semaphore = new Semaphore(5);

    public void accessDatabase() {
        try {
            // Prende un permesso. Se count == 0, si blocca qui.
            semaphore.acquire(); 
            
            System.out.println("Connessione acquisita: " + Thread.currentThread().getName());
            // Simulazione lavoro...
            Thread.sleep(100); 
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            // Restituisce il permesso, svegliando eventuali thread in coda
            semaphore.release(); 
            System.out.println("Connessione rilasciata");
        }
    }
}
\end{lstlisting}

\begin{deepdive}{Lock vs Semaphore}
    Una differenza sottile ma importante:
    \begin{itemize}
        \item Il \textbf{Lock} ha un proprietario (Owner): solo il thread che ha fatto \texttt{lock()} può fare \texttt{unlock()}.
        \item Il \textbf{Semaphore} non ha proprietario: il thread A può fare \texttt{acquire()} e il thread B può fare \texttt{release()} (utile in pattern produttore-consumatore particolari o death-detection).
    \end{itemize}
\end{deepdive}

\section{Pattern di Coordinamento e Code}

Uno dei pattern più diffusi nei sistemi concorrenti è il \textbf{Producer-Consumer} (Produttore-Consumatore).
In passato, questo si implementava usando i metodi di basso livello \texttt{Object.wait()} e \texttt{Object.notify()}, ma questo approccio è difficile da mantenere e prono a errori (es. \textit{Spurious Wakeups} o segnali persi).

Java offre soluzioni di alto livello nel pacchetto \texttt{java.util.concurrent}, in particolare l'interfaccia \textbf{BlockingQueue}.

\subsection{BlockingQueue: La Coda Thread-Safe}
Una \texttt{BlockingQueue} è una struttura dati che gestisce automaticamente la sincronizzazione tra thread.
Ha due proprietà chiave che eliminano la necessità di controlli manuali:
\begin{itemize}
    \item Se la coda è \textbf{Piena}, il thread Produttore che chiama \texttt{put()} viene bloccato (messo in attesa) finché non si libera uno spazio.
    \item Se la coda è \textbf{Vuota}, il thread Consumatore che chiama \texttt{take()} viene bloccato finché non arriva un nuovo elemento.
\end{itemize}

\begin{lstlisting}[language=Java, caption=Producer-Consumer con ArrayBlockingQueue]
public class QueueDemo {
    // Coda con capacità fissa di 10 elementi
    private BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);

    public void start() {
        // PRODUTTORE
        new Thread(() -> {
            try {
                for (int i = 0; i < 100; i++) {
                    String msg = "Messaggio " + i;
                    // Si blocca qui se la coda è piena (nessun dato perso)
                    queue.put(msg); 
                    System.out.println("Prodotto: " + msg);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        // CONSUMATORE
        new Thread(() -> {
            try {
                while (true) {
                    // Si blocca qui se la coda è vuota (nessun busy-waiting)
                    String msg = queue.take(); 
                    System.out.println("Consumato: " + msg);
                    process(msg);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
    
    private void process(String msg) { /* Simulazione lavoro */ }
}
\end{lstlisting}

\subsection{Poison Pill Pattern (La Pillola Avvelenata)}
Un problema comune con i consumatori è: \textit{"Come faccio a fermare il loop \texttt{while(true)} in modo pulito?"}.
Uccidere il thread con \texttt{stop()} è deprecato. Interromperlo mentre lavora potrebbe lasciare dati corrotti.

La soluzione elegante è il \textbf{Poison Pill Pattern}: inseriamo nella coda un oggetto speciale che significa "Fine delle trasmissioni". Quando il consumatore lo pesca, sa che deve terminare.

\begin{lstlisting}[language=Java, caption=Poison Pill Implementation]
public class GracefulShutdownDemo {
    // Oggetto sentinella (o una costante stringa specifica)
    private static final String POISON_PILL = "###STOP###";
    private BlockingQueue<String> queue = new LinkedBlockingQueue<>();

    public void producer() {
        try {
            queue.put("Job A");
            queue.put("Job B");
            // ... fine del lavoro ...
            queue.put(POISON_PILL); // Invia segnale di stop
        } catch (InterruptedException e) { ... }
    }

    public void consumer() {
        try {
            while (true) {
                String msg = queue.take();
                
                // Controllo se è la pillola
                if (msg.equals(POISON_PILL)) {
                    System.out.println("Ricevuto segnale di stop. Chiusura...");
                    break; // Esce dal loop while in modo pulito
                }
                
                process(msg);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
\end{lstlisting}

\begin{deepdive}{Multiple Consumers e Poison Pill}
    Se hai \textbf{più consumatori} (es. 5 thread che leggono dalla stessa coda), inserire una sola Poison Pill non basta: la leggerà solo il primo consumatore fortunato, che si spegnerà, mentre gli altri 4 rimarranno bloccati in eterno su \texttt{take()}.
    
    \textbf{Soluzione:} Il produttore deve inserire \textbf{N Poison Pills} (una per ogni consumatore), oppure ogni consumatore, prima di morire, deve rimettere la pillola nella coda per il prossimo.
\end{deepdive}

\section{Gestione delle Risorse: Thread Pools ed Executors}

Abbiamo visto come creare un thread con \texttt{new Thread().start()}. Tuttavia, in un'applicazione Enterprise, creare thread manualmente è considerato una \textbf{Bad Practice}.

\subsection{Il costo di \texttt{new Thread()}}
Riprendendo il concetto di System Call visto all'inizio:
\begin{itemize}
    \item La creazione di un thread richiede l'allocazione di memoria per lo stack (circa 1MB).
    \item Richiede una chiamata al Kernel.
    \item Se arrivano 10.000 richieste e creiamo 10.000 thread, il server andrà in \textbf{OutOfMemoryError} o la CPU passerà il 100\% del tempo a fare Context Switch invece che lavorare.
\end{itemize}

\subsection{Il concetto di "Task" vs "Thread"}
Java 5 ha introdotto l'\textbf{Executor Framework} per disaccoppiare "cosa deve essere fatto" da "chi lo fa".

\begin{itemize}
    \item \textbf{Task (Il Lavoro):} È l'unità logica di lavoro. Rappresentato da \texttt{Runnable} (se non ritorna nulla) o \texttt{Callable<T>} (se ritorna un risultato).
    \item \textbf{Thread (Il Lavoratore):} È la risorsa fisica che esegue il task.
    \item \textbf{Thread Pool (Il Gestore):} È un gruppo di thread riutilizzabili che prelevano i task da una coda.
\end{itemize}

L'idea è: invece di creare un nuovo lavoratore per ogni mattone da spostare, assumiamo 10 lavoratori fissi e mettiamo i mattoni in una coda.

\subsection{L'interfaccia ExecutorService}
Invece di lavorare con la classe \texttt{Thread}, interagiamo con \texttt{ExecutorService}.

\begin{lstlisting}[language=Java, caption=Uso di un Thread Pool Fisso]
// Creo un pool con ESATTAMENTE 4 thread (es. numero di Core CPU)
ExecutorService executor = Executors.newFixedThreadPool(4);

for (int i = 0; i < 1000; i++) {
    int taskId = i;
    // Sottometto 1000 task.
    // Non vengono creati 1000 thread!
    // I 4 thread si scambiano i task man mano che finiscono.
    executor.submit(() -> {
        System.out.println("Task " + taskId + " eseguito da " + 
                           Thread.currentThread().getName());
    });
}

// Importante: chiudere il pool alla fine
executor.shutdown();
\end{lstlisting}

\subsection{Tipologie di Pool (Executors Factory)}
La classe \texttt{Executors} offre vari metodi factory. È vitale conoscerne le differenze e i pericoli.

\begin{enumerate}
    \item \textbf{FixedThreadPool(n):}
    Ha un numero fisso di thread. Se tutti sono occupati, i nuovi task finiscono in una \texttt{LinkedBlockingQueue} di attesa.
    \textit{Uso:} Ideale per carichi prevedibili e CPU-bound.
    
    \item \textbf{CachedThreadPool():}
    Non ha un limite massimo di thread. Se arrivano task e tutti i thread sono occupati, ne crea di nuovi. Se un thread sta fermo per 60 secondi, viene distrutto.
    \textit{Uso:} Per task brevi e sporadici.
    
    \item \textbf{SingleThreadExecutor():}
    Ha un solo thread. Garantisce che i task vengano eseguiti \textbf{sequenzialmente} (uno dopo l'altro).
    
    \item \textbf{ScheduledThreadPool(n):}
    Sostituisce il vecchio \texttt{java.util.Timer}. Permette di eseguire task con ritardo o periodicamente (es. ogni 10 secondi).
\end{enumerate}

\begin{interview}{Perché NON usare Executors.newCachedThreadPool() in produzione?}
    \textbf{Domanda:} "In un server ad alto traffico, qual è il rischio di usare \texttt{CachedThreadPool} o \texttt{FixedThreadPool}?"
    
    \textbf{Risposta:}
    \begin{itemize}
        \item \textbf{CachedThreadPool:} Se il traffico esplode, crea thread all'infinito fino a saturare la RAM (\texttt{OutOfMemoryError}). Non ha freni.
        \item \textbf{FixedThreadPool:} Anche se i thread sono fissi, la \textbf{coda di attesa} interna è illimitata (\texttt{Integer.MAX\_VALUE}). Se i task arrivano più velocemente di quanto vengano smaltiti, la coda riempie la Heap Memory fino al crash.
    \end{itemize}
    
    \textbf{Soluzione Senior:} In produzione non si usano i metodi factory di \texttt{Executors}. Si istanzia manualmente \texttt{ThreadPoolExecutor} configurando una coda con capacità limitata (Bounded Queue) e una \textit{Rejection Policy} (cosa fare quando la coda è piena: scartare? lanciare eccezione?).
\end{interview}

\begin{deepdive}{Configurazione Manuale Sicura}
Ecco come si crea un pool "a prova di bomba" per la produzione:

\begin{small}
\begin{verbatim}
ExecutorService safePool = new ThreadPoolExecutor(
    4,  // Core Pool Size (Thread minimi)
    10, // Max Pool Size (Thread massimi sotto carico)
    60L, TimeUnit.SECONDS, // Tempo di vita dei thread extra
    new ArrayBlockingQueue<>(500), // CODA LIMITATA a 500 task
    new ThreadPoolExecutor.CallerRunsPolicy() // Se piena, esegue il chiamante 
												//(rallenta il flusso)
);
\end{verbatim}
\end{small}
\end{deepdive}

\subsection{I Metodi dell'ExecutorService: Submit e Shutdown}
Una volta ottenuto un'istanza di \texttt{ExecutorService}, dobbiamo interagire con essa. L'interfaccia offre due categorie principali di metodi: quelli per sottomettere i task e quelli per gestire il ciclo di vita del pool.

\subsubsection{1. Sottomissione dei Task}
Esistono due modi per passare lavoro al pool. Scegliere quello giusto è importante per la gestione delle eccezioni.

\begin{itemize}
    \item \textbf{\texttt{void execute(Runnable command)}}:
    Metodo "Fire-and-Forget". Si passa un task che non restituisce nulla.
    \textit{Difetto:} Se il task lancia un'eccezione non controllata (RuntimeException), l'eccezione viene stampata sulla console e il thread potrebbe morire (venendo rimpiazzato dal pool), ma il chiamante non ha modo di saperlo o gestirlo.
    
    \item \textbf{\texttt{Future<T> submit(Callable<T> task)}}:
    Il metodo preferito. Restituisce un oggetto \texttt{Future} che rappresenta il risultato pendente.
    \textit{Vantaggio:} Se il task lancia un'eccezione, questa viene "catturata" e conservata dentro il Future. Verrà rilanciata (come \texttt{ExecutionException}) solo quando chiamerai \texttt{future.get()}.
\end{itemize}

\begin{interview}{execute() vs submit()}
    \textbf{Domanda:} "Qual è la differenza fondamentale nella gestione degli errori tra \texttt{execute} e \texttt{submit}?"
    
    \textbf{Risposta:}
    \begin{itemize}
        \item Con \textbf{\texttt{execute()}}, le eccezioni "scappano" dallo stack del thread e finiscono nell'\texttt{UncaughtExceptionHandler}. Se non ne hai configurato uno, vedi solo lo stacktrace nei log di sistema.
        \item Con \textbf{\texttt{submit()}}, l'eccezione è "ingabbiata" nel Future. Il task sembra finire con successo, ma l'errore esplode solo quando il thread principale chiede il risultato.
    \end{itemize}
\end{interview}

\subsubsection{2. Spegnimento (Shutdown)}
Un \texttt{ExecutorService} non è un oggetto normale: contiene thread attivi. Se il tuo programma Java finisce il `main` ma non spegni il pool, la JVM \textbf{non si chiuderà mai} (perché i thread del pool sono User Threads, non Daemon).

Ecco la "Trinità dello Shutdown":

\begin{itemize}
    \item \textbf{\texttt{void shutdown()}}:
    Lo spegnimento "gentile". Il pool smette di accettare \textit{nuovi} task, ma continua a lavorare per finire quelli già in coda. È asincrono (ritorna subito).
    
    \item \textbf{\texttt{List<Runnable> shutdownNow()}}:
    Lo spegnimento "brutale". Tenta di fermare i thread attivi (usando \texttt{interrupt()}) e restituisce una lista dei task che erano in coda e non sono mai partiti.
    
    \item \textbf{\texttt{boolean awaitTermination(long timeout, TimeUnit unit)}}:
    Metodo bloccante. Il thread corrente aspetta che il pool sia effettivamente spento (tutti i task finiti). Restituisce \texttt{true} se il pool si è spento, \texttt{false} se è scaduto il timeout.
\end{itemize}

\begin{lstlisting}[language=Java, caption=Il Pattern "Graceful Shutdown" (Da imparare a memoria)]
ExecutorService pool = Executors.newFixedThreadPool(10);

// ... utilizzo del pool ...

// 1. Smetti di accettare nuovi ordini
pool.shutdown(); 

try {
    // 2. Aspetta un tempo ragionevole (es. 60s) che finiscano i lavori in corso
    if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {
        
        // 3. Tempo scaduto! Forza la chiusura
        pool.shutdownNow(); 
        
        // 4. Aspetta ancora un attimo che i thread rispondano all'interrupt
        if (!pool.awaitTermination(60, TimeUnit.SECONDS))
            System.err.println("Il Pool non vuole terminare!");
    }
} catch (InterruptedException ie) {
    // 5. (Opzionale) Se il thread che sta facendo lo shutdown viene interrotto
    pool.shutdownNow();
    Thread.currentThread().interrupt();
}
\end{lstlisting}

\section{Gestione Asincrona: Future vs CompletableFuture}

Fino a Java 5, il multithreading si basava sul lancio di \texttt{Runnable}, che però avevano un grosso limite: il metodo \texttt{run()} è \texttt{void}. Non restituisce alcun valore.
Se volevamo il risultato di un calcolo parallelo, dovevamo inventarci meccanismi complessi con variabili condivise.

\subsection{L'interfaccia Future (Java 5)}
Java 5 ha introdotto \texttt{Callable<T>} (che restituisce un valore) e \texttt{Future<T>}, un "placeholder" per un risultato che arriverà in futuro.

\begin{lstlisting}[language=Java, caption=Il vecchio approccio con Future]
ExecutorService executor = Executors.newFixedThreadPool(2);

// Sottomettiamo un task che richiede tempo (es. 2 secondi)
Future<Integer> future = executor.submit(() -> {
    Thread.sleep(2000);
    return 42;
});

System.out.println("Faccio altro nel frattempo...");

try {
    // IL PROBLEMA E' QUI:
    // get() è BLOCCANTE. Il main thread si ferma qui e aspetta.
    // Abbiamo perso il vantaggio dell'asincronia nel momento in cui ci serviva il dato.
    Integer result = future.get(); 
    System.out.println("Risultato: " + result);
} catch (Exception e) { e.printStackTrace(); }
\end{lstlisting}

\subsection{CompletableFuture (Java 8): La Rivoluzione}
Il limite di \texttt{Future} è che non puoi dire: \textit{"Quando hai finito, fai questo, poi questo, poi quest'altro"}. Devi per forza bloccarti con \texttt{get()} per orchestrare i passi successivi.

Java 8 introduce \textbf{CompletableFuture}, che implementa il pattern delle \textbf{Promise}. Permette di costruire una \textbf{pipeline} di operazioni che verranno eseguite in cascata, senza mai bloccare il thread principale.

\begin{lstlisting}[language=Java, caption=Pipeline Asincrona con CompletableFuture]
// 1. Avvia un task asincrono (in un thread del ForkJoinPool)
CompletableFuture.supplyAsync(() -> fetchUserId("alessandro"))
    
    // 2. Quando l'ID arriva, usalo per scaricare gli ordini (Chain asincrona)
    .thenCompose(userId -> fetchOrders(userId))
    
    // 3. Quando gli ordini arrivano, calcola il totale (Trasformazione sincrona)
    .thenApply(orders -> calculateTotal(orders))
    
    // 4. Alla fine, stampa il risultato o gestisci l'errore
    .thenAccept(total -> System.out.println("Totale speso: " + total))
    
    .exceptionally(ex -> {
        System.err.println("Qualcosa è andato storto: " + ex.getMessage());
        return null;
    });

// Il main thread prosegue immediatamente, senza aspettare i risultati!
System.out.println("Non mi sono bloccato!");
\end{lstlisting}

\begin{deepdive}{thenApply vs thenCompose}
    È la domanda da "100 punti" sui CompletableFuture (simile a \texttt{map} vs \texttt{flatMap} negli Stream).
    
    \begin{itemize}
        \item \textbf{thenApply (Map):} Prende il valore precedente e lo trasforma.
        \textit{Input: String $\to$ Output: Int.}
        Usa questo se la funzione di trasformazione è veloce e sincrona.
        
        \item \textbf{thenCompose (FlatMap):} Prende il valore precedente e restituisce un \textbf{nuovo CompletableFuture}.
        \textit{Input: String $\to$ Output: CompletableFuture<Int>.}
        Usa questo se lo step successivo è a sua volta un'operazione asincrona (es. chiamare un altro microservizio), per evitare di avere \texttt{Future<Future<Int>>} annidati.
    \end{itemize}
\end{deepdive}

\begin{interview}{Combinare più Future}
    \textbf{Domanda:} "Devo chiamare 3 servizi REST in parallelo e aspettare che abbiano finito tutti. Come faccio?"
    
    \textbf{Risposta:} Si usa \texttt{CompletableFuture.allOf()}.
    \begin{small}
    \begin{verbatim}
    var f1 = CompletableFuture.supplyAsync(() -> service1.call());
    var f2 = CompletableFuture.supplyAsync(() -> service2.call());
    var f3 = CompletableFuture.supplyAsync(() -> service3.call());

    // Crea un nuovo Future che si completa quando TUTTI e 3 sono finiti
    CompletableFuture<Void> allDone = CompletableFuture.allOf(f1, f2, f3);
    
    // Join finale (qui blocchiamo solo alla fine per raccogliere i dati)
    allDone.join();
    \end{verbatim}
    \end{small}
\end{interview}

\section{Java 21: Virtual Threads (Project Loom)}

Nelle sezioni precedenti abbiamo stabilito due verità dolorose:
\begin{enumerate}
    \item I Thread del Sistema Operativo sono costosi (1-2 MB di RAM, Context Switch lento).
    \item Per sopravvivere, dobbiamo usare i Thread Pool per limitarne il numero.
\end{enumerate}

Questo approccio ha funzionato per anni, ma ha un limite: il modello \textit{Thread-per-Request} non scala. Se hai un pool di 200 thread e arrivano 201 richieste che fanno I/O (es. query lenta al DB), la 201esima richiesta deve aspettare in coda, anche se la CPU è scarica.

Con Java 21 (LTS), Project Loom introduce i \textbf{Virtual Threads}, cambiando per sempre le regole del gioco.

\subsection{Platform Threads vs Virtual Threads}
Per capire la rivoluzione, confrontiamo il vecchio e il nuovo:

\begin{itemize}
    \item \textbf{Platform Thread (Il Vecchio):} È un wrapper 1:1 su un thread del Sistema Operativo.
    \begin{itemize}
        \item Gestito dal Kernel.
        \item Stack fisso e grande.
        \item Costoso da creare e bloccare.
    \end{itemize}
    
    \item \textbf{Virtual Thread (Il Nuovo):} È un'entità interamente gestita dalla JVM (User-mode thread).
    \begin{itemize}
        \item Non ha un legame 1:1 con l'OS.
        \item Stack dinamico che parte da pochi byte (nell'Heap).
        \item Possiamo crearne milioni senza finire la memoria.
    \end{itemize}
\end{itemize}

\subsection{Architettura M:N (Mounting e Unmounting)}
Come fanno milioni di Virtual Threads a girare su, ad esempio, 8 Core fisici?
La JVM introduce un livello di indirezione.

\begin{enumerate}
    \item \textbf{Carrier Thread:} È il thread fisico (Platform Thread) che funge da "motore". Ce ne sono pochi (solitamente pari al numero di core CPU).
    \item \textbf{Mounting:} Quando un Virtual Thread deve eseguire calcoli (CPU Bound), la JVM lo "monta" su un Carrier Thread temporaneo.
    \item \textbf{Unmounting (La Magia):} Quando il Virtual Thread chiama un'operazione bloccante (es. \texttt{Thread.sleep()}, \texttt{socket.read()}, query JDBC), la JVM \textbf{non blocca} il Carrier Thread.
    \begin{itemize}
        \item Salva lo stack del Virtual Thread nell'Heap ("congela" lo stato).
        \item Stacca il Virtual Thread dal Carrier.
        \item Il Carrier è ora libero di eseguire un \textit{altro} Virtual Thread.
    \end{itemize}
    \item \textbf{Resuming:} Quando l'operazione di I/O finisce (l'OS notifica la JVM), il Virtual Thread viene riattivato e montato sul primo Carrier disponibile.
\end{enumerate}

\begin{deepdive}{System Calls "Truccate"}
    Nella Sezione 1 abbiamo detto che le System Call sono bloccanti. Come fa Loom a evitarlo?
    
    Gli ingegneri di Java hanno riscritto quasi tutte le librerie standard (\texttt{java.io}, \texttt{java.net}, \texttt{java.util.concurrent}).
    Quando tu scrivi codice bloccante:
    \begin{verbatim}
    // Sembra bloccante...
    var response = httpClient.send(request); 
    \end{verbatim}
    
    Sotto il cofano, la JVM non chiama la System Call bloccante \texttt{read()}. Chiama invece una modalità I/O asincrona del sistema operativo (come \texttt{epoll} su Linux o \texttt{kqueue} su Mac) e "parcheggia" il Virtual Thread, liberando immediatamente il Carrier.
    
    \textbf{Risultato:} Scrivi codice sincrono, semplice e leggibile, ma ottieni le performance del codice asincrono non bloccante.
\end{deepdive}

\subsection{Addio Thread Pools?}
Con i Virtual Threads, la gestione delle risorse cambia radicalmente.

\begin{interview}{Devo usare un Thread Pool per i Virtual Threads?}
    \textbf{Domanda:} "Ho migrato a Java 21. Come configuro il pool per i Virtual Threads?"
    
    \textbf{Risposta:} \textbf{Non lo fai.}
    Il pooling serve a razionare risorse costose. I Virtual Threads sono economici ("cheap").
    Non si riciclano i Virtual Threads; se ne crea uno nuovo per ogni task e lo si lascia morire alla fine.
    
    Invece di \texttt{newFixedThreadPool}, si usa il nuovo esecutore:
    \texttt{Executors.newVirtualThreadPerTaskExecutor()}.
\end{interview}

\begin{lstlisting}[language=Java, caption=Il server da 1 milione di thread]
// Esempio pratico: simuliamo 100.000 richieste concorrenti
// Con i Platform Threads, questo manderebbe in crash la JVM (OOM).

try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 100_000).forEach(i -> {
        executor.submit(() -> {
            // Simula operazione I/O (es. chiamata HTTP) di 1 sec
            Thread.sleep(1000); 
            return i;
        });
    });
} 
// Tempo totale esecuzione: ~1 secondo (perché corrono tutti insieme!)
\end{lstlisting}

\subsection{Quando NON usare i Virtual Threads}
I Virtual Threads non sono la panacea per tutto.

\begin{itemize}
    \item \textbf{I/O Bound (Database, Network):} \textbf{Perfetti.} Qui i Virtual Threads brillano perché passano il tempo ad aspettare, lasciando libero il Carrier.
    \item \textbf{CPU Bound (Calcoli intensivi, Rendering video, Hashing):} \textbf{Inutili (o dannosi).} Se un thread deve macinare numeri per 10 minuti senza mai fermarsi, occuperà il Carrier Thread per 10 minuti. Lo scheduling dei Virtual Threads non fa "preemption" temporale. Per task CPU intensive, i cari vecchi Platform Threads (o \texttt{ForkJoinPool}) sono ancora la scelta migliore.
\end{itemize}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Logging e Observability}

"I log sono la scatola nera del tuo aereo. Se l'applicazione si schianta, sono l'unica cosa che ti resta per capire perché."

Molti Junior usano \texttt{System.out.println()}. Un Senior sa che in produzione la console non esiste (o è un buco nero ingestibile).
In Java, il logging è maturo e strutturato secondo un pattern architetturale preciso: il \textbf{Facade Pattern}.

\section{L'Architettura: SLF4J e Logback}

In Spring Boot non parliamo quasi mai direttamente con la libreria di logging. Usiamo un'interfaccia.

\begin{center}
\begin{tikzpicture}[
    node distance=3cm, auto, thick,
    % Stili
    app/.style={rectangle, draw=deepblue, fill=white, text width=4cm, align=center, minimum height=1.5cm},
    facade/.style={rectangle, draw=intervieworange, fill=intervieworange!10, text width=3cm, align=center, minimum height=1.5cm, rounded corners},
    impl/.style={rectangle, draw=javagreen, fill=javagreen!10, text width=3cm, align=center, minimum height=1.5cm, rounded corners},
    arrow/.style={->, >=stealth, thick}
]

    \node[app] (code) {Tuo Codice\\(Controller/Service)};
    
    \node[facade, right=1.5cm of code] (slf4j) {\textbf{SLF4J}\\(Interfaccia)\\The Facade};
    
    \node[impl, right=1.5cm of slf4j] (logback) {\textbf{Logback}\\(Motore)\\Implementation};

    \draw[arrow] (code) -- node[above, font=\scriptsize] {chiama} (slf4j);
    \draw[arrow] (slf4j) -- node[above, font=\scriptsize] {delega} (logback);
    
    % Nota laterale
    \node[below=0.5cm of slf4j, font=\scriptsize, align=center] {Puoi scambiare il motore\\senza cambiare il codice!};

\end{tikzpicture}
\end{center}

\begin{itemize}
    \item \textbf{SLF4J (Simple Logging Facade for Java):} È l'interfaccia standard. Tu usi \texttt{Logger.info()}.
    \item \textbf{Logback:} È l'implementazione di default di Spring Boot. È il motore che scrive fisicamente su file o console.
    \item \textbf{Log4j2:} Un'altra implementazione potente (usata per alte performance async).
\end{itemize}

\section{I Livelli di Log (Hierarchy)}
Non tutti i messaggi sono uguali. Configurare i livelli correttamente salva lo spazio su disco e la sanità mentale.

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|c|X|c|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Livello}} & \textcolor{white}{\textbf{Significato}} & \textcolor{white}{\textbf{Ambiente}} \\
    \hline
    \textbf{ERROR} & Qualcosa si è rotto e l'operazione è fallita. Richiede intervento. & PROD \\
    \hline
    \textbf{WARN} & Qualcosa non va (es. disco quasi pieno, retry connessione), ma l'app funziona ancora. & PROD \\
    \hline
    \textbf{INFO} & Eventi di business significativi (es. "Utente X creato", "Ordine Y pagato"). & PROD \\
    \hline
    \textbf{DEBUG} & Dettagli tecnici per sviluppatori (es. "Query SQL eseguita", "Parametri input"). & DEV/TEST \\
    \hline
    \textbf{TRACE} & Dettaglio atomico (es. inizio/fine metodo, valori variabili intermedie). Verbosissimo. & DEV \\
    \hline
\end{tabularx}
\end{center}

\section{Anatomia di un Logger: Gerarchia e Istanziazione}

Quando scrivi la classica riga di inizializzazione del logger, stai definendo la posizione della tua classe all'interno di una struttura ad albero.

\begin{lstlisting}[language=Java]
public class PaymentService {
    // Perché static? Perché final?
    private static final Logger log = LoggerFactory.getLogger(PaymentService.class);
}
\end{lstlisting}

Analizziamo questa riga parola per parola:
\begin{itemize}
    \item \textbf{private:} Il logger serve solo a questa classe.
    \item \textbf{static:} Esiste una sola istanza del logger per \textit{tutti} gli oggetti \texttt{PaymentService}. Risparmia memoria (non ricrei il logger per ogni transazione).
    \item \textbf{final:} Il riferimento non cambia mai.
    \item \textbf{getLogger(PaymentService.class):} Qui avviene la magia. Stai dicendo alla Factory: \textit{"Dammi il logger associato al namespace \texttt{com.azienda.app.service.PaymentService}"}.
\end{itemize}

\subsection{La Gerarchia ad Albero (Logger Tree)}
I logger non sono entità isolate. Sono organizzati gerarchicamente in base al package java (il nome della classe).
Esiste un logger speciale, chiamato \textbf{ROOT}, che è il padre di tutti.

\begin{center}
\begin{tikzpicture}[
    level distance=2cm,
    level 1/.style={sibling distance=7cm},
    level 2/.style={sibling distance=3.5cm},
    every node/.style={
        rectangle, 
        draw=deepblue, 
        thick,
        fill=white, 
        rounded corners, 
        align=center, 
        font=\ttfamily\scriptsize,
        inner sep=5pt
    },
    edge from parent/.style={draw, -latex, thick, deepblue}
]

% Nodo Radice
\node[fill=intervieworange!10, font=\bfseries\small] {ROOT Logger\\(Level: INFO)}
    % Ramo Sinistro (Librerie Esterne)
    child { 
        node {org.springframework\\(Level: WARN)}
        child { node {web} }
        child { node {security} }
    }
    % Ramo Destro (Tuo Codice)
    child { 
        node {com.myapp\\(Level: DEBUG)}
        child { 
            node {service}
            child { node[fill=javagreen!10] {PaymentService} }
        }
        child { 
            node {controller} 
        }
    };

\end{tikzpicture}
\end{center}

\subsection{Ereditarietà della Configurazione}
Questa struttura ad albero spiega come funziona il file \texttt{application.properties}.
Quando configuri un livello di log, questo si propaga a cascata ("bubbling down") a tutti i figli, a meno che un figlio non lo sovrascriva.

\begin{lstlisting}[language=Java, title={application.properties}]
# 1. Configurazione Globale (ROOT)
logging.level.root=INFO

# 2. Configurazione Specifica (Sovrascrittura)
# Voglio vedere tutto quello che succede nel mio codice...
logging.level.com.myapp=DEBUG

# 3. ...ma le librerie di Spring devono stare zitte (solo errori gravi)
logging.level.org.springframework=WARN
\end{lstlisting}

\begin{deepdive}{Lombok @Slf4j: Cosa genera?}
Quando usi l'annotazione \texttt{@Slf4j}, Lombok genera esattamente la riga statica che abbiamo visto sopra, usando il nome della classe in cui ti trovi.
\begin{lstlisting}[language=Java]
// Lombok genera questo a compile time:
private static final org.slf4j.Logger log = 
    org.slf4j.LoggerFactory.getLogger(NomeDellaTuaClasse.class);
\end{lstlisting}
Inoltre, se rinomini la classe (Refactoring), Lombok aggiorna automaticamente il logger, mentre se lo scrivi a mano spesso ti dimentichi di cambiare il \texttt{.class} nel \texttt{getLogger}, creando confusione nei log.
\end{deepdive}

\section{Come scrivere i Log: Performance e Placeholder}

\subsection{L'errore della Concatenazione}
\begin{lstlisting}[language=Java]
// BAD: String Concatenation
// Anche se il livello è impostato a ERROR, Java DEVE comunque
// concatenare queste stringhe (costoso) PRIMA di entrare nel metodo debug.
log.debug("L'utente " + user.getName() + " ha fatto login da " + ip);
\end{lstlisting}

\subsection{La Soluzione: I Placeholder \{\}}
SLF4J supporta i placeholder. La concatenazione avviene \textbf{solo se} il livello di log è abilitato.

\begin{lstlisting}[language=Java]
// GOOD: Placeholder
// Se il livello è INFO, questa riga costa quasi zero.
log.debug("L'utente {} ha fatto login da {}", user.getName(), ip);
\end{lstlisting}

\begin{deepdive}{Lombok @Slf4j}
Non istanziare mai il logger a mano in ogni classe. Usa Lombok.
\begin{lstlisting}[language=Java]
@Service
@Slf4j // Genera: private static final Logger log = LoggerFactory.getLogger(...)
public class UserService {
    public void doSomething() {
        log.info("Sto facendo qualcosa...");
    }
}
\end{lstlisting}
\end{deepdive}

\section{Appenders: Dove vanno i log?}
Logback usa il concetto di \textbf{Appender} per decidere la destinazione. Un Logger può avere più Appender contemporaneamente.

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    src/.style={circle, draw=deepblue, fill=white, text width=4cm, align=center},
    appender/.style={rectangle, draw=black, fill=gray!10, text width=4cm, align=center, rounded corners},
    arrow/.style={->, >=stealth, thick}
]

    \node[src] (logger) {Root\\Logger};
    
    \node[appender, right=2cm of logger, yshift=1.5cm] (console) {\textbf{ConsoleAppender}\\(Standard Output)};
    \node[appender, right=2cm of logger, yshift=0cm] (file) {\textbf{RollingFile}\\(File su disco)};
    \node[appender, right=2cm of logger, yshift=-1.5cm] (elk) {\textbf{Logstash/TCP}\\(ELK Stack)};

    \draw[arrow] (logger) -- (console);
    \draw[arrow] (logger) -- (file);
    \draw[arrow] (logger) -- (elk);

\end{tikzpicture}
\end{center}

\subsection{Rolling Policy (Rotazione)}
Non scrivere mai su un file unico infinito (\texttt{app.log}). Usa una \textbf{RollingPolicy}.
\begin{itemize}
    \item \textbf{TimeBased:} Crea un file nuovo ogni giorno (\texttt{app-2023-10-01.log}).
    \item \textbf{SizeBased:} Crea un file nuovo ogni 10MB.
\end{itemize}

\section{MDC: Tracciare le richieste nel caos}
In un'app web multithread, i log di 10 utenti si mischiano.
Come fai a filtrare solo i log relativi alla richiesta dell'utente Mario?

L'\textbf{MDC (Mapped Diagnostic Context)} è una mappa Thread-Local (simile a una \texttt{Map<String, String>}) che "viaggia" insieme al thread corrente.

\begin{lstlisting}[language=Java, title={Uso di MDC in un Interceptor}]
// All'inizio della richiesta (es. in un Filter)
MDC.put("userId", "user-123");
MDC.put("transactionId", UUID.randomUUID().toString());

// ... nel Service (senza passare parametri!) ...
log.info("Pagamento avviato"); 
// Output automatico: 
// [INFO] [userId:user-123] [tx:abc-999] Pagamento avviato

// Alla fine (nel finally)
MDC.clear(); // Fondamentale pulire il thread!
\end{lstlisting}

\section{Best Practices di Sicurezza}

\begin{interview}{Cosa NON loggare mai?}
\textbf{Domanda:} Quali dati sono vietati nei log (GDPR/Security)?

\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Password:} Mai, nemmeno hashate.
    \item \textbf{Dati Carte di Credito (PAN):} Assolutamente vietato (PCI-DSS).
    \item \textbf{Token di Sessione/JWT:} Se li logghi, chi legge i log può rubare l'identità.
    \item \textbf{Dati PII (Personally Identifiable Information):} Codici fiscali, indirizzi, se non strettamente necessario e protetto.
\end{itemize}
\end{interview}


\part{Ingegneria del Software e Design}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Principi SOLID e Clean Code}

I principi SOLID (acronimo introdotto da Robert C. Martin, "Uncle Bob") non sono regole rigide, ma linee guida diagnostiche per gestire il "debito tecnico". Un codice che viola i SOLID tende a diventare rigido (difficile da cambiare) e fragile (si rompe in punti inaspettati).

\section{S - Single Responsibility Principle (SRP)}

\begin{interview}{Definizione Reale di SRP}
Molti dicono: "Una classe deve fare una sola cosa". È vago.
La definizione corretta è: \textbf{"Una classe deve avere una sola ragione per cambiare"}.
Se devi modificare la stessa classe sia perché è cambiato il database, sia perché è cambiata la formula di calcolo delle tasse, stai violando l'SRP.
\end{interview}

\textbf{Violazione (Bad Design):}
\begin{lstlisting}
public class Fattura {
    public float calcolaTotale() { ... } // Logica di Business
    public void stampaPDF() { ... }      // Logica di Presentazione
    public void salvaSuDB() { ... }      // Logica di Persistenza
}
\end{lstlisting}
Questa classe è un "God Object". Se cambia la libreria PDF, tocchi la classe. Se cambia SQL in Mongo, tocchi la stessa classe.

\textbf{Soluzione (Refactoring):}
Separare le responsabilità in classi dedicate: \texttt{FatturaCalculator}, \texttt{FatturaPrinter}, \texttt{FatturaRepository}.

\section{O - Open/Closed Principle (OCP)}

"Le entità software devono essere \textbf{aperte all'estensione}, ma \textbf{chiuse alla modifica}".
Dovresti poter aggiungere nuove funzionalità senza toccare il codice sorgente esistente (e già testato).

\textbf{Violazione (Bad Design):}
Usare \texttt{switch} o catene di \texttt{if-else} per determinare il comportamento.
\begin{lstlisting}
public double calcolaSconto(String tipoUtente) {
    if (tipoUtente.equals("Standard")) return 0.10;
    else if (tipoUtente.equals("VIP")) return 0.20;
    // Se aggiungo "SuperVIP", devo modificare questo file!
    return 0;
}
\end{lstlisting}

\textbf{Soluzione (Refactoring):}
Usare il Polimorfismo (Interfacce).
\begin{lstlisting}
interface ScontoStrategy { double applica(); }

class ScontoVIP implements ScontoStrategy { ... }
class ScontoStandard implements ScontoStrategy { ... }

// Il codice che usa la strategia non cambia se ne aggiungi una nuova
public double calcola(ScontoStrategy strategia) {
    return strategia.applica();
}
\end{lstlisting}

\section{L - Liskov Substitution Principle (LSP)}

"Gli oggetti di una superclasse devono poter essere sostituiti con oggetti delle sottoclassi senza rompere l'applicazione".

In pratica: Una sottoclasse non deve mai restringere il comportamento del padre o lanciare eccezioni impreviste per metodi che il padre supporta.

\begin{deepdive}{Il classico esempio del Quadrato/Rettangolo}
Matematicamente un Quadrato è un Rettangolo. In OOP, questa eredità è spesso sbagliata.
Se hai un metodo \texttt{resize(Rettangolo r)} che raddoppia la larghezza, e gli passi un \texttt{Quadrato}, potresti rompere la logica perché il Quadrato forza altezza = larghezza.
\textbf{Sintomo di violazione:} Se nel codice devi fare \texttt{if (obj instanceof Sottoclasse)}, probabilmente stai violando LSP.
\end{deepdive}

\section{I - Interface Segregation Principle (ISP)}

"I client non devono essere forzati a dipendere da interfacce che non usano".
Meglio avere tante interfacce piccole e specifiche (\textit{Role Interfaces}) piuttosto che un'unica interfaccia gigante (\textit{Header Interface}).

\textbf{Violazione:}
\begin{lstlisting}
interface Worker {
    void lavora();
    void mangia();
}

class Robot implements Worker {
    public void lavora() { ... }
    public void mangia() { 
        // I robot non mangiano! Violazione.
        throw new UnsupportedOperationException(); 
    }
}
\end{lstlisting}

\textbf{Soluzione:} Dividere in \texttt{Workable} e \texttt{Eatable}. Il Robot implementa solo \texttt{Workable}.

\section{D - Dependency Inversion Principle (DIP)}

Questo è il principio che abilita framework come Spring.
\begin{enumerate}
    \item I moduli di alto livello (Business Logic) non devono dipendere da moduli di basso livello (Dettagli tecnici, es. MySQL, FileSystem). Entrambi devono dipendere da \textbf{Astrazioni} (Interfacce).
    \item Le astrazioni non devono dipendere dai dettagli. I dettagli devono dipendere dalle astrazioni.
\end{enumerate}

\textbf{Violazione (Tight Coupling):}
\begin{lstlisting}
class ServizioVendite {
    // Dipendenza diretta dalla classe concreta MySQL
    private MySQLDatabase db = new MySQLDatabase(); 
    
    void vendi() { db.save(); }
}
\end{lstlisting}

\textbf{Soluzione (Dependency Injection):}
\begin{lstlisting}
class ServizioVendite {
    private Database db; // Dipende dall'interfaccia (Astrazione)

    // Qualcuno da fuori iniettera' l'implementazione concreta
    public ServizioVendite(Database db) {
        this.db = db;
    }
}
\end{lstlisting}

\section{Bonus: DRY, KISS e YAGNI}

\begin{itemize}
    \item \textbf{DRY (Don't Repeat Yourself):} Ogni pezzo di conoscenza/logica deve avere una rappresentazione unica. Se copi-incolli codice, stai creando debito tecnico.
    \item \textbf{KISS (Keep It Simple, Stupid):} La soluzione più semplice è quasi sempre la migliore. Evita l'over-engineering.
    \item \textbf{YAGNI (You Ain't Gonna Need It):} Non scrivere codice per funzionalità che "potrebbero servire in futuro". Scrivi solo ciò che serve oggi. (Principio cardine dell'Extreme Programming).
\end{itemize}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Il Pattern Singleton (Creational)}

Iniziamo dal pattern più famoso, più utilizzato e paradossalmente più frainteso dell'ingegneria del software.
Il \textbf{Singleton} ha uno scopo semplice: garantire che una classe abbia \textbf{una e una sola istanza} e fornire un punto di accesso globale ad essa.

Nel mondo moderno, l'abuso del Singleton è considerato un anti-pattern, ma capirlo è fondamentale per comprendere come funzionano i framework come Spring.

\section{Il Problema}
In molte applicazioni, ci sono componenti che devono essere unici per natura:
\begin{itemize}
    \item Un \textbf{Connection Pool} verso il Database (non vuoi aprirne 50 diversi).
    \item Un \textbf{Configuration Manager} che legge le proprietà all'avvio.
    \item Un \textbf{Logger} che scrive su un file condiviso.
\end{itemize}
Se istanziassimo questi oggetti ogni volta (\texttt{new Database()}), avremmo spreco di memoria, corruzione dei dati o errori di connessione.

\section{Implementazione "Senior": Thread Safety}
Un Junior implementa il Singleton in modo "Lazy" (crealo solo se serve), ma dimentica che le applicazioni web sono \textbf{Multi-Thread}.

\begin{lstlisting}[language=Java, title={Approccio Naive (Non Thread-Safe)}]
public class DatabaseConnection {
    private static DatabaseConnection instance;

    // 1. Costruttore privato: Nessuno può fare 'new' da fuori
    private DatabaseConnection() {}

    public static DatabaseConnection getInstance() {
        if (instance == null) {
            // RACE CONDITION:
            // Se due thread arrivano qui contemporaneamente,
            // entrambi creano una nuova istanza!
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
\end{lstlisting}

\subsection{La Soluzione: Double-Checked Locking}
Per renderlo sicuro, potremmo mettere \texttt{synchronized} sul metodo, ma rallenteremmo tutte le letture future.
L'approccio professionale è il \textbf{Double-Checked Locking} con la keyword \texttt{volatile}.

\begin{lstlisting}[language=Java, title={Thread-Safe Performance Singleton}]
public class DatabaseConnection {
    
    // 'volatile' garantisce che le modifiche siano visibili
    // immediatamente a tutti i thread (niente cache CPU locale)
    private static volatile DatabaseConnection instance;

    private DatabaseConnection() {}

    public static DatabaseConnection getInstance() {
        // Primo check (senza lock, veloce)
        if (instance == null) {
            
            // Acquisisco il lock solo se necessario
            synchronized (DatabaseConnection.class) {
                
                // Secondo check (dentro il lock)
                // Necessario perché un altro thread potrebbe aver creato
                // l'istanza mentre eravamo in attesa del lock.
                if (instance == null) {
                    instance = new DatabaseConnection();
                }
            }
        }
        return instance;
    }
}
\end{lstlisting}

\section{La Soluzione "Effective Java" (Enum)}
Joshua Bloch (autore di Java Core) suggerisce che il modo migliore per implementare un Singleton in Java è usare un \textbf{Enum}.

\begin{lstlisting}[language=Java]
public enum ConfigurationManager {
    INSTANCE; // L'unica istanza possibile

    private Properties props;

    // Costruttore (eseguito una volta sola dalla JVM)
    ConfigurationManager() {
        props = new Properties();
        // load from file...
    }

    public String getProperty(String key) {
        return props.getProperty(key);
    }
}

// Utilizzo
String dbUrl = ConfigurationManager.INSTANCE.getProperty("db.url");
\end{lstlisting}

\begin{deepdive}{Perché l'Enum è superiore?}
L'approccio Enum risolve gratis due problemi complessi:
\begin{enumerate}
    \item \textbf{Reflection Attack:} Con il Singleton classico, un hacker potrebbe usare \texttt{setAccessible(true)} sul costruttore privato e creare una seconda istanza. Con gli Enum, la JVM impedisce la creazione manuale.
    \item \textbf{Serialization:} Se serializzi e deserializzi un Singleton classico, ottieni una nuova istanza (copia). Con gli Enum, Java garantisce che rimanga la stessa istanza.
\end{enumerate}
\end{deepdive}

\section{Spring Singleton vs GoF Singleton}
Questa è la domanda che separa chi conosce i Pattern da chi conosce Spring.

\begin{interview}{Spring Bean Singleton}
\textbf{Domanda:} I Bean di Spring sono Singleton di default. Sono la stessa cosa del Singleton Pattern?

\textbf{Risposta:} \textbf{No, concettualmente è diverso.}
\begin{itemize}
    \item \textbf{GoF Singleton (Design Pattern):} Garantisce una istanza per \textbf{ClassLoader} (in pratica, una per JVM). È hardcoded nella classe (static).
    \item \textbf{Spring Singleton (Scope):} Garantisce una istanza per \textbf{Container (ApplicationContext)}.
\end{itemize}
\textbf{Conseguenza:} Se avvio due ApplicationContext nella stessa JVM, avrò due istanze del Bean "Singleton". In Spring, il Singleton è una regola di gestione del ciclo di vita, non una caratteristica strutturale della classe.
\end{interview}

\section{Perché è considerato un Anti-Pattern?}
Oggi si tende a evitare il Singleton manuale (quello statico).

\subsection{Il problema del Testing}
Il Singleton introduce uno stato globale nascosto e un accoppiamento forte.

\begin{lstlisting}[language=Java]
public class UserService {
    public void register(User u) {
        // Accoppiamento forte! Non posso sostituirlo con un Mock.
        // Se DatabaseConnection prova a connettersi al DB vero,
        // il mio Unit Test fallisce senza rete.
        DatabaseConnection.getInstance().save(u);
    }
}
\end{lstlisting}

\textbf{Soluzione:} Usare la \textbf{Dependency Injection} (Spring).
Invece di chiamare \texttt{getInstance()}, chiedi l'istanza nel costruttore. Spring ti passerà l'unica istanza (Singleton Scope), ma nei test potrai passare un Mock.

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Concetto}} & \textcolor{white}{\textbf{Best Practice}} \\
    \hline
    Implementazione Manuale & Usa \textbf{Enum} se possibile, o \textbf{Double-Checked Locking} con \texttt{volatile}. \\
    \hline
    Uso moderno & Evita i Singleton statici. Usa la \textbf{Dependency Injection} di Spring con scope \texttt{@Scope("singleton")}. \\
    \hline
    Visibilità & Il costruttore deve essere sempre \textbf{private}. \\
    \hline
    Testing & I Singleton statici rendono il mocking quasi impossibile. Preferire sempre l'iniezione. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Il Pattern Builder (Creational)}

Hai mai visto un costruttore con 10 parametri, di cui 7 sono \texttt{null}?
Questo è il segnale inequivocabile che ti serve il \textbf{Builder Pattern}.

Il Builder separa la costruzione di un oggetto complesso dalla sua rappresentazione, permettendo di creare lo stesso oggetto passo dopo passo. In Java, è diventato lo standard de-facto per la creazione di DTO, Configurazioni e Entità immutabili.

\section{Il Problema: Telescoping Constructors}
Immagina di dover istanziare una classe \texttt{Pizza}.

\begin{lstlisting}[language=Java, title={L'Anti-Pattern}]
public class Pizza {
    public Pizza(int size) { ... }
    public Pizza(int size, boolean cheese) { ... }
    public Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    public Pizza(int size, boolean cheese, boolean pepperoni, boolean bacon) { ... }
}

// Utilizzo: Cosa significano questi boolean? È facile scambiarli!
Pizza p = new Pizza(12, true, false, true); 
\end{lstlisting}

Questo codice è fragile. Se aggiungi un ingrediente, devi rifare i costruttori. Se scambi il secondo \texttt{true} col terzo, il compilatore non ti avvisa, ma la pizza è sbagliata.

\section{L'Implementazione Classica (Effective Java)}
Prima di Lombok, il Builder si scriveva a mano usando una \textbf{Static Inner Class}. È importante saperlo scrivere ai colloqui per dimostrare di capire cosa succede "sotto il cofano".

\begin{lstlisting}[language=Java, title={Builder Manuale}]
public class User {
    // 1. Campi final (Immutabilità)
    private final String firstName; // Required
    private final String lastName;  // Required
    private final int age;          // Optional
    private final String email;     // Optional

    // 2. Costruttore Privato: accetta solo il Builder
    private User(UserBuilder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
        this.email = builder.email;
    }

    // 3. Static Inner Class
    public static class UserBuilder {
        private final String firstName;
        private final String lastName;
        private int age = 0; // Default
        private String email = null;

        public UserBuilder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        // 4. Fluent Interface (Ritorna 'this')
        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder email(String email) {
            this.email = email;
            return this;
        }

        // 5. Metodo finale di build
        public User build() {
            // Qui puoi fare validazioni complesse prima di creare l'oggetto
            if (age < 0) throw new IllegalStateException("Age cannot be negative");
            return new User(this);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java, title={Utilizzo Fluente}]
User u = new User.UserBuilder("Mario", "Rossi")
    .age(30)
    .email("mario@test.com")
    .build();
\end{lstlisting}

\section{L'Era Moderna: Lombok @Builder}
Scrivere tutto quel codice boilerplate è noioso. Nelle aziende moderne si usa \textbf{Project Lombok}.

\begin{lstlisting}[language=Java]
@Builder
@Getter
@ToString
public class UserDTO {
    private String name;
    private String surname;
    
    @Builder.Default // Importante! Altrimenti il builder ignora il valore
    private boolean active = true; 
}
\end{lstlisting}

L'annotazione \texttt{@Builder} genera automaticamente la classe statica interna, i metodi setter fluenti e il metodo build.

\begin{deepdive}{Il Potere di toBuilder = true}
Se hai un oggetto immutabile e vuoi crearne una copia modificando solo un campo, Lombok offre una feature potente:
\texttt{@Builder(toBuilder = true)}.

\begin{lstlisting}[language=Java]
UserDTO user = ...; // Oggetto esistente
// Crea una copia identica ma cambia solo l'email
UserDTO updated = user.toBuilder()
    .email("new@email.com")
    .build();
\end{lstlisting}
Questo è fondamentale nella programmazione funzionale e reattiva dove gli oggetti non si modificano mai.
\end{deepdive}

\section{Builder vs JavaBeans (Setters)}
Perché non usare semplicemente un costruttore vuoto e poi chiamare \texttt{setAge(10)}, \texttt{setEmail(...)}?

\begin{interview}{Immutabilità e Thread Safety}
\textbf{Domanda:} Qual è il vantaggio principale del Builder rispetto ai Setter?

\textbf{Risposta:} L'\textbf{Immutabilità}.
\begin{itemize}
    \item Con i \textbf{Setter (JavaBeans)}, l'oggetto può trovarsi in uno stato inconsistente (es. hai settato il nome ma non ancora il cognome). Inoltre, l'oggetto è mutabile, quindi non Thread-Safe.
    \item Con il \textbf{Builder}, l'oggetto viene restituito dal metodo \texttt{build()} solo quando è completo. L'oggetto risultante può non avere setter (tutti i campi \texttt{final}), rendendolo intrinsecamente Thread-Safe e sicuro da passare tra i layer.
\end{itemize}
\end{interview}

\section{Real World Examples in Spring}
Non usi il Builder solo per le tue classi. Spring è pieno di Builder.

\subsection{1. UriComponentsBuilder (Costruzione URL)}
Invece di concatenare stringhe per creare URL (rischiando errori di encoding), Spring offre questo builder.

\begin{lstlisting}[language=Java]
String url = UriComponentsBuilder.fromHttpUrl("https://api.google.com")
    .path("/search")
    .queryParam("q", "Spring Boot")
    .queryParam("lang", "it")
    .build()
    .toUriString();
// Risultato: https://api.google.com/search?q=Spring\%20Boot&lang=it
\end{lstlisting}

\subsection{2. ResponseEntity (Rest Controller)}
Quando rispondi da un Controller, usi un Builder fluente.

\begin{lstlisting}[language=Java]
return ResponseEntity
    .status(HttpStatus.CREATED)
    .header("X-Custom-Header", "Value")
    .body(myDto);
\end{lstlisting}

\subsection{3. Spring Security (HttpSecurity)}
La configurazione della sicurezza è una catena di builder infinita.

\begin{lstlisting}[language=Java]
http
    .authorizeRequests()
        .antMatchers("/public").permitAll()
        .anyRequest().authenticated()
    .and() // Torna al builder padre
    .formLogin();
\end{lstlisting}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Caratteristica}} & \textcolor{white}{\textbf{Builder Pattern}} \\
    \hline
    \textbf{Quando usarlo} & Quando un oggetto ha più di 3-4 parametri, specialmente se opzionali. \\
    \hline
    \textbf{Vantaggio Key} & Codice leggibile (sai cosa stai settando) e possibilità di creare oggetti immutabili. \\
    \hline
    \textbf{Best Practice} & Usa \textbf{Lombok} \texttt{@Builder} per DTO ed Entity. Usa \texttt{@Builder.Default} per valori di default. \\
    \hline
    \textbf{Attenzione} & Non abusarne per oggetti semplici con 2 campi. Lì il costruttore \texttt{AllArgs} è più veloce. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Il Pattern Factory Method (Creational)}

"New is Glue".
Ogni volta che usi la keyword \texttt{new} nel tuo codice di business, stai incollando (accoppiando) la tua classe a un'implementazione specifica.

Il \textbf{Factory Method} serve a delegare la creazione degli oggetti a un componente specializzato, nascondendo la logica di istanziazione al client. In Java Moderno e Spring, questo pattern è ovunque, spesso mascherato da metodi statici.

\section{Il Problema: Accoppiamento Rigido}
Immagina un sistema di reportistica.

\begin{lstlisting}[language=Java, title={Approccio Senza Factory (Bad)}]
public class ReportService {
    public void generateReport(String type) {
        Report report;
        if (type.equals("PDF")) {
            report = new PdfReport(); // Accoppiamento forte!
        } else if (type.equals("CSV")) {
            report = new CsvReport(); // Accoppiamento forte!
        }
        report.render();
    }
}
\end{lstlisting}

Se domani aggiungi "Excel", devi modificare il \texttt{ReportService}. Questo viola l'\textbf{Open/Closed Principle} (aperto all'estensione, chiuso alla modifica).

\section{L'Implementazione Classica (Polimorfismo)}
La definizione GoF (Gang of Four) prevede di usare l'ereditarietà: una classe astratta definisce il metodo \texttt{create()}, e le sottoclassi decidono cosa istanziare.

Tuttavia, nel Java moderno, si preferisce spesso la variante \textbf{Simple Factory} o \textbf{Static Factory Method}.

\begin{lstlisting}[language=Java, title={Simple Static Factory}]
public class ReportFactory {
    
    // Metodo statico: il client non deve istanziare la Factory
    public static Report create(String type) {
        return switch (type) {
            case "PDF" -> new PdfReport();
            case "CSV" -> new CsvReport();
            default -> throw new IllegalArgumentException("Unknown type");
        };
    }
}

// Utilizzo nel Service
Report report = ReportFactory.create("PDF");
\end{lstlisting}

\section{Modern Java: Static Factory Methods}
Questa è la declinazione più importante per un Senior Developer.
Da Java 8 in poi, i costruttori sono considerati "limitati". Si preferiscono metodi statici con nomi parlanti.

\begin{interview}{Costruttore vs Static Factory Method}
\textbf{Domanda:} Perché dovrei usare \texttt{User.of(...)} invece di \texttt{new User(...)}?

\textbf{Risposta:} I metodi statici hanno 3 vantaggi enormi:
\begin{enumerate}
    \item \textbf{Hanno un nome:} Il costruttore si chiama sempre come la classe. Un metodo statico può chiamarsi \texttt{fromEmail()}, \texttt{fromId()}, \texttt{createGuest()}. È documentazione viva.
    \item \textbf{Non devono per forza creare un nuovo oggetto:} Possono restituire un'istanza cachata (Singleton) o una costante (es. \texttt{Optional.empty()}).
    \item \textbf{Possono restituire un sottotipo:} Un metodo che dichiara di ritornare \texttt{List} può restituire una \texttt{ArrayList} o una \texttt{LinkedList} o una \texttt{ImmutableCollections\$ListN} senza che il client lo sappia.
\end{enumerate}
\end{interview}

\begin{lstlisting}[language=Java, title={Esempi nel JDK}]
// 1. List.of (Ritorna una lista immutabile ottimizzata)
List<String> list = List.of("A", "B"); 

// 2. Integer.valueOf (Usa la cache per numeri piccoli)
Integer i = Integer.valueOf(10); 

// 3. Optional.ofNullable (Gestione null)
Optional<String> opt = Optional.ofNullable(maybeNullString);
\end{lstlisting}

\section{Spring Framework: La Fabbrica Gigante}
Spring è, essenzialmente, un contenitore IoC che agisce come una Factory.
L'interfaccia radice di Spring non a caso si chiama \textbf{\texttt{BeanFactory}}.

Quando usi \texttt{@Autowired}, Spring sta facendo il lavoro della Factory per te: decide quale istanza creare (o recuperare se Singleton) e te la inietta.

\subsection{Pattern Avanzato: FactoryBean}
A volte la creazione di un oggetto è così complessa che non basta l'XML o l'annotazione \texttt{@Bean}. Spring offre l'interfaccia \texttt{FactoryBean<T>}.

\begin{deepdive}{FactoryBean in azione}
Hai mai usato JPA?
Quando configuri Spring Data, definisci un \texttt{LocalContainerEntityManagerFactoryBean}.
Questo \textbf{non} è l'EntityManager. È una Factory che costruisce l'EntityManager (leggendo il \texttt{persistence.xml}, configurando il DataSource, scansionando le entità, etc.).
Spring vede che la classe implementa \texttt{FactoryBean}, quindi quando chiedi di iniettare l'EntityManager, chiama automaticamente \texttt{getObject()} sulla factory.
\end{deepdive}

\section{Esempio Architetturale: Factory + Strategy}
Un pattern molto potente in Spring è combinare Factory e Strategy per eliminare gli \texttt{if} dai Service.

\begin{lstlisting}[language=Java, title={Service Locator Pattern (Spring Style)}]
@Service
public class PaymentFactory {
    
    // Spring inietta automaticamente tutti i Bean che implementano
    // l'interfaccia PaymentService in una Mappa!
    // Key = nome del bean ("paypalService"), Value = istanza
    @Autowired
    private Map<String, PaymentService> services;

    public PaymentService getService(String type) {
        PaymentService service = services.get(type + "Service");
        if (service == null) throw new IllegalArgumentException("No provider found");
        return service;
    }
}
\end{lstlisting}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Concetto}} & \textcolor{white}{\textbf{Best Practice}} \\
    \hline
    \textbf{Codice Client} & Non usare \texttt{new} per logica complessa o polimorfica. Usa una Factory. \\
    \hline
    \textbf{Naming} & Usa convenzioni standard: \texttt{of()}, \texttt{from()}, \texttt{getInstance()}, \texttt{newInstance()}. \\
    \hline
    \textbf{JDK Usage} & Preferisci \texttt{List.of()} a \texttt{new ArrayList<>()} {{doppia graffa}}. \\
    \hline
    \textbf{Spring} & Sfrutta \texttt{BeanFactory} e l'iniezione di Mappe/Liste per creare Factory dinamiche senza switch-case. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Il Pattern Strategy (Behavioral)}

Se apri una classe Service e trovi uno \texttt{switch} o una catena di \texttt{if-else} che controlla il "tipo" di un'operazione per decidere cosa fare, sei di fronte a un problema di design.

Il \textbf{Strategy Pattern} definisce una famiglia di algoritmi, li incapsula e li rende intercambiabili.
In Spring, questo pattern diventa potentissimo perché il framework gestisce l'iniezione delle strategie automaticamente, eliminando quasi del tutto il codice di controllo.

\section{Il Problema: "If-Else Hell"}
Immagina un e-commerce che deve gestire pagamenti.

\begin{lstlisting}[language=Java, title={Approccio Procedurale (Bad)}]
@Service
public class CheckoutService {
    
    public void processPayment(String type, double amount) {
        if ("PAYPAL".equals(type)) {
            // Logica PayPal (50 righe)
            // Chiamate API esterne...
        } else if ("CREDIT_CARD".equals(type)) {
            // Logica Stripe (50 righe)
        } else if ("BITCOIN".equals(type)) {
            // Logica Crypto (50 righe)
        } else {
            throw new IllegalArgumentException("Metodo non supportato");
        }
    }
}
\end{lstlisting}

\textbf{Perché è male?}
\begin{enumerate}
    \item \textbf{Violazione OCP (Open/Closed Principle):} Se vuoi aggiungere "Apple Pay", devi modificare questa classe (rischiando di rompere gli altri pagamenti).
    \item \textbf{Testabilità:} Per testare questa classe devi mockare tutte le dipendenze di tutti i metodi di pagamento.
    \item \textbf{Complessità:} La classe diventa un "God Object" illeggibile.
\end{enumerate}

\section{Implementazione Classica (Interfaccia)}
Il primo passo è estrarre la logica in classi separate che implementano un'interfaccia comune.

\begin{lstlisting}[language=Java]
public interface PaymentStrategy {
    void pay(double amount);
    
    // Metodo utile per l'identificazione in Spring (vedi dopo)
    String getType();
}

public class PaypalStrategy implements PaymentStrategy {
    public void pay(double amount) { /* API PayPal */ }
    public String getType() { return "PAYPAL"; }
}

public class CreditCardStrategy implements PaymentStrategy {
    public void pay(double amount) { /* API Stripe */ }
    public String getType() { return "CREDIT_CARD"; }
}
\end{lstlisting}

\section{La "Magia" di Spring: Map Injection}
In Java puro, dovresti comunque avere uno switch da qualche parte per fare \texttt{new PaypalStrategy()}.
In Spring, possiamo usare l'IoC Container per eliminare anche quello.

Spring ha una feature killer: se chiedi di iniettare una \texttt{Map<String, Interfaccia>}, lui la popola automaticamente con tutti i Bean che implementano quell'interfaccia.

\begin{lstlisting}[language=Java, title={Strategy Pattern "Spring Way"}]
@Service
@RequiredArgsConstructor
public class PaymentFactory { // O Context

    // Key: Nome del Bean (es. "paypalStrategy")
    // Value: L'istanza del Service
    private final Map<String, PaymentStrategy> strategies;

    public void executePayment(String type, double amount) {
        // 1. Recupero la strategia dalla mappa
        // Assumiamo che i bean si chiamino "PAYPAL", "CREDIT_CARD" 
        // (oppure usiamo una logica di mapping)
        PaymentStrategy strategy = strategies.get(type);

        if (strategy == null) {
            throw new IllegalArgumentException("Metodo non supportato: " + type);
        }

        // 2. Eseguo (Polimorfismo)
        strategy.pay(amount);
    }
}
\end{lstlisting}

\begin{deepdive}{Come nominare i Bean?}
Per far funzionare la mappa con chiavi custom (es. "PAYPAL" invece di "paypalStrategy"), hai due vie:
\begin{enumerate}
    \item Annotare l'implementazione: \texttt{@Service("PAYPAL")}
    \item (Migliore) Usare un metodo \texttt{getType()} nell'interfaccia e convertire la \texttt{List<PaymentStrategy>} in una \texttt{Map} nel costruttore della Factory.
\end{enumerate}
\end{deepdive}

\section{Enum Strategy (Per logica semplice)}
Se le strategie non hanno dipendenze esterne (es. calcolo tasse, sconti), non serve creare classi e bean. Gli \textbf{Enum} in Java possono implementare interfacce e avere metodi astratti.

\begin{lstlisting}[language=Java, title={Strategy leggero con Enum}]
public enum DiscountStrategy {
    NONE {
        @Override double apply(double price) { return price; }
    },
    SUMMER_SALE {
        @Override double apply(double price) { return price * 0.90; }
    },
    BLACK_FRIDAY {
        @Override double apply(double price) { return price * 0.50; }
    };

    abstract double apply(double price);
}

// Utilizzo:
double finalPrice = DiscountStrategy.valueOf("BLACK_FRIDAY").apply(100.0);
\end{lstlisting}

\section{Interview Questions}

\begin{interview}{Strategy vs State Pattern}
\textbf{Domanda:} I diagrammi UML di Strategy e State sono quasi identici. Qual è la differenza?

\textbf{Risposta:} L'\textbf{Intento}.
\begin{itemize}
    \item \textbf{Strategy:} Il client \textit{sceglie} l'algoritmo specifico (es. "Voglio pagare con PayPal"). Le strategie solitamente non sanno l'una dell'altra.
    \item \textbf{State:} L'oggetto cambia comportamento internamente in base al suo stato (es. Ordine: "Creato" $\to$ "Spedito"). Spesso uno stato contiene la logica per passare allo stato successivo.
\end{itemize}
\end{interview}

\begin{interview}{Strategy e Bean Lifecycle}
\textbf{Domanda:} Le strategie in Spring sono Singleton?
\textbf{Risposta:} Sì, di default.
Questo significa che le classi \texttt{PaypalStrategy}, etc., devono essere \textbf{Stateless} (senza stato). Non salvare dati specifici della transazione (es. \texttt{amount}) come campi di istanza, ma passali sempre come argomenti del metodo \texttt{pay()}.
\end{interview}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Concetto}} & \textcolor{white}{\textbf{Best Practice}} \\
    \hline
    \textbf{Obiettivo} & Eliminare \texttt{if-else} complessi basati su "tipo". Rispetta OCP. \\
    \hline
    \textbf{Implementazione Spring} & Inietta \texttt{Map<String, Strategy>} o \texttt{List<Strategy>} per selezionare l'implementazione a runtime. \\
    \hline
    \textbf{Stateless} & Le strategie devono essere bean puri senza stato. I dati viaggiano nei parametri dei metodi. \\
    \hline
    \textbf{Alternative} & Per logica matematica semplice, usa \textbf{Enum} con metodi astratti. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Il Pattern Proxy (Structural)}

Se Spring e Hibernate fossero un film, il \textbf{Proxy} sarebbe l'attore protagonista.
È il meccanismo fondamentale che permette ai framework di aggiungere comportamenti (transazioni, sicurezza, lazy loading) al tuo codice senza che tu debba scriverli esplicitamente.

Il Proxy è un oggetto che agisce come un surrogato o segnaposto per un altro oggetto per controllarne l'accesso.

\section{Il Concetto: L'Intermediario}
Immagina di voler chiamare il metodo \texttt{save()} di un Repository.

\begin{itemize}
    \item \textbf{Senza Proxy:} Il tuo Controller chiama direttamente il Repository.
    \item \textbf{Con Proxy (Spring):} Il tuo Controller chiama un oggetto wrapper (il Proxy). Il Proxy apre la transazione, chiama il Repository vero, e poi chiude la transazione.
\end{itemize}

\begin{center}
\begin{tikzpicture}[node distance=4cm, auto, thick,
    block/.style={rectangle, draw=deepblue, fill=white, text width=2.5cm, align=center, minimum height=1.5cm},
    arrow/.style={->, >=stealth, thick}
]

    \node[block] (client) {Client\\(Controller)};
    \node[block, right of=client, xshift=1cm, fill=intervieworange!10] (proxy) {\textbf{Proxy}\\(Spring AOP)};
    \node[block, right of=proxy, xshift=1cm] (real) {Real Subject\\(Service)};

    \draw[arrow] (client) -- node[above, font=\scriptsize] {1. chiama()} (proxy);
    \draw[arrow] (proxy) -- node[above, font=\scriptsize] {2. Logica Extra} node[below=0.6, font=\scriptsize] {(Transazione)} (real);
    \draw[arrow, dashed] (real) -- node[below, font=\scriptsize] {3. return} (proxy);
    \draw[arrow, dashed] (proxy) -- (client);

\end{tikzpicture}
\end{center}

\section{JDK Dynamic Proxy vs CGLIB}
Ai colloqui tecnici avanzati, ti chiederanno: \textit{"Come fa Spring a creare questi Proxy a runtime?"}.
Esistono due tecnologie.

\subsection{1. JDK Dynamic Proxy (L'originale)}
Fa parte del cuore di Java (\texttt{java.lang.reflect.Proxy}).
\begin{itemize}
    \item \textbf{Requisito:} L'oggetto target DEVE implementare un'\textbf{Interfaccia}.
    \item \textbf{Funzionamento:} Il Proxy implementa la stessa interfaccia del target e delega le chiamate.
    \item \textbf{Limite:} Se la tua classe non ha interfacce, questo metodo fallisce.
\end{itemize}

\subsection{2. CGLIB (Code Generation Library)}
È una libreria di terze parti (inclusa in Spring Core).
\begin{itemize}
    \item \textbf{Funzionamento:} Genera al volo una \textbf{Sottoclasse} del tuo oggetto target e fa \textit{Override} dei metodi.
    \item \textbf{Vantaggio:} Funziona anche senza interfacce (per questo in Spring Boot possiamo autowirare le classi concrete).
    \item \textbf{Limite:} Non può proxare metodi o classi \texttt{final} (perché non si possono estendere/overridare).
\end{itemize}

\begin{deepdive}{Spring Boot Default}
Dalla versione 2.0, Spring Boot usa \textbf{CGLIB} di default per tutto, anche se hai delle interfacce. Questo per evitare comportamenti inconsistenti (es. casting exceptions se provi a castare il proxy alla classe concreta).
\end{deepdive}

\section{Spring AOP: Il Proxy in Azione}
Prendiamo l'annotazione \texttt{@Transactional}. È solo un metadato. Non fa nulla da sola.
È il \textbf{BeanPostProcessor} di Spring che, all'avvio, vede l'annotazione e decide di avvolgere il tuo Bean in un Proxy.

\begin{lstlisting}[language=Java, title={Cosa fa il Proxy (Codice simulato)}]
public class UserServiceProxy extends UserService { // CGLIB
    
    private UserService target; // Il vero service
    private TransactionManager txManager;

    @Override
    public void createUser(User u) {
        // 1. Pre-Processing (Aspect)
        Transaction tx = txManager.begin();
        
        try {
            // 2. Chiamata al metodo reale
            target.createUser(u);
            
            // 3. Post-Processing (Success)
            txManager.commit(tx);
        } catch (RuntimeException e) {
            // 4. Error Handling
            txManager.rollback(tx);
            throw e;
        }
    }
}
\end{lstlisting}

\section{La Trappola della Self-Invocation}
Questo è il problema numero uno causato dai Proxy.

\begin{interview}{Perché @Transactional viene ignorato?}
\textbf{Domanda:} Ho un metodo \texttt{a()} che chiama \texttt{b()} nella stessa classe. \texttt{b()} è annotato con \texttt{@Transactional}, ma la transazione non parte. Perché?

\begin{lstlisting}[language=Java]
public class MyService {
    public void a() {
        this.b(); // Chiamata interna
    }

    @Transactional
    public void b() { ... }
}
\end{lstlisting}

\textbf{Risposta:} Quando chiami \texttt{this.b()}, stai usando il riferimento \texttt{this}, che punta all'istanza \textbf{Reale}, non al Proxy.
Spring non può intercettare la chiamata. Il codice di apertura transazione non viene mai eseguito.
\textbf{Soluzione:}
\begin{enumerate}
    \item Spostare \texttt{b()} in un altro Service (e iniettarlo).
    \item (Brutta) Iniettare il Service dentro se stesso (\texttt{@Lazy @Autowired MyService self}) e chiamare \texttt{self.b()}.
\end{enumerate}
\end{interview}

\section{Hibernate: Il Lazy Loading Proxy}
Anche Hibernate usa i Proxy, ma per un motivo diverso: le performance.

Quando carichi un oggetto che ha una relazione \texttt{LAZY} (es. \texttt{user.getDepartment()}), Hibernate non fa la query per il dipartimento.
Al suo posto, mette nel campo \texttt{department} un Proxy CGLIB/Javassist.

\begin{itemize}
    \item Questo Proxy ha solo l'ID popolato. Tutti gli altri campi sono null.
    \item Appena chiami un metodo (es. \texttt{dept.getName()}), il Proxy si "sveglia", apre una connessione al DB, esegue la query e si riempie i dati (\textit{Initialization}).
\end{itemize}

\begin{deepdive}{LazyInitializationException spiegata col Proxy}
Se provi a chiamare \texttt{dept.getName()} quando la Sessione Hibernate è chiusa:
\begin{enumerate}
    \item Il Proxy intercetta la chiamata.
    \item Cerca di chiedere alla Sessione di eseguire l'SQL.
    \item Trova la Sessione chiusa.
    \item Lancia l'eccezione.
\end{enumerate}
L'eccezione non viene lanciata dal tuo oggetto, ma dal codice generato dentro il Proxy.
\end{deepdive}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Concetto}} & \textcolor{white}{\textbf{Dettaglio}} \\
    \hline
    \textbf{Scopo} & Controllare l'accesso a un oggetto (Lazy Load) o aggiungere comportamenti (AOP). \\
    \hline
    \textbf{Spring} & Usa Proxy per \texttt{@Transactional}, \texttt{@Async}, \texttt{@Cacheable}, Security. \\
    \hline
    \textbf{Limitazione Key} & \textbf{Self-Invocation:} Le chiamate interne (\texttt{this.method()}) scavalcano il proxy e perdono le funzionalità AOP. \\
    \hline
    \textbf{Final} & Le classi o i metodi \texttt{final} non possono essere proxati con CGLIB (Spring darà errore all'avvio). \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Il Pattern Adapter (Structural)}

"Se qualcosa non si incastra, forza finché non entra". Questa è una pessima idea in meccanica, ma è la base dell'integrazione software.

Il \textbf{Adapter Pattern} permette a interfacce incompatibili di lavorare insieme. Agisce come un convertitore (pensa all'adattatore della presa elettrica USA $\to$ EU) che traduce le chiamate del client in un formato comprensibile per il sistema target.

\section{Il Problema: L'Integrazione Legacy}
Stai costruendo un moderno e-commerce che usa \texttt{JSON} e oggetti DTO puliti.
Tuttavia, devi integrare un vecchio sistema di fatturazione (Legacy) fornito dalla banca, che accetta solo \texttt{XML} e ha nomi dei metodi incomprensibili.

\begin{itemize}
    \item \textbf{Opzione A (Bad):} Sporchi il tuo codice moderno con logica XML e chiamate al sistema vecchio ovunque.
    \item \textbf{Opzione B (Good):} Crei un Adapter che nasconde la "bruttezza" del sistema vecchio dietro un'interfaccia pulita.
\end{itemize}

\begin{center}
\begin{tikzpicture}[
    auto,
    thick,
    block/.style={
        rectangle,
        draw=blue!60!black,
        fill=white,
        minimum width=3.0cm,
        minimum height=1.6cm,
        align=center
    },
    adapter/.style={
        rectangle,
        draw=orange!80!black,
        fill=orange!20,
        minimum width=3.0cm,
        minimum height=1.6cm,
        align=center
    },
    legacy/.style={
        rectangle,
        draw=black,
        fill=gray!25,
        minimum width=3.0cm,
        minimum height=1.6cm,
        align=center
    },
    arrow/.style={->, >=stealth, thick},
    labelstyle/.style={font=\footnotesize}
]

% Nodes
\node[block] (client) {Tuo Codice\\\footnotesize(Domain)};
\node[adapter, right=3.0cm of client] (adapter) {Adapter};
\node[legacy,  right=3.0cm of adapter] (legacy) {Legacy System\\\footnotesize(Incompatibile)};

% Arrows - forward
\draw[arrow] (client) -- node[above, labelstyle] {1.\ request()} (adapter);
\draw[arrow] (adapter) -- node[above, labelstyle] {2.\ specificReq()} (legacy);

% Arrows - backward (responses)
\draw[arrow, dashed] (legacy) -- node[below, labelstyle] {3.\ XML} (adapter);
\draw[arrow, dashed] (adapter) -- node[below, labelstyle] {4.\ DTO} (client);

\end{tikzpicture}
\end{center}


\section{Implementazione Pratica}

\subsection{1. L'Adaptee (Il sistema vecchio)}
Questa è la classe che non puoi modificare (es. una libreria esterna chiusa).

\begin{lstlisting}[language=Java]
// Classe chiusa, metodi final, logica oscura
public class OldBankSystem {
    public String sendPaymentXML(String xmlData) {
        System.out.println("Processing XML: " + xmlData);
        return "<response>SUCCESS</response>";
    }
}
\end{lstlisting}

\subsection{2. Il Target (La tua interfaccia ideale)}
Questo è come il tuo codice vorrebbe interagire con il mondo.

\begin{lstlisting}[language=Java]
public interface PaymentGateway {
    boolean processPayment(PaymentDTO payment);
}
\end{lstlisting}

\subsection{3. L'Adapter (Il ponte)}
Implementa la tua interfaccia e delega al sistema vecchio, facendo la traduzione.

\begin{lstlisting}[language=Java]
@Service // In Spring diventa un Bean iniettabile
@RequiredArgsConstructor
public class BankAdapter implements PaymentGateway {

    private final OldBankSystem oldSystem;

    @Override
    public boolean processPayment(PaymentDTO payment) {
        // 1. Traduzione Input (DTO -> XML)
        String xmlPayload = convertToXml(payment);
        
        // 2. Chiamata al sistema Legacy
        String response = oldSystem.sendPaymentXML(xmlPayload);
        
        // 3. Traduzione Output (XML -> boolean)
        return response.contains("SUCCESS");
    }

    private String convertToXml(PaymentDTO dto) {
        return "<payment amount='" + dto.getAmount() + "' />";
    }
}
\end{lstlisting}

\section{Java Core Examples}
L'Adapter è ovunque nel JDK.

\subsection{Arrays.asList()}
Un array \texttt{String[]} e una \texttt{List<String>} sono incompatibili.
Il metodo statico \texttt{Arrays.asList()} funge da Adapter: avvolge l'array e lo fa sembrare una lista (pur mantenendo i dati nell'array originale).

\subsection{InputStreamReader}
I flussi di I/O sono pieni di adapter.
\begin{itemize}
    \item \texttt{InputStream}: Legge byte grezzi.
    \item \texttt{Reader}: Legge caratteri (char).
\end{itemize}
\texttt{InputStreamReader} adatta un \texttt{InputStream} per farlo diventare un \texttt{Reader}.

\section{Spring MVC: HandlerAdapter}
Come fa Spring a chiamare il tuo metodo nel Controller, indipendentemente da come lo hai scritto (con o senza parametri, con o senza \texttt{@RequestBody})?

Usa il pattern \textbf{HandlerAdapter}.
Il \texttt{DispatcherServlet} (il cuore di MVC) non chiama direttamente i controller. Delega a un Adapter.
\begin{itemize}
    \item Esiste un \texttt{RequestMappingHandlerAdapter} che sa come invocare i metodi annotati con \texttt{@RequestMapping}.
    \item Se domani inventi un nuovo modo di scrivere controller, basta scrivere un nuovo Adapter e Spring potrà usarlo senza modificare il core.
\end{itemize}

\section{Interview Questions}

\begin{interview}{Adapter vs Decorator vs Proxy}
\textbf{Domanda:} Sono tutti wrapper. Qual è la differenza?

\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Adapter:} Cambia l'\textbf{Interfaccia}. Fa collaborare oggetti incompatibili (presa tonda in spina quadrata).
    \item \textbf{Decorator:} Mantiene l'interfaccia ma aggiunge \textbf{Responsabilità/Comportamento} (es. aggiungere la compressione a uno stream).
    \item \textbf{Proxy:} Mantiene l'interfaccia ma controlla l'\textbf{Accesso} (es. sicurezza, transazioni, lazy loading).
\end{itemize}
\end{interview}

\begin{deepdive}{DDD: Anti-Corruption Layer (ACL)}
Nel Domain-Driven Design, l'Adapter è il blocco costruttivo dell'ACL.
Se il tuo dominio deve parlare con un sistema ERP "sporco", costruisci uno strato di Adapter che impedisce ai termini e alle strutture dati dell'ERP di infiltrarsi nel tuo codice pulito.
Il tuo codice conosce solo i DTO dell'ACL, mai gli oggetti dell'ERP.
\end{deepdive}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Concetto}} & \textcolor{white}{\textbf{Best Practice}} \\
    \hline
    \textbf{Scopo} & Integrare classi incompatibili o Legacy senza modificare il codice esistente. \\
    \hline
    \textbf{Principio SOLID} & Rispetta l'\textbf{Interface Segregation Principle} e l'\textbf{Open/Closed} (estendi il sistema con l'adapter senza toccare il vecchio codice). \\
    \hline
    \textbf{Composizione} & Preferisci l'Adapter a Oggetti (composizione) rispetto all'Adapter di Classe (ereditarietà multipla, che in Java non esiste). \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Il Pattern Observer (Behavioral)}

Nelle architetture monolitiche disordinate, i Service si chiamano tutti a vicenda.
Il \texttt{UserService} chiama il \texttt{EmailService}, che chiama il \texttt{AuditService}, che chiama il \texttt{AnalyticsService}... creando un groviglio inestricabile (Spaghetti Code).

Il \textbf{Observer Pattern} risolve questo problema invertendo la dipendenza. Invece di ordinare agli altri di fare qualcosa, un oggetto dice semplicemente: \textit{"È successo questo evento!"}. Chi è interessato, reagirà.

\section{Il Problema: Accoppiamento Stretto}
Immagina il caso d'uso: \textbf{Registrazione Utente}.
Dopo aver salvato l'utente, devi fare 3 cose: inviare una mail di benvenuto, tracciare l'evento su Google Analytics e scrivere un log di audit.

\begin{lstlisting}[language=Java, title={Approccio Procedurale (Bad)}]
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repo;
    private final EmailService emailService;       // Dipendenza 1
    private final AnalyticsService analyticsService; // Dipendenza 2
    private final AuditService auditService;       // Dipendenza 3

    public void register(User user) {
        repo.save(user);
        
        // Il Service sa TROPPO. Se aggiungi un quarto step, devi modificare qui.
        emailService.sendWelcomeEmail(user);
        analyticsService.trackRegistration(user);
        auditService.logAction("REGISTER", user);
    }
}
\end{lstlisting}

\section{La Soluzione Spring: Application Events}
Spring implementa l'Observer Pattern in modo nativo e potentissimo tramite l'\textbf{ApplicationContext}.

Il flusso è composto da tre attori:
\begin{enumerate}
    \item \textbf{Event:} Un semplice POJO che contiene i dati (il messaggio).
    \item \textbf{Publisher:} Colui che lancia l'evento (il Subject).
    \item \textbf{Listener:} Colui che ascolta e reagisce (l'Observer).
\end{enumerate}

\begin{center}
\begin{tikzpicture}[
    auto,
    thick,
    block/.style={
        rectangle,
        draw=blue!60!black,
        fill=white,
        minimum width=3.2cm,
        minimum height=1.4cm,
        align=center
    },
    event/.style={
        circle,
        draw=orange!80!black,
        fill=orange!20,
        minimum size=1.8cm,
        align=center
    },
    arrow/.style={->, >=stealth, thick},
    labelstyle/.style={font=\footnotesize}
]

% Publisher
\node[block] (pub) {UserService\\\footnotesize(Publisher)};

% Event
\node[event, right=2.8cm of pub] (evt) {User\\Created\\Event};

% Listeners (stacked vertically)
\node[block, right=3.4cm of evt, yshift=1.8cm] (lis1) {EmailService\\\footnotesize(Listener)};
\node[block, right=3.4cm of evt]             (lis2) {AuditService\\\footnotesize(Listener)};
\node[block, right=3.4cm of evt, yshift=-1.8cm] (lis3) {AnalyticsService\\\footnotesize(Listener)};

% Arrows
\draw[arrow] (pub) -- node[above, labelstyle] {pubblica} (evt);

\draw[arrow, dashed] (evt) -- node[above, labelstyle] {notifica} (lis1);
\draw[arrow, dashed] (evt) -- node[above, labelstyle] {notifica} (lis2);
\draw[arrow, dashed] (evt) -- node[above, labelstyle] {notifica} (lis3);

\end{tikzpicture}
\end{center}

\subsection{1. L'Evento (POJO)}
In Spring moderno, non serve più estendere classi speciali. Basta un oggetto Java.

\begin{lstlisting}[language=Java]
// I Record sono perfetti per gli eventi (immutabili)
public record UserCreatedEvent(String email, String username) {}
\end{lstlisting}

\subsection{2. Il Publisher (UserService)}
Il Service non conosce più gli altri componenti. Inietta solo il \texttt{ApplicationEventPublisher}.

\begin{lstlisting}[language=Java]
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repo;
    private final ApplicationEventPublisher publisher; // Interfaccia Spring

    public void register(User user) {
        repo.save(user);
        
        // Lancia e dimentica. Disaccoppiamento totale.
        publisher.publishEvent(new UserCreatedEvent(user.getEmail(), user.getUsername()));
    }
}
\end{lstlisting}

\subsection{3. I Listener (Observers)}
Gli altri service ascoltano l'evento usando l'annotazione \texttt{@EventListener}.

\begin{lstlisting}[language=Java]
@Component
public class EmailListener {

    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        // Manda la mail...
        System.out.println("Invio email a " + event.email());
    }
}

@Component
public class AuditListener {

    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        // Scrive il log...
        System.out.println("Audit log per " + event.username());
    }
}
\end{lstlisting}

\section{Sincrono vs Asincrono}
Qui casca l'asino (e il Junior).

\begin{interview}{Spring Events sono Async?}
\textbf{Domanda:} Se uso \texttt{@EventListener}, l'invio della mail avviene in background?

\textbf{Risposta:} \textbf{No, di default è Sincrono.}
Tutto avviene nello stesso Thread del \texttt{UserService}.
Se l'invio della mail impiega 5 secondi, la risposta HTTP della registrazione ritarderà di 5 secondi.
Se l'invio della mail lancia un'eccezione non gestita, la transazione di registrazione potrebbe fare Rollback!
\end{interview}

\subsection{Come renderlo Asincrono (@Async)}
Se vuoi che l'evento sia gestito in un thread separato (Fire-and-Forget reale), devi combinare due annotazioni.

\begin{lstlisting}[language=Java]
@Component
public class AsyncEmailListener {

    @Async // Esegui in un thread separato (TaskExecutor)
    @EventListener
    public void sendEmailAsync(UserCreatedEvent event) {
        // ... operazione lenta ...
    }
}
\end{lstlisting}
\textit{Nota: Ricorda di abilitare \texttt{@EnableAsync} nella configurazione.}

\section{Transactional Events (Livello Senior)}
Cosa succede se salvi l'utente, pubblichi l'evento, mandi la mail (sincrona), ma poi \textbf{la transazione del DB fallisce} e fa Rollback?
\begin{itemize}
    \item L'utente \textbf{non} è stato creato nel DB.
    \item Ma la mail di benvenuto è partita!
\end{itemize}
Questo è uno stato inconsistente ("Phantom Notification").

\subsection{La Soluzione: @TransactionalEventListener}
Spring permette di ascoltare l'evento solo in una specifica fase della transazione.

\begin{lstlisting}[language=Java]
@Component
public class SafeEmailListener {

    // Esegui questo metodo SOLO se la transazione del Publisher
    // ha fatto COMMIT con successo.
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void sendEmailOnlyIfCommitted(UserCreatedEvent event) {
        // Ora siamo sicuri che l'utente esiste nel DB.
        emailService.send(event.email());
    }
}
\end{lstlisting}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Caratteristica}} & \textcolor{white}{\textbf{Dettaglio}} \\
    \hline
    \textbf{Scopo} & Disaccoppiare chi produce un dato da chi lo consuma. Relazione 1-a-Molti. \\
    \hline
    \textbf{Implementazione} & Usa \texttt{ApplicationEventPublisher} e \texttt{@EventListener}. Evita l'interfaccia \texttt{Observer} di Java (deprecata). \\
    \hline
    \textbf{Default} & Sincrono. Blocca il thread chiamante. \\
    \hline
    \textbf{Consistency} & Usa \texttt{@TransactionalEventListener} per garantire che l'evento parta solo a transazione conclusa. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Il Pattern Decorator (Structural)}

"Preferire la Composizione all'Ereditarietà".
Il \textbf{Decorator Pattern} è la massima espressione di questo principio.

Permette di aggiungere funzionalità a un oggetto dinamicamente, avvolgendolo in un guscio (wrapper). È come una matrioska: l'oggetto esterno aggiunge qualcosa e poi delega il lavoro all'oggetto interno.

\section{Il Problema: L'Esplosione delle Classi}
Immagina di dover gestire dei flussi di dati. Vuoi supportare:
\begin{itemize}
    \item Lettura dati base.
    \item Crittografia.
    \item Compressione.
\end{itemize}

Se usi l'ereditarietà, ti trovi in un incubo combinatorio:
\begin{itemize}
    \item \texttt{FileStream}
    \item \texttt{EncryptedFileStream}
    \item \texttt{CompressedFileStream}
    \item \texttt{EncryptedCompressedFileStream} ...
\end{itemize}
Ogni nuova feature raddoppia il numero di classi necessarie.

\begin{center}
\begin{tikzpicture}[
    auto,
    thick,
    obj/.style={circle, draw=blue!60!black, fill=white, minimum size=1.6cm, align=center},
    wrap/.style={circle, draw=orange!80!black, dashed, thick},
    labelstyle/.style={font=\footnotesize}
]

% Core
\node[obj] (core) {Core\\Object};

% Primo decoratore (A)
\node[wrap, minimum size=3.0cm] (decA) at (core) {};
\node[labelstyle, above] at (decA.north) {Decorator A};

% Secondo decoratore (B)
\node[wrap, minimum size=4.4cm] (decB) at (core) {};
\node[labelstyle, above] at (decB.north) {Decorator B};

% Frecce
\draw[->] (decB.east) -- ++(1.0,0) node[right, labelstyle] {chiama} |- (decA.east);
\draw[->] (decA.east) -- ++(0.7,0) |- (core.east);

\end{tikzpicture}
\end{center}


\section{Esempio Reale: Java I/O}
Il miglior esempio di Decorator è la libreria standard \texttt{java.io}.
Hai mai notato questa sintassi "a cipolla"?

\begin{lstlisting}[language=Java]
// File -> Buffer -> GZip -> Object
InputStream in = new ObjectInputStream(
    new GZIPInputStream(
        new BufferedInputStream(
            new FileInputStream("data.txt")
        )
    )
);
\end{lstlisting}

\begin{itemize}
    \item \textbf{FileInputStream:} Componente Concreto (legge i byte).
    \item \textbf{BufferedInputStream:} Decorator (aggiunge un buffer in RAM per performance).
    \item \textbf{GZIPInputStream:} Decorator (decomprime i dati al volo).
\end{itemize}
Tutti implementano la stessa interfaccia (\texttt{InputStream}). Il client non sa e non si preoccupa di quanti strati ci siano.

\section{Implementazione Manuale}
Vediamo come costruire un sistema di notifiche modulare (Email, SMS, Slack) usando il Decorator.

\subsection{1. Interfaccia Comune}
\begin{lstlisting}[language=Java]
public interface Notifier {
    void send(String message);
}
\end{lstlisting}

\subsection{2. Componente Base}
\begin{lstlisting}[language=Java]
public class EmailNotifier implements Notifier {
    public void send(String message) {
        System.out.println("Invio Email: " + message);
    }
}
\end{lstlisting}

\subsection{3. Decorator Base (Astratto)}
Mantiene il riferimento all'oggetto "wrappato".

\begin{lstlisting}[language=Java]
@RequiredArgsConstructor
public abstract class NotifierDecorator implements Notifier {
    protected final Notifier wrapped;

    @Override
    public void send(String message) {
        wrapped.send(message); // Delega standard
    }
}
\end{lstlisting}

\subsection{4. Decoratori Concreti}
Aggiungono comportamento prima o dopo la delega.

\begin{lstlisting}[language=Java]
public class SMSDecorator extends NotifierDecorator {
    public SMSDecorator(Notifier wrapped) { super(wrapped); }

    @Override
    public void send(String message) {
        super.send(message); // Manda l'email (o il precedente)
        System.out.println("Invio SMS: " + message); // Funzionalità aggiunta
    }
}

public class SlackDecorator extends NotifierDecorator {
    public SlackDecorator(Notifier wrapped) { super(wrapped); }

    @Override
    public void send(String message) {
        super.send(message);
        System.out.println("Post su Slack: " + message);
    }
}
\end{lstlisting}

\subsection{Utilizzo}
\begin{lstlisting}[language=Java]
// Voglio Email + SMS + Slack
Notifier stack = new SlackDecorator(
                    new SMSDecorator(
                        new EmailNotifier()
                    )
                 );

stack.send("Server Down!"); 
// Output:
// Invio Email...
// Invio SMS...
// Post su Slack...
\end{lstlisting}

\section{Real World in Spring/Enterprise}

\subsection{1. Collections.unmodifiableList()}
Quando chiami \texttt{Collections.unmodifiableList(list)}, Java non copia i dati.
Restituisce un Decorator che avvolge la tua lista originale.
\begin{itemize}
    \item I metodi di lettura (\texttt{get}) sono delegati alla lista originale.
    \item I metodi di scrittura (\texttt{add}, \texttt{remove}) sono sovrascritti per lanciare \texttt{UnsupportedOperationException}.
\end{itemize}

\subsection{2. Servlet Filters (HttpServletRequestWrapper)}
In Spring Security o nei filtri custom, spesso vogliamo modificare la richiesta HTTP (es. fare il trim delle stringhe in input o sanificare XSS).
Non possiamo modificare l'oggetto \texttt{HttpServletRequest} originale.

Usiamo \texttt{HttpServletRequestWrapper} (un Decorator).
\begin{lstlisting}[language=Java]
public class XSSRequestWrapper extends HttpServletRequestWrapper {
    public XSSRequestWrapper(HttpServletRequest request) {
        super(request);
    }

    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return sanitizeXSS(value); // Aggiunge comportamento al volo
    }
}
\end{lstlisting}

\section{Interview Questions}

\begin{interview}{Decorator vs Proxy}
\textbf{Domanda:} Strutturalmente sono identici (un wrapper che delega a un oggetto interno). Qual è la differenza?

\textbf{Risposta:} L'\textbf{Intento}.
\begin{itemize}
    \item \textbf{Proxy:} Controlla l'\textbf{Accesso}. Non cambia la funzionalità di business, ma aggiunge logica "amministrativa" (Lazy Loading, Security, Transaction). Spesso il client non sa di usare un proxy.
    \item \textbf{Decorator:} Aggiunge \textbf{Funzionalità/Responsabilità}. Arricchisce l'oggetto (es. aggiunge compressione, bordi grafici, notifiche extra). Il client spesso compone la catena manualmente.
\end{itemize}
\end{interview}

\begin{interview}{Decorator vs Inheritance}
\textbf{Domanda:} Quando l'ereditarietà è preferibile al Decorator?
\textbf{Risposta:} Quando la funzionalità aggiunta dipende strettamente dalla struttura interna della classe padre e non deve essere combinata dinamicamente. Il Decorator è potente ma crea tanti piccoli oggetti in memoria e rende il debugging più difficile (stack trace profondi).
\end{interview}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Caratteristica}} & \textcolor{white}{\textbf{Dettaglio}} \\
    \hline
    \textbf{Obiettivo} & Aggiungere responsabilità a singoli oggetti dinamicamente, senza estendere classi. \\
    \hline
    \textbf{Vantaggio} & Evita l'esplosione combinatoria delle sottoclassi. Rispetta il Single Responsibility Principle. \\
    \hline
    \textbf{Esempi Java} & \texttt{java.io.*} (Streams), \texttt{Collections.synchronizedList()}, \texttt{HttpServletRequestWrapper}. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Il Pattern Template Method (Behavioral)}

Hai mai notato che molte operazioni seguono uno schema fisso, dove cambiano solo pochi dettagli?
Aprire file $\to$ \textbf{Processare riga} $\to$ Chiudere file.
Aprire connessione DB $\to$ \textbf{Mappare ResultSet} $\to$ Chiudere connessione.

Il \textbf{Template Method} definisce lo scheletro di un algoritmo in una classe base, deferendo alcuni passaggi alle sottoclassi. È l'incarnazione del \textbf{Hollywood Principle}: \textit{"Non chiamateci, vi chiameremo noi"}.

\section{Il Problema: Duplicazione del Flusso}
Immagina di dover generare report in formati diversi (CSV e PDF).

\begin{itemize}
    \item \textbf{CsvReport:} Connette al DB, recupera dati, converte in stringhe separate da virgola, salva su file.
    \item \textbf{PdfReport:} Connette al DB, recupera dati, disegna tabelle grafiche, salva su file.
\end{itemize}

Il 90\% del codice (connessione, recupero dati, gestione errori I/O, salvataggio) è identico. Solo la fase di "formattazione" cambia.
Se copi e incolli il codice in due classi, al primo bug dovrai correggere in due posti.

\section{La Soluzione: Lo Scheletro}
Creiamo una classe astratta che possiede un metodo \texttt{final} (il Template) che detta legge sull'ordine di esecuzione.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto, thick,
    class/.style={rectangle, draw=deepblue, fill=white, text width=4cm, align=left, minimum height=2cm},
    note/.style={rectangle, draw=none, text width=3cm, align=left, font=\scriptsize}
]
    \node[class] (base) {
        \textbf{AbstractReport}\\
        \rule{3.8cm}{0.5pt}\\
        + generate() \textbf{\{final\}}\\
        \# \textit{fetchData()}\\
        \# \textit{formatData()}\\
        \# \textit{saveFile()}
    };
    
    \node[note, right=0.5cm of base] {
        \textbf{generate() Code:}\\
        1. fetchData()\\
        2. formatData()\\
        3. saveFile()
    };
    
    \node[class, below=1cm of base, xshift=-2.5cm] (csv) {\textbf{CsvReport}\\formatData() \{...\}};
    \node[class, below=1cm of base, xshift=2.5cm] (pdf) {\textbf{PdfReport}\\formatData() \{...\}};
    
    \draw[->, >=stealth] (csv) -- (base);
    \draw[->, >=stealth] (pdf) -- (base);

\end{tikzpicture}
\end{center}

\section{Implementazione Pratica}

\subsection{1. La Classe Astratta (Template)}
\begin{lstlisting}[language=Java]
public abstract class DataProcessor {

    // IL TEMPLATE METHOD
    // È final per impedire che le sottoclassi cambino l'algoritmo.
    public final void process() {
        try {
            openResource();
            
            // Passaggio variabile (astratto)
            processData(); 
            
            // Hook (opzionale)
            if (shouldLog()) {
                System.out.println("Processing completato");
            }
        } finally {
            closeResource(); // Eseguito sempre
        }
    }

    // Parte fissa (comune a tutti)
    private void openResource() { System.out.println("Apro File..."); }
    private void closeResource() { System.out.println("Chiudo File..."); }

    // Parte variabile (obbligatoria)
    protected abstract void processData();

    // Hook (facoltativo, ha implementazione di default vuota)
    protected boolean shouldLog() { return true; }
}
\end{lstlisting}

\subsection{2. Le Sottoclassi Concrete}
\begin{lstlisting}[language=Java]
public class CsvProcessor extends DataProcessor {
    @Override
    protected void processData() {
        System.out.println("Converto in CSV...");
    }
}

public class JsonProcessor extends DataProcessor {
    @Override
    protected void processData() {
        System.out.println("Serializzo in JSON...");
    }
    
    @Override
    protected boolean shouldLog() {
        return false; // Override dell'hook
    }
}
\end{lstlisting}

\section{Real World: Spring Templates}
Spring usa massicciamente questo pattern, ma con una variante moderna: invece di usare l'ereditarietà (classe astratta), usa le \textbf{Callback} (interfacce funzionali).

\subsection{JdbcTemplate}
Pensaci: quando usi JDBC puro devi aprire la connessione, creare lo statement, ciclare il ResultSet, gestire \texttt{SQLException} e chiudere tutto nel finally.
Spring \texttt{JdbcTemplate} fa tutto questo per te.

\begin{itemize}
    \item \textbf{Parte Fissa (Template):} Gestione connessione, transazione, try-catch-finally.
    \item \textbf{Parte Variabile:} "Come mappo questa singola riga SQL su un oggetto Java?".
\end{itemize}

Tu fornisci solo la parte variabile tramite un \texttt{RowMapper}:

\begin{lstlisting}[language=Java]
// JdbcTemplate.query è il Template Method
jdbcTemplate.query(
    "SELECT * FROM users", 
    
    // Questa lambda è l'implementazione del passaggio variabile
    (resultSet, rowNum) -> new User(resultSet.getString("name"))
);
\end{lstlisting}

\section{Template vs Strategy}
Questa è la domanda da colloquio per eccellenza per distinguere i pattern.

\begin{interview}{Differenza tra Template Method e Strategy}
\textbf{Domanda:} Entrambi permettono di variare parti di un algoritmo. Qual è la differenza?

\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Template Method (Ereditarietà):} La struttura è definita nella classe padre. Modifichi il comportamento \textbf{estendendo} la classe e sovrascrivendo i metodi. È statico (compilazione).
    \item \textbf{Strategy (Composizione):} La logica è delegata a un oggetto esterno (interfaccia). Modifichi il comportamento \textbf{iniettando} una diversa implementazione. È dinamico (runtime).
\end{itemize}
\textbf{Verdetto Senior:} Oggi si preferisce quasi sempre lo \textbf{Strategy} ("Favor composition over inheritance"), tranne quando si scrivono framework o librerie base dove si vuole forzare uno scheletro rigido.
\end{interview}

\section{Modern Java: Execute Around Pattern}
Con le Lambda di Java 8, il Template Method è evoluto nel pattern \textbf{Execute Around}.
Invece di creare una classe figlia per ogni variante, passi un comportamento (Lambda) a un metodo.

\begin{lstlisting}[language=Java, title={Template Method Funzionale}]
public class TransactionHelper {
    
    // Metodo che accetta una funzione (la parte variabile)
    public static void runInTransaction(Runnable businessLogic) {
        System.out.println("BEGIN TX");
        try {
            businessLogic.run(); // Esegue il pezzo variabile
            System.out.println("COMMIT");
        } catch (Exception e) {
            System.out.println("ROLLBACK");
        }
    }
}

// Utilizzo (senza estendere classi!)
TransactionHelper.runInTransaction(() -> {
    System.out.println("Salvataggio Utente...");
});
\end{lstlisting}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Caratteristica}} & \textcolor{white}{\textbf{Dettaglio}} \\
    \hline
    \textbf{Obiettivo} & Definire lo scheletro di un algoritmo, permettendo alle sottoclassi di ridefinire certi passaggi senza cambiare la struttura. \\
    \hline
    \textbf{Hook} & Metodi opzionali (spesso vuoti nel padre) che le sottoclassi possono decidere di estendere o ignorare. \\
    \hline
    \textbf{Spring} & Usato in \texttt{JdbcTemplate}, \texttt{RestTemplate}, \texttt{JmsTemplate} (nella variante con Callback). \\
    \hline
    \textbf{Contro} & L'ereditarietà è rigida. Se puoi, preferisci Strategy o le Lambda (Execute Around). \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Il Pattern Chain of Responsibility (Behavioral)}

"Passarsi la palla".
In un sistema complesso, spesso una richiesta deve superare una serie di controlli prima di essere elaborata: Autenticazione, Autorizzazione, Validazione, Logging, Caching.

Se mettessimo tutta questa logica in un unico metodo, avremmo un mostro procedurale.
Il \textbf{Chain of Responsibility Pattern} permette di passare una richiesta lungo una catena di "Gestori" (Handlers). Ogni gestore decide se:
\begin{enumerate}
    \item Elaborare la richiesta.
    \item Passarla al prossimo anello della catena.
    \item Bloccare la catena (Short-circuit).
\end{enumerate}

\section{Il Problema: Validazione Sequenziale}
Immagina un sistema di approvazione spese aziendali.
\begin{itemize}
    \item Spese $<$ 100\euro: Approvate automaticamente.
    \item Spese $<$ 1000\euro: Richiedono approvazione del Manager.
    \item Spese $>$ 1000\euro: Richiedono approvazione del CEO.
\end{itemize}

Scrivere questo con \texttt{if-else} annidati crea codice rigido. Se domani aggiungiamo il "VP Finance", dobbiamo toccare la logica di tutti.

\section{La Soluzione: La Catena}
Creiamo una serie di oggetti collegati. Ognuno conosce solo il suo successore.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto, thick,
    handler/.style={rectangle, draw=deepblue, fill=white, text width=2.5cm, align=center, minimum height=1.5cm},
    arrow/.style={->, >=stealth, thick}
]

    \node (req) {Richiesta};
    \node[handler, right=1cm of req] (h1) {Auth\\Handler};
    \node[handler, right=1cm of h1] (h2) {Validation\\Handler};
    \node[handler, right=1cm of h2] (h3) {Business\\Logic};
    
    \draw[arrow] (req) -- (h1);
    \draw[arrow] (h1) -- node[above, font=\tiny] {next} (h2);
    \draw[arrow] (h2) -- node[above, font=\tiny] {next} (h3);

    \draw[arrow, red, dashed, bend right] (h1.north) to node[above, font=\tiny] {Error (Stop)} (req.north);

\end{tikzpicture}
\end{center}

\section{Implementazione Classica (GoF)}
In questo approccio (Linked List), ogni handler ha un riferimento al prossimo.

\begin{lstlisting}[language=Java]
public abstract class Handler {
    protected Handler next;

    public void setNext(Handler next) { this.next = next; }

    public void handleRequest(Request req) {
        if (canHandle(req)) {
            process(req);
        } else if (next != null) {
            next.handleRequest(req); // Passa la palla
        }
    }

    protected abstract boolean canHandle(Request req);
    protected abstract void process(Request req);
}
\end{lstlisting}

\section{Spring Security: The Ultimate Chain}
Il caso d'uso più famoso nel mondo Java è la \textbf{Security Filter Chain}.

Quando una richiesta HTTP arriva al tuo server (Tomcat), prima di toccare il tuo Controller, deve attraversare una catena di filtri gestita da Spring Security.

\begin{enumerate}
    \item \textbf{CorsFilter:} Controlla gli header CORS. Se fallisce, blocca tutto.
    \item \textbf{CsrfFilter:} Controlla il token anti-forgery.
    \item \textbf{JwtAuthenticationFilter:} (Custom) Controlla se c'è il Token Bearer, lo valida e setta l'utente nel contesto.
    \item \textbf{UsernamePasswordAuthenticationFilter:} Gestisce il login classico.
    \item \textbf{FilterSecurityInterceptor:} L'ultimo della catena. Controlla se l'utente ha il ruolo giusto (es. \texttt{ROLE\_ADMIN}) per accedere all'URL.
\end{enumerate}

\begin{deepdive}{Short-Circuiting (Il Muro)}
La potenza della Chain è la capacità di interrompere il flusso.
Se il \texttt{JwtAuthenticationFilter} scopre che il token è scaduto:
\begin{enumerate}
    \item Lancia un'eccezione o scrive direttamente nella Response (HTTP 401).
    \item \textbf{NON} chiama \texttt{chain.doFilter()}.
    \item La richiesta muore lì. Il Database non viene nemmeno toccato. Questo protegge il sistema da carico inutile.
\end{enumerate}
\end{deepdive}

\section{Implementazione "Spring Style" (List Injection)}
Invece di linkare manualmente gli handler (`h1.setNext(h2)`), usiamo la Dependency Injection di Spring per iniettare una lista ordinata. È più pulito.

\begin{lstlisting}[language=Java, title={Chain con @Order}]
// 1. Interfaccia comune
public interface OrderValidator {
    void validate(Order order);
}

// 2. Implementazioni con ordine specifico
@Component
@Order(1)
public class StockValidator implements OrderValidator { ... }

@Component
@Order(2)
public class FraudValidator implements OrderValidator { ... }

@Component
@Order(3)
public class PaymentValidator implements OrderValidator { ... }

// 3. Il "Manager" della catena
@Service
@RequiredArgsConstructor
public class OrderProcessingService {

    // Spring inietta tutti i bean trovati, ordinati per @Order!
    private final List<OrderValidator> validators;

    public void process(Order order) {
        // Esegue la catena sequenzialmente
        for (OrderValidator v : validators) {
            v.validate(order); // Se uno lancia eccezione, il processo si ferma
        }
        
        saveOrder(order);
    }
}
\end{lstlisting}

\section{Spring MVC Interceptors}
Un'altra incarnazione del pattern è \texttt{HandlerInterceptor}.
Permette di eseguire codice prima e dopo l'esecuzione del Controller.

\begin{itemize}
    \item \texttt{preHandle()}: Prima del controller. Se ritorna \texttt{false}, la catena si ferma.
    \item \texttt{postHandle()}: Dopo il controller, prima del rendering della vista.
    \item \texttt{afterCompletion()}: Dopo che la risposta è stata inviata al client (utile per pulizia risorse o logging finale).
\end{itemize}

\section{Interview Questions}

\begin{interview}{Chain vs Decorator}
\textbf{Domanda:} Entrambi avvolgono logica in sequenza. Qual è la differenza?

\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Decorator:} Aggiunge funzionalità e \textbf{passa sempre} la chiamata all'oggetto decorato. L'obiettivo è arricchire il risultato.
    \item \textbf{Chain of Responsibility:} Ogni handler può decidere di \textbf{interrompere} il flusso e non chiamare il successivo. L'obiettivo è processare (o bloccare) una richiesta. Inoltre, nella Chain classica, spesso solo \textit{uno} degli handler elabora la richiesta, mentre nel Decorator tutti contribuiscono.
\end{itemize}
\end{interview}

\begin{interview}{Ordine di Esecuzione}
\textbf{Domanda:} In Spring Security, l'ordine dei filtri è importante?
\textbf{Risposta:} \textbf{Assolutamente sì.}
Non puoi controllare se l'utente è "ADMIN" (Authorization) se prima non hai capito "Chi è" (Authentication). Ecco perché il filtro JWT deve girare prima del filtro di Autorizzazione.
\end{interview}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Caratteristica}} & \textcolor{white}{\textbf{Dettaglio}} \\
    \hline
    \textbf{Scopo} & Disaccoppiare il mittente dai destinatari, permettendo a più oggetti di gestire la richiesta. \\
    \hline
    \textbf{Spring Security} & È l'esempio principe. Una catena di filtri che protegge l'applicazione. \\
    \hline
    \textbf{Short-Circuit} & La capacità di un anello di bloccare la catena (es. Auth fallita) è la feature chiave per la sicurezza e la validazione. \\
    \hline
    \textbf{@Order} & Usare l'annotazione di Spring per definire la sequenza dei Bean in una lista iniettata. \\
    \hline
\end{tabularx}
\end{center}

\part{JDBC, JPA e Hibernate}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{JDBC: L'Interfaccia Standard per Database}

Prima di Hibernate, prima di Spring Data, c'era (e c'è tuttora) JDBC (Java Database Connectivity). Anche se usi framework di alto livello, sotto il cofano tutto viene tradotto in chiamate JDBC.
Capire JDBC è essenziale per il debugging, per le operazioni di batching massivo e per evitare problemi di sicurezza (SQL Injection).
\newline\newline
JDBC è un insieme di interfacce (pacchetto \texttt{java.sql}) che definiscono uno standard. Sono i produttori dei Database (Oracle, PostgreSQL, MySQL) a fornire l'implementazione concreta tramite i \textbf{Driver JDBC}.

I componenti fondamentali sono:
\begin{enumerate}
    \item \textbf{DriverManager:} La classe di utility che gestisce i driver registrati e crea le connessioni.
    \item \textbf{Connection:} Rappresenta la sessione fisica (socket TCP) con il database. È un oggetto "pesante" da creare.
    \item \textbf{Statement / PreparedStatement:} L'oggetto che trasporta la query SQL al database.
    \item \textbf{ResultSet:} L'oggetto che contiene i dati restituiti (una tabella in memoria puntata da un cursore).
\end{enumerate}

\section{Il DriverManager: Il "Centralino" delle Connessioni}

Il \texttt{DriverManager} è il punto di ingresso storico di JDBC. Immaginalo come un centralino: la tua applicazione non parla direttamente con il driver specifico (MySQL, Oracle), ma chiede al DriverManager una connessione generica, e lui si occupa di trovare il traduttore giusto.

\subsection{Come funziona la selezione del Driver?}
Quando chiami \texttt{getConnection}, il DriverManager scorre una lista interna di driver registrati e pone a ciascuno una domanda: \textit{"Sei in grado di comprendere questa URL?"}.

Il primo driver che risponde "Sì" viene selezionato per creare la connessione.

\begin{lstlisting}[language=Java, caption={Ottenere una Connessione (Il modo classico)}]
// 1. Definiamo la stringa di connessione (JDBC URL)
// Sintassi: jdbc:<vendor>:<proprietà>
String url = "jdbc:postgresql://localhost:5432/mio_db";
String user = "admin";
String pwd = "password123";

try {
    // 2. Chiediamo la connessione al DriverManager
    Connection conn = DriverManager.getConnection(url, user, pwd);
    
    System.out.println("Connessione aperta!");
    
    // ... usa la connessione ...
    
    // 3. È FONDAMENTALE chiudere la connessione
    conn.close(); 
} catch (SQLException e) {
    e.printStackTrace();
}
\end{lstlisting}

\subsection{La JDBC URL: La chiave di tutto}
Il DriverManager capisce quale driver attivare analizzando esclusivamente la stringa di connessione. La struttura è standardizzata:

\begin{center}
\texttt{jdbc:<sottoprotocollo>:<altri-dati>}
\end{center}

\begin{itemize}
    \item \textbf{jdbc:} Prefisso fisso.
    \item \textbf{sottoprotocollo:} Identifica il database (es. \texttt{mysql}, \texttt{postgresql}, \texttt{oracle:thin}, \texttt{h2}).
    \item \textbf{altri-dati:} Indirizzo IP, porta, nome DB e parametri extra.
\end{itemize}

\begin{deepdive}{Il mito del \texttt{Class.forName()}}
Se guardi tutorial vecchi (pre-Java 6), troverai spesso questa riga prima della connessione:
\begin{lstlisting}[language=Java, basicstyle=\ttfamily\scriptsize]
Class.forName("com.mysql.cj.jdbc.Driver"); // Legacy!
\end{lstlisting}
Questo serviva per caricare forzatamente la classe del driver in memoria.
Oggi non serve più: grazie al meccanismo \textbf{SPI (Service Provider Interface)} di Java, il DriverManager scansiona automaticamente i file \texttt{.jar} nel classpath alla ricerca dei driver disponibili.
\end{deepdive}

\subsection{Limiti del DriverManager: Perché serve un Pool?}

Usare il \texttt{DriverManager} direttamente nel codice di produzione di un'applicazione web è considerato una \textbf{bad practice}.

\begin{interview}{Perché non usare DriverManager in produzione?}
\textbf{Domanda:} "Se DriverManager funziona, perché usiamo librerie come HikariCP o il DataSource di Spring?"

\textbf{Risposta:} Per questioni di \textbf{Performance} e \textbf{Latenza}.
\begin{enumerate}
    \item \textbf{Handshake Costoso:} Creare un oggetto \texttt{Connection} fisico richiede l'apertura di un socket TCP, l'autenticazione col DB e l'allocazione di buffer. È un'operazione lenta (può richiedere dai 50ms ai 500ms).
    \item \textbf{Nessun Riutilizzo:} Il DriverManager crea una \textit{nuova} connessione ogni volta e la chiude alla fine. Se hai 1000 utenti al secondo, ucciderai il database con 1000 aperture/chiusure.
\end{enumerate}

\textbf{Soluzione:} Il \textbf{Connection Pooling} (DataSource).
Il Pool tiene aperte, ad esempio, 10 connessioni "calde". Quando l'app chiede una connessione, il Pool ne "presta" una già pronta. Quando l'app fa \texttt{close()}, la connessione non viene chiusa realmente, ma restituita al Pool per essere riusata.
\end{interview}

\section{Deep Dive: Cosa c'è "sotto" una Connessione JDBC?}

Spesso pensiamo alla \texttt{Connection} JDBC come a un semplice oggetto Java nello Heap. In realtà, è solo un wrapper leggero (una "maniglia") che controlla una risorsa di sistema molto pesante: un \textbf{Socket TCP/IP}.

Per capire perché aprire una connessione è un'operazione lenta (dai 50ms ai 500ms, un'eternità per una CPU), dobbiamo scendere al livello di rete.

\subsection{Anatomia di una connessione (The TCP 3-Way Handshake)}
Quando invochi \texttt{DriverManager.getConnection()}, non stai solo allocando memoria Java. Dietro le quinte, il driver JDBC istruisce il sistema operativo a stabilire un canale di comunicazione affidabile con il server del database.

Questo processo segue il protocollo TCP e richiede tre passaggi obbligatori (Handshake) prima di poter inviare anche solo un singolo byte di dati (la query SQL):

\begin{enumerate}
    \item \textbf{SYN (Synchronize):} Il client (la tua app Java) invia un pacchetto al server DB chiedendo di aprire una connessione.
    \item \textbf{SYN-ACK (Synchronize-Acknowledge):} Il server DB riceve la richiesta, alloca le risorse interne (thread, buffer di memoria) e risponde confermando la disponibilità.
    \item \textbf{ACK (Acknowledge):} Il client conferma di aver ricevuto la risposta.
\end{enumerate}

Solo \textit{dopo} questi tre passaggi, il canale è aperto. Ma non è finita qui.

\subsection{L'Overhead del Database (Autenticazione)}
Una volta stabilito il canale TCP, inizia il protocollo applicativo del database (es. PostgreSQL Wire Protocol o MySQL Protocol).

\begin{itemize}
    \item \textbf{Negoziazione:} Client e Server si accordano sulla versione del protocollo, la codifica dei caratteri (UTF-8) e se usare la crittografia (SSL/TLS).
    \item \textbf{Autenticazione:} Il client invia Username e Password (spesso hashata). Il server deve verificare le credenziali, controllare i permessi (ACL) e allocare una sessione utente.
    \item \textbf{Setup Processo:} Molti database (come PostgreSQL) creano un intero nuovo \textit{processo} del sistema operativo per ogni connessione client. Questo è estremamente costoso in termini di RAM e CPU lato server.
\end{itemize}

\begin{deepdive}{Perché chiudere la connessione è vitale?}
    Se non chiami \texttt{conn.close()}, l'oggetto Java \texttt{Connection} alla fine verrà rimosso dal Garbage Collector.
    
    Tuttavia, il \textbf{Socket TCP} sottostante potrebbe rimanere aperto (stato \texttt{ESTABLISHED}) per ore, finché non scatta un timeout di rete (KeepAlive).
    
    Durante questo tempo:
    \begin{itemize}
        \item Il Server DB tiene occupata la RAM per quella sessione "zombie".
        \item Il Server DB raggiunge il limite massimo di connessioni (es. \texttt{max\_connections = 100}) e inizia a rifiutare nuovi utenti.
    \end{itemize}
    
    Chiamare \texttt{close()} invia esplicitamente un pacchetto di terminazione (\textbf{FIN}) al server, permettendogli di liberare le risorse immediatamente.
\end{deepdive}

\begin{interview}{Perché i Connection Pool sono necessari?}
    \textbf{Domanda:} "Hai spiegato che creare una connessione costa tempo e risorse. Come risolviamo il problema in un'app ad alto traffico?"
    
    \textbf{Risposta:} Non chiudendo mai veramente il Socket TCP.
    
    Usiamo un \textbf{Connection Pool} (es. HikariCP).
    \begin{itemize}
        \item Il Pool apre 10 connessioni fisiche (TCP Handshake + Auth) all'avvio dell'app e le tiene "calde".
        \item Quando l'app chiama \texttt{dataSource.getConnection()}, il Pool restituisce un oggetto "proxy" che punta a uno dei socket già aperti (operazione istantanea, microsecondi).
        \item Quando l'app chiama \texttt{conn.close()}, il proxy \textbf{non chiude il socket TCP}. Semplicemente segna la connessione come "libera" nel pool, pronta per essere riusata dal prossimo thread.
    \end{itemize}
\end{interview}

\section{L'Oggetto Connection: Il Canale Fisico}

L'interfaccia \texttt{java.sql.Connection} non è un semplice oggetto Java che vive nell'Heap: è un "puntatore" a una risorsa esterna, un \textbf{Socket TCP} aperto verso il server del database.
Finché l'oggetto \texttt{Connection} è vivo ("open"), c'è un cavo virtuale dedicato che collega la tua JVM al DB.

Le sue responsabilità principali sono due:
\begin{enumerate}
    \item \textbf{Factory di Statement}: È la fabbrica che crea gli oggetti per eseguire le query (\texttt{createStatement}, \texttt{prepareStatement}).
    \item \textbf{Gestore della Transazione}: Controlla quando le modifiche diventano permanenti.
\end{enumerate}

\subsection{Il Controllo della Transazione (AutoCommit)}
In JDBC, il comportamento di default è spesso controintuitivo per chi viene dal mondo Enterprise.
Ogni singola connessione nasce in modalità \textbf{AutoCommit = true}.

Significa che ogni singola query SQL (INSERT, UPDATE) viene trattata come una transazione autonoma e committata immediatamente. Non c'è modo di fare rollback se la query successiva fallisce.

Per gestire una transazione atomica (più operazioni insieme), dobbiamo disabilitare questo automatismo:

\begin{lstlisting}[language=Java, caption={Gestione Transazionale Manuale con JDBC}]
Connection conn = DriverManager.getConnection(url, user, pwd);

try {
    // 1. DISABILITIAMO l'automatismo
    // Ora inizia ufficialmente la transazione
    conn.setAutoCommit(false); 

    // 2. Eseguiamo varie operazioni
    // (codice per insert 1...)
    // (codice per insert 2...)

    // 3. Se arriviamo qui senza errori, confermiamo tutto
    conn.commit(); 

} catch (SQLException e) {
    // 4. Se qualcosa va storto, annulliamo tutto
    conn.rollback();
} finally {
    conn.close();
}
\end{lstlisting}

\begin{deepdive}{Isolation Levels}
Attraverso l'oggetto \texttt{Connection} possiamo anche definire quanto la nostra transazione deve essere isolata dalle modifiche altrui.
\begin{lstlisting}
conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
\end{lstlisting}
Questo è il meccanismo di basso livello che Hibernate usa quando configuriamo l'isolamento su \texttt{@Transactional}.
\end{deepdive}

\subsection{Approfondimento: I Livelli di Isolamento}

Quando più utenti accedono contemporaneamente al database, si verifica un compromesso fondamentale tra \textbf{Performance} (velocità) e \textbf{Coerenza} (precisione dei dati).
L'oggetto \texttt{Connection} ci permette di scegliere questo bilanciamento tramite il metodo \texttt{setTransactionIsolation(int level)}.

Più l'isolamento è alto, più i dati sono sicuri, ma il database diventa lento (a causa dei lock). Più è basso, più il database è veloce, ma rischiamo di leggere dati incoerenti.

\subsubsection{Le Anomalie di Concorrenza}
Per capire i livelli di isolamento, dobbiamo prima definire i tre "mostri" che cercano di combattere:

\begin{description}
    \item[Dirty Read (Lettura Sporca)] \hfill \\
    Avviene quando leggi un dato che un'altra transazione ha modificato ma \textbf{non ha ancora committato}. Se l'altra transazione fa Rollback, tu hai letto un dato che non è mai esistito realmente.
    
    \item[Non-Repeatable Read (Lettura Non Ripetibile)] \hfill \\
    Avviene quando leggi la \textbf{stessa riga} due volte nella stessa transazione e ottieni valori diversi.
    \textit{Esempio:} Leggi "Saldo: 100". Nel frattempo qualcuno fa commit di un prelievo. Rileggi la stessa riga: "Saldo: 50".
    
    \item[Phantom Read (Lettura Fantasma)] \hfill \\
    Avviene quando esegui la stessa query di ricerca (es. "utenti di Roma") due volte e ottieni un \textbf{numero di righe diverso}.
    Non sono cambiati i dati delle righe esistenti, ma sono apparse (INSERT) o sparite (DELETE) intere righe.
\end{description}

\subsubsection{I 4 Livelli Standard JDBC}

La tabella seguente mostra quali anomalie sono permesse (\textcolor{red}{Sì}) e quali sono prevenute (\textcolor{javagreen}{No}) in ogni livello.

\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.4}
\begin{tabularx}{\textwidth}{|l|c|c|c|X|}
\hline
\textbf{Livello JDBC} & \textbf{Dirty} & \textbf{Non-Rep.} & \textbf{Phantom} & \textbf{Note e Utilizzo} \\
\hline

\texttt{READ\_UNCOMMITTED} & 
\textcolor{red}{\textbf{Sì}} & 
\textcolor{red}{\textbf{Sì}} & 
\textcolor{red}{\textbf{Sì}} & 
Performance massima, ma dati inaffidabili. Usato raramente. \\
\hline

\texttt{READ\_COMMITTED} & 
\textcolor{javagreen}{\textbf{No}} & 
\textcolor{red}{\textbf{Sì}} & 
\textcolor{red}{\textbf{Sì}} & 
\textbf{Default} in PostgreSQL, Oracle, SQL Server. Ottimo compromesso. \\
\hline

\texttt{REPEATABLE\_READ} & 
\textcolor{javagreen}{\textbf{No}} & 
\textcolor{javagreen}{\textbf{No}} & 
\textcolor{red}{\textbf{Sì}} & 
\textbf{Default} in MySQL. Blocca le modifiche alle righe lette. \\
\hline

\texttt{SERIALIZABLE} & 
\textcolor{javagreen}{\textbf{No}} & 
\textcolor{javagreen}{\textbf{No}} & 
\textcolor{javagreen}{\textbf{No}} & 
Esegue le transazioni in serie. Lento, alto rischio di Deadlock. \\
\hline
\end{tabularx}
\caption{Matrice dei Livelli di Isolamento (Sì = Anomalia permessa)}
\end{table}

\subsubsection{Configurazione Programmatica}
Ecco come impostare il livello di isolamento direttamente sulla connessione JDBC prima di avviare operazioni critiche.

\begin{lstlisting}[language=Java, caption={Cambiare l'Isolation Level in JDBC}]
Connection conn = dataSource.getConnection();

// Best Practice: Salvare il livello precedente per ripristinarlo dopo
int oldLevel = conn.getTransactionIsolation();

try {
    // Settiamo il livello PARANOICO per operazioni finanziarie
    conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
    conn.setAutoCommit(false); // Inizio Transazione

    // ... operazioni di business critiche ...
    // Qui siamo sicuri che nessuno può inserire/modificare dati
    // che interferiscono con la nostra vista
    
    conn.commit();

} catch (SQLException e) {
    conn.rollback();
    throw e;
} finally {
    // Ripristino dello stato originale (fondamentale per il Pooling!)
    conn.setTransactionIsolation(oldLevel);
    conn.close();
}
\end{lstlisting}

\begin{interview}{Differenza tra Non-Repeatable e Phantom?}
\textbf{Domanda:} "Spesso si confondono. Qual è la differenza tecnica tra Non-Repeatable Read e Phantom Read?"

\textbf{Risposta:} 
\begin{itemize}
    \item \textbf{Non-Repeatable Read} riguarda le \textbf{modifiche (UPDATE)} su righe esistenti che hai già letto. Il lock sulla singola riga può prevenirlo.
    \item \textbf{Phantom Read} riguarda l'apparizione di \textbf{nuove righe (INSERT)} o la sparizione (DELETE) che soddisfano una clausola \texttt{WHERE}.
\end{itemize}
\textit{Metafora:} Il Non-Repeatable Read è come rileggere un libro e trovare una parola cambiata. Il Phantom Read è come rileggere un libro e trovare una pagina in più.
\end{interview}

\subsection{Chiudere le risorse: Il "Try-with-resources"}

Poiché la \texttt{Connection} (e gli Statement che ne derivano) occupa risorse di rete e memoria nel database, non chiuderla è un peccato capitale. Prima di Java 7, il blocco \texttt{finally} era obbligatorio e verboso.

Oggi, poiché \texttt{Connection} implementa l'interfaccia \texttt{AutoCloseable}, usiamo il \textbf{try-with-resources}. Java chiuderà automaticamente la connessione alla fine del blocco, anche in caso di eccezione.

\begin{lstlisting}[language=Java, caption={Pattern Moderno (Java 7+)}]
String sql = "SELECT * FROM utenti WHERE id = ?";

// Le risorse aperte nelle parentesi tonde vengono chiuse automaticamente
try (Connection conn = dataSource.getConnection();
     PreparedStatement ps = conn.prepareStatement(sql)) {
    
    ps.setInt(1, 100);
    
    try (ResultSet rs = ps.executeQuery()) {
        while (rs.next()) {
            System.out.println(rs.getString("nome"));
        }
    }
    // Qui rs.close() è chiamato automaticamente
} catch (SQLException e) {
    e.printStackTrace();
}
// Qui ps.close() e conn.close() sono chiamati automaticamente
\end{lstlisting}

\begin{interview}{Cos'è un Connection Leak?}
\textbf{Domanda:} "Cosa succede se il programmatore dimentica di chiamare \texttt{conn.close()} e non usa il try-with-resources?"

\textbf{Risposta:} Si verifica un \textbf{Connection Leak} (perdita di connessione).
L'oggetto Java viene distrutto dal Garbage Collector, ma il database vede la connessione TCP ancora attiva dall'altra parte.
Dopo un po' di tempo, il database esaurirà il numero massimo di connessioni disponibili (spesso default 100 o 150) e l'intera applicazione smetterà di funzionare, rifiutando nuove richieste con errori di timeout.
\end{interview}

\section{Statement vs PreparedStatement: Sicurezza e Performance}

Una volta ottenuta una \texttt{Connection}, abbiamo bisogno di un "veicolo" per trasportare la nostra query SQL verso il database. JDBC ci offre due interfacce principali: \texttt{Statement} e \texttt{PreparedStatement}.

Scegliere quella sbagliata non è solo una questione di stile: può compromettere la sicurezza dell'intero sistema.

\subsection{Lo Statement (e il pericolo della concatenazione)}
L'interfaccia \texttt{Statement} è la versione base. Si usa per eseguire query SQL statiche.
Il problema nasce quando dobbiamo inserire parametri dinamici (es. un nome utente inserito in un form). Con lo \texttt{Statement}, siamo costretti a usare la \textbf{concatenazione di stringhe}.

\begin{lstlisting}[language=Java, caption={Statement: Il modo pericoloso}]
Statement stmt = conn.createStatement();
String userInput = "Mario";

// CONCATENAZIONE DIRETTA: PERICOLO!
String sql = "SELECT * FROM utenti WHERE nome = '" + userInput + "'";

ResultSet rs = stmt.executeQuery(sql);
\end{lstlisting}

\subsubsection{Il disastro della SQL Injection}
Cosa succede se un utente malintenzionato, invece di scrivere \texttt{"Mario"}, inserisce nel form di login questa stringa?

\begin{center}
\texttt{Mario' OR '1'='1}
\end{center}

La query risultante concatenata diventerà:
\begin{lstlisting}[language=SQL]
SELECT * FROM utenti WHERE nome = 'Mario' OR '1'='1'
\end{lstlisting}

Poiché \texttt{'1'='1'} è sempre vero, il database restituirà \textbf{tutti gli utenti} della tabella, permettendo al pirata di loggarsi come amministratore senza sapere la password. Questo attacco si chiama \textbf{SQL Injection}.

\subsection{Il PreparedStatement: La Soluzione}
Il \texttt{PreparedStatement} (estensione di Statement) risolve il problema alla radice separando la struttura della query dai dati.
Invece di concatenare stringhe, usiamo dei \textbf{segnaposto} (placeholder) indicati dal punto di domanda \texttt{?}.

\begin{lstlisting}[language=Java, caption={PreparedStatement: Il modo sicuro}]
String sql = "SELECT * FROM utenti WHERE nome = ?"; // Notare il ?

PreparedStatement ps = conn.prepareStatement(sql);

// Il driver si occupa di fare l'escaping corretto dei caratteri speciali
ps.setString(1, "Mario' OR '1'='1"); 

ResultSet rs = ps.executeQuery();
\end{lstlisting}

In questo caso, il database cercherà letteralmente un utente che si chiama \textit{"Mario' OR '1'='1"}. Ovviamente non lo troverà e l'attacco fallirà.

\begin{interview}{Perché PreparedStatement è più veloce?}
\textbf{Domanda:} "Oltre alla sicurezza, c'è un motivo di performance per preferire PreparedStatement?"

\textbf{Risposta:} Sì, grazie al \textbf{Database Plan Caching}.
Quando il DB riceve una query, deve:
\begin{enumerate}
    \item Fare il Parsing (controllare la sintassi).
    \item Creare l'Execution Plan (decidere quali indici usare).
\end{enumerate}

Con uno \texttt{Statement} classico, ogni query con parametri diversi (es. \texttt{WHERE id=1}, \texttt{WHERE id=2}) è vista come una query \textbf{diversa}. Il DB deve ricompilarla ogni volta.

Con un \texttt{PreparedStatement}, la struttura \texttt{WHERE id = ?} è inviata una volta sola. Il DB la compila e la mette in cache. Le esecuzioni successive inviano solo i nuovi parametri, saltando la fase di compilazione.
\end{interview}

\subsection{Recuperare i Dati: Il ResultSet}
Sia \texttt{Statement} che \texttt{PreparedStatement} restituiscono un \texttt{ResultSet} quando si esegue una \texttt{executeQuery()}.

Il ResultSet non contiene tutti i dati in memoria (immagina di selezionare 1 milione di righe!). È un \textbf{cursore} che punta a una riga alla volta.

\begin{lstlisting}[language=Java, caption={Iterare su un ResultSet}]
try (ResultSet rs = ps.executeQuery()) {
    // rs.next() sposta il cursore alla riga successiva.
    // Restituisce false quando non ci sono piu' righe.
    while (rs.next()) {
        // Recupero per nome colonna (più leggibile)
        String nome = rs.getString("nome");
        
        // Recupero per indice (parte da 1, leggermente più veloce)
        int eta = rs.getInt(2); 
        
        System.out.println(nome + " - " + eta);
    }
}
\end{lstlisting}

\begin{deepdive}{Attenzione all'Indice 1}
In Java (array, liste) gli indici partono da 0.
In JDBC (\texttt{PreparedStatement} e \texttt{ResultSet}), gli indici partono da \textbf{1}.
Scrivere \texttt{ps.setString(0, "...")} lancerà una \texttt{SQLException}.
\end{deepdive}

\section{Il ResultSet: Navigare i Risultati}

Quando eseguiamo una query \texttt{SELECT}, il database non ci restituisce immediatamente tutti i dati (che potrebbero essere gigabyte), ma ci restituisce un \textbf{ResultSet}.

Il \texttt{ResultSet} non è una \texttt{List} o un array che contiene i dati. È un \textbf{Cursore Attivo} mantenuto aperto tra la nostra applicazione e il database.
Immaginalo come un puntatore che, inizialmente, è posizionato \textit{prima} della prima riga (header).

\subsection{Navigazione e Estrazione}
Il metodo principale è \texttt{rs.next()}. Esegue due operazioni:
\begin{enumerate}
    \item Sposta il cursore alla riga successiva.
    \item Restituisce \texttt{true} se c'è una riga valida, \texttt{false} se siamo arrivati alla fine.
\end{enumerate}

\begin{lstlisting}[language=Java, caption={Iterazione standard su ResultSet}]
// Il cursore parte "Before First"
try (ResultSet rs = stmt.executeQuery("SELECT nome, eta FROM utenti")) {
    
    while (rs.next()) {
        // Ora il cursore è su una riga valida
        
        // Estrazione per Nome Colonna (Consigliato per leggibilità)
        String nome = rs.getString("nome");
        
        // Estrazione per Indice (1-based, leggermente più performante)
        int eta = rs.getInt(2);
        
        System.out.println(nome + " ha " + eta + " anni");
    }
}
\end{lstlisting}

\subsection{La trappola dei NULL: Primitivi vs Wrapper}
Una delle fonti di bug più insidiose in JDBC riguarda la lettura di colonne numeriche (INT, FLOAT) che permettono valori \texttt{NULL} nel database.

In Java, i tipi primitivi (\texttt{int}, \texttt{double}) \textbf{non possono essere null}.
Se nel DB hai una colonna \texttt{eta = NULL} e chiami \texttt{rs.getInt("eta")}, JDBC non lancerà un'eccezione (come farebbe un NullPointerException), ma restituirà silenziosamente il valore di default: \textbf{0}.

Questo crea una pericolosa ambiguità: quel valore \textbf{0} significa che l'utente è un neonato (età 0) o che non ha inserito l'età (NULL)?

\subsubsection{Soluzione 1: Il controllo manuale (Legacy)}
Il metodo classico prevede di controllare subito dopo la lettura se l'ultimo valore letto era nullo.

\begin{lstlisting}[language=Java, caption={Gestione manuale con wasNull()}]
int valoreLetto = rs.getInt("eta"); // Restituisce 0 se NULL

Integer eta; // Usiamo il Wrapper per permettere il null

if (rs.wasNull()) {
    eta = null; // Era davvero NULL nel DB
} else {
    eta = valoreLetto; // Era davvero 0 (neonato)
}
\end{lstlisting}

\subsubsection{Soluzione 2: Usare i Wrapper e getObject (Consigliata)}
Da Java 7 in poi, possiamo evitare questo codice verboso chiedendo al ResultSet di restituirci direttamente un oggetto \textbf{Wrapper}. Il metodo \texttt{getObject} con il tipo specificato gestisce automaticamente la conversione: se il DB ha \texttt{NULL}, restituisce \texttt{null}; altrimenti restituisce l'oggetto popolato.

\begin{lstlisting}[language=Java, caption={Lettura diretta tramite Wrapper}]
// Restituisce un Integer (che può essere null), non un int
Integer eta = rs.getObject("eta", Integer.class);

if (eta == null) {
    System.out.println("Età non specificata");
} else {
    System.out.println("Età: " + eta);
}
\end{lstlisting}

\textbf{Regola d'oro:} Se una colonna del database è \texttt{nullable}, mappala sempre nel codice Java con la corrispondente classe Wrapper (\texttt{Integer}, \texttt{Long}, \texttt{Double}, \texttt{Boolean}) invece del primitivo.

\begin{deepdive}{ResultSet Scrollabili e Aggiornabili}
Di default, un ResultSet è \textbf{Forward-Only} (puoi solo andare avanti) e \textbf{Read-Only}.
Tuttavia, configurando lo Statement, possiamo creare ResultSet avanzati:

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
Statement stmt = conn.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE, // Possiamo fare rs.previous()
    ResultSet.CONCUR_UPDATABLE         // Possiamo modificare i dati
);
\end{lstlisting}

Con un ResultSet aggiornabile, possiamo modificare il DB senza scrivere SQL:
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
rs.absolute(5);          // Vai alla riga 5
rs.updateString("nome", "Luigi"); // Modifica colonna
rs.updateRow();          // Commit della riga
\end{lstlisting}
\textbf{Nota:} Queste funzionalità sono usate raramente nelle web app moderne per via dell'overhead di memoria.
\end{deepdive}

\subsection{L'evoluzione: Il RowSet (Disconnected)}

Abbiamo detto che il \texttt{ResultSet} è legato a doppio filo alla connessione: se chiudi la \texttt{Connection}, il ResultSet muore e non puoi più leggere i dati. Questo è un problema se vogliamo passare i dati a un'altra parte dell'applicazione (es. una GUI Swing o una pagina web) senza tenere il database bloccato.

Qui entra in gioco il \texttt{javax.sql.RowSet}, e in particolare la sua implementazione più famosa: il CachedRowSet.

Il \texttt{CachedRowSet} funziona in modalità Disconnected (Disconnessa):
\begin{enumerate}
\item Si connette al DB ed esegue la query.
\item Copia \textbf{tutti} i dati in memoria (RAM).
\item Chiude immediatamente la connessione al DB.
\item Permette all'applicazione di navigare, modificare e scorrere i dati offline.
\end{enumerate}

\begin{lstlisting}[language=Java, caption={Uso di CachedRowSet (Disconnesso)}]
// 1. Creazione tramite Factory (Java 7+)
RowSetFactory factory = RowSetProvider.newFactory();
CachedRowSet crs = factory.createCachedRowSet();

// 2. Configurazione (contiene al suo interno i dati di connessione)
crs.setUrl("jdbc:mysql://localhost:3306/mydb");
crs.setUsername("user");
crs.setPassword("pass");
crs.setCommand("SELECT * FROM utenti WHERE eta > ?");
crs.setInt(1, 18);

// 3. Esecuzione: Scarica i dati e CHIUDE la connessione fisica
crs.execute();

// --- Qui la connessione al DB è già chiusa! ---

// Possiamo passare 'crs' in giro per l'app
while (crs.next()) {
System.out.println(crs.getString("nome"));
}
\end{lstlisting}

\begin{deepdive}{Perché oggi si usano i DTO e non i RowSet?}
Se il RowSet sembra così comodo (dati in memoria, scollegati dal DB), perché nelle applicazioni moderne (Spring/Hibernate) usiamo le \texttt{List<User>} (DTO/Entity) invece dei RowSet?

\textbf{Risposta:}
\begin{itemize}
\item \textbf{Performance:} Il \texttt{RowSet} è un oggetto pesante e complesso, pieno di metadati JDBC. Una \texttt{List} di oggetti Java puri (POJO) è molto più leggera per la RAM.
\item \textbf{Astrazione:} Il \texttt{RowSet} costringe il resto dell'applicazione a conoscere concetti SQL (eccezioni \texttt{SQLException}). Convertendo in Oggetti/DTO, nascondiamo completamente la natura del database al resto del codice.
\end{itemize}
\end{deepdive}

\begin{interview}{ResultSet vs RowSet vs List}
\textbf{Domanda:} "Perché spesso convertiamo subito il ResultSet in una \texttt{List<Oggetto>}?"

\textbf{Risposta:}
Il \texttt{ResultSet} è legato alla connessione fisica.
\begin{enumerate}
    \item Finché scorri il ResultSet, la \texttt{Connection} deve restare occupata. Non puoi passarlo alla View (HTML/JSP) per il rendering, perché la connessione sarebbe già chiusa o bloccherebbe il pool.
    \item Trasformando i dati in una \texttt{List} di oggetti (DTO o Entity), ci "disaccoppiamo" dal database (Pattern DAO/Repository) e possiamo chiudere la connessione immediatamente.
\end{enumerate}
\end{interview}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Esempio Pratico: Architettura JDBC Pura}

In questo capitolo non c'è teoria. Vediamo come si scrive un livello di accesso ai dati (DAO Pattern) robusto, sicuro (No SQL Injection) e corretto nella gestione delle risorse, usando solo Java standard.

L'architettura è divisa in 3 file:
\begin{enumerate}
    \item \textbf{User}: Il DTO (Data Transfer Object) che rappresenta il dato.
    \item \textbf{DatabaseConnection}: La classe responsabile di fornire la connessione.
    \item \textbf{UserRepository}: La classe che contiene la logica SQL.
\end{enumerate}

\section{1. Il Modello (DTO)}

Una semplice classe per trasportare i dati dal DB all'applicazione.

\begin{lstlisting}[language=Java, caption=User.java (POJO)]
public class User {
    private Long id;
    private String username;
    private String email;

    // Costruttore vuoto (spesso richiesto da librerie/framework)
    public User() {}

    // Costruttore completo
    public User(Long id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }

    // Getters e Setters (Omessi per brevità)
    // toString() per loggare l'oggetto
    @Override
    public String toString() {
        return "User{id=" + id + ", username='" + username + "'}";
    }
}
\end{lstlisting}

\section{2. Gestione Connessione (Factory)}

Centralizziamo i parametri di connessione. In un progetto reale, questi valori verrebbero letti da un file di properties o variabili d'ambiente, mai hardcoded.

\begin{lstlisting}[language=Java, caption=DatabaseFactory.java]
public class DatabaseFactory {
    
    // Parametri di connessione (In prod usare variabili d'ambiente!)
    private static final String URL = "jdbc:postgresql://localhost:5432/myapp";
    private static final String USER = "admin";
    private static final String PASS = "secret";

    // Metodo statico per ottenere una nuova connessione
    // NOTA: In produzione qui si userebbe un Connection Pool (HikariCP)
    // invece di DriverManager per performance.
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(URL, USER, PASS);
    }
}
\end{lstlisting}

\section{3. Il Repository (Lettura Sicura)}

Ecco come eseguire una \texttt{SELECT} prevenendo SQL Injection e memory leak.

\begin{lstlisting}[language=Java, caption=UserRepository.java (Metodo FindById)]
public class UserRepository {

    // QUERY COSTANTE: Usiamo '?' come placeholder.
    // MAI concatenare stringhe qui!
    private static final String SQL_FIND_BY_ID = 
        "SELECT id, username, email FROM users WHERE id = ?";

    public Optional<User> findById(Long id) {
        // TRY-WITH-RESOURCES (Java 7+)
        // Apre le risorse e le chiude AUTOMATICAMENTE alla fine del blocco.
        // Ordine di chiusura inverso: ResultSet -> PreparedStatement -> Connection.
        try (
            Connection conn = DatabaseFactory.getConnection();
            PreparedStatement ps = conn.prepareStatement(SQL_FIND_BY_ID)
        ) {
            
            // 1. Binding del parametro (Sostituisce il ? con l'ID)
            // Gestisce automaticamente l'escaping (Sicurezza SQL Injection)
            ps.setLong(1, id);

            // 2. Esecuzione Query
            try (ResultSet rs = ps.executeQuery()) {
                
                // 3. Mapping: C'è un risultato?
                if (rs.next()) {
                    User user = new User();
                    user.setId(rs.getLong("id"));
                    user.setUsername(rs.getString("username"));
                    user.setEmail(rs.getString("email"));
                    
                    // Restituiamo un Optional pieno
                    return Optional.of(user);
                }
            }
        } catch (SQLException e) {
            // Loggare sempre l'errore!
            System.err.println("Errore DB: " + e.getMessage());
            // Rilanciare come RuntimeException o eccezione custom
            throw new RuntimeException("Errore durante la ricerca utente", e);
        }

        // Nessun utente trovato
        return Optional.empty();
    }
}
\end{lstlisting}

\section{4. Transazioni (Scrittura Atomica)}

Esempio avanzato: inserimento di un utente e, contestualmente, di un log di audit. Se uno fallisce, falliscono entrambi (Rollback).

\begin{lstlisting}[language=Java, caption=UserRepository.java (Transazione)]
    private static final String SQL_INSERT_USER = 
        "INSERT INTO users (username, email) VALUES (?, ?)";
    
    private static final String SQL_INSERT_LOG = 
        "INSERT INTO audit_log (action, user_data) VALUES (?, ?)";

    public void createUserWithAudit(User user) {
        Connection conn = null; // Dichiarata fuori per gestirla nel finally
        
        try {
            conn = DatabaseFactory.getConnection();
            
            // 1. DISABILITIAMO l'AutoCommit (Inizio Transazione)
            conn.setAutoCommit(false);

            // --- STEP A: Inserimento Utente ---
            // RETURN_GENERATED_KEYS serve per recuperare l'ID autoincrementato
            try (PreparedStatement psUser = 
                    conn.prepareStatement(SQL_INSERT_USER, Statement.RETURN_GENERATED_KEYS)) {
                
                psUser.setString(1, user.getUsername());
                psUser.setString(2, user.getEmail());
                psUser.executeUpdate();
                
                // Recuperiamo l'ID generato dal DB
                try (ResultSet rs = psUser.getGeneratedKeys()) {
                    if (rs.next()) {
                        user.setId(rs.getLong(1));
                    }
                }
            }

            // --- STEP B: Inserimento Log (Audit) ---
            try (PreparedStatement psLog = conn.prepareStatement(SQL_INSERT_LOG)) {
                psLog.setString(1, "CREATE_USER");
                psLog.setString(2, "Created user with ID: " + user.getId());
                psLog.executeUpdate();
            }

            // 3. COMMIT: Se siamo qui, tutto è andato bene. Rendiamo le modifiche permanenti.
            conn.commit();
            System.out.println("Transazione completata con successo.");

        } catch (SQLException e) {
            // 4. ROLLBACK: Qualcosa è andato storto. Annulliamo TUTTO.
            if (conn != null) {
                try {
                    System.err.println("Rollback in corso...");
                    conn.rollback();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
            throw new RuntimeException("Transazione fallita", e);
        } finally {
            // 5. Ripristino stato e chiusura
            if (conn != null) {
                try {
                    conn.setAutoCommit(true); // Buona norma ripristinare il default
                    conn.close();
                } catch (SQLException e) { e.printStackTrace(); }
            }
        }
    }
\end{lstlisting}

\section{5. Esecuzione: Il Main}

Infine, mettiamo tutto insieme.
Questo `main` simula quello che succederebbe in un Controller o in un Service layer: istanzia il repository, crea un oggetto, lo salva (sfruttando la transazione) e poi lo rilegge per conferma.

\begin{lstlisting}[language=Java, caption=MainApp.java (Entry Point)]
public class MainApp {

    public static void main(String[] args) {
        // 1. Istanziamo il Repository
        // (In un'app Spring questo sarebbe un @Autowired, qui è manuale)
        UserRepository userRepo = new UserRepository();

        System.out.println("--- AVVIO DIMOSTRAZIONE JDBC ---");

        // --- FASE 1: Creazione (Scrittura Transazionale) ---
        User nuovoUtente = new User(null, "MarioRossi", "mario@example.com");

        try {
            System.out.println("Salvataggio utente in corso...");
            
            // Chiama il metodo transazionale (User + Audit Log)
            userRepo.createUserWithAudit(nuovoUtente);
            
            // Se arriviamo qui, il commit è avvenuto.
            // L'ID è stato popolato grazie a RETURN_GENERATED_KEYS nel repository.
            System.out.println("Utente salvato! ID assegnato dal DB: " + nuovoUtente.getId());

        } catch (RuntimeException e) {
            System.err.println("Errore critico nel salvataggio: " + e.getMessage());
            // In caso di errore, il main termina qui.
            return;
        }

        // --- FASE 2: Recupero (Lettura Sicura) ---
        System.out.println("\nVerifica lettura dal database...");
        
        Long idDaCercare = nuovoUtente.getId();
        
        // Il metodo restituisce Optional, obbligandoci a gestire il caso "Not Found"
        Optional<User> utenteLetto = userRepo.findById(idDaCercare);

        // Uso funzionale di Optional (Java 9+)
        utenteLetto.ifPresentOrElse(
            (u) -> System.out.println("Trovato: " + u.toString()),
            () -> System.out.println("ERRORE: Utente con ID " + idDaCercare + " non trovato!")
        );
        
        System.out.println("--- FINE DIMOSTRAZIONE ---");
    }
}
\end{lstlisting}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Hibernate Internals: Architettura e Lifecycle}

Molti sviluppatori usano Hibernate come una "scatola nera": annotano le classi, chiamano \texttt{save()} e sperano che funzioni.
Questo approccio funziona finché non incontri una \texttt{LazyInitializationException}, un \texttt{NonUniqueObjectException} o un aggiornamento involontario sul database.

Per padroneggiare Hibernate, bisogna smettere di pensare in termini di "Query SQL" e iniziare a pensare in termini di \textbf{Gestione degli Stati}.

\section{JPA vs Hibernate: Facciamo ordine}
Prima di entrare nel tecnico, chiariamo la terminologia.

\begin{interview}{Differenza tra JPA e Hibernate}
\begin{itemize}
    \item \textbf{JPA (Java Persistence API):} È la \textbf{Specifica}. È un documento PDF che definisce le interfacce (es. \texttt{EntityManager}) e le annotazioni (es. \texttt{@Entity}). Non fa nulla da solo.
    \item \textbf{Hibernate:} È l'\textbf{Implementazione}. È il motore che scarichi nel progetto. Rispetta la specifica JPA ma aggiunge funzionalità proprietarie (es. la L2 Cache avanzata).
\end{itemize}
\textbf{Analogia:} JPA sta a Hibernate come l'interfaccia \texttt{List} sta alla classe \texttt{ArrayList}.
\end{interview}

\section{L'EntityManager e il Persistence Context}
In JDBC, l'oggetto principale era la \texttt{Connection}. In JPA, il protagonista è l'\textbf{EntityManager}.

L'EntityManager non è solo un passacarte verso il DB. Gestisce il \textbf{Persistence Context}, che agisce come una \textbf{Cache di Primo Livello (L1)}.

\begin{center}
\begin{tikzpicture}[
    node distance=2cm, auto, thick,
    % Stili robusti per evitare crash di compilazione
    box/.style={rectangle, draw=deepblue, thick, fill=white, minimum height=2cm, text width=3.5cm, align=center},
    db/.style={cylinder, draw=black, aspect=0.25, fill=gray!20, minimum height=1.5cm, minimum width=1.5cm, shape border rotate=90, align=center},
    txt/.style={rectangle, text width=2.5cm, align=center}
]

    % 1. Contesto
    \node[box] (context) {\textbf{Persistence Context}\\(L1 Cache)};
    
    % 2. Java World
    \node[txt, left of=context, node distance=5cm] (java) {Oggetto Java\\(Heap Memory)};
    
    % 3. DB World
    \node[db, right of=context, node distance=5cm] (database) {Database};

    % Frecce
    \draw[->] (java) -- node[above, font=\scriptsize] {persist()} (context);
	    \draw[->] (context) -- node[above = 1cm, font=\scriptsize] {Dirty Checking} (context);
    \draw[->] (context) -- node[above, font=\scriptsize] {flush() SQL} (database);
    \draw[->, dashed] (database) -- node[below, font=\scriptsize] {find()} (context);

\end{tikzpicture}
\end{center}

\section{Il Concetto di Sessione e il Persistence Context}

Al cuore di Hibernate (e di JPA) c'è un concetto che funge da intermediario tra la tua applicazione Java e il Database fisico: la \textbf{Sessione} (in Hibernate chiamata \texttt{Session}, in JPA standard \texttt{EntityManager}).

La Sessione non è solo un wrapper intorno alla connessione JDBC. È un ambiente intelligente che traccia gli oggetti caricati dal database. Questo ambiente di tracciamento si chiama \textbf{Persistence Context}.

\subsection{EntityManager vs Session}
Spesso si usano i termini in modo intercambiabile, ma c'è una gerarchia:
\begin{itemize}
    \item \textbf{Session (Hibernate):} È l'interfaccia nativa e proprietaria di Hibernate. Offre metodi specifici (es. \texttt{save()}, \texttt{update()}).
    \item \textbf{EntityManager (JPA):} È l'interfaccia standard definita da Java. Spring Boot usa questa. Sotto il cofano, l'EntityManager "avvolge" la Session di Hibernate.
\end{itemize}

\subsection{Entity Lifecycle: La Macchina a Stati}
In JPA, un oggetto non è semplicemente "nel DB" o "non nel DB". Vive in uno di 4 stati ben precisi. Capire questi stati è la differenza tra un Junior e un Senior.

\begin{center}
\begin{tikzpicture}[node distance=4cm, auto, thick,
    state/.style={rectangle, draw=deepblue, thick, fill=white, text width=2.5cm, align=center, rounded corners, minimum height=1.5cm},
    arrow/.style={->, >=stealth, thick, deepblue}
]

    % Nodi Stati
    \node[state] (transient) {\textbf{Transient}\\(Effimero)};
    \node[state, right of=transient] (managed) {\textbf{Managed}\\(Persistent)};
    \node[state, below of=managed] (detached) {\textbf{Detached}\\(Staccato)};
    \node[state, right of=managed] (removed) {\textbf{Removed}\\(Cancellato)};

    % Transizioni
    \draw[arrow] (transient) -- node[above, font=\scriptsize] {persist()} (managed);
    \draw[arrow] (managed) -- node[right, font=\scriptsize] {close() / clear()} (detached);
    \draw[arrow] (detached) to[bend left] node[left, font=\scriptsize] {merge()} (managed);
    \draw[arrow] (managed) -- node[above, font=\scriptsize] {remove()} (removed);
    \draw[arrow] (managed) to[loop above] node[font=\scriptsize] {get() / find()} (managed);

\end{tikzpicture}
\end{center}

\subsubsection{1. Transient (Effimero)}
L'oggetto è appena stato creato con \texttt{new}.
\begin{itemize}
    \item Vive solo nella memoria Heap di Java.
    \item Hibernate non sa che esiste.
    \item Non ha un ID (o è null).
    \item Se il programma termina, l'oggetto svanisce.
\end{itemize}

\subsubsection{2. Managed (Gestito)}
L'oggetto è "sotto sorveglianza" nel Persistence Context.
\begin{itemize}
    \item Ha un ID database.
    \item Ogni modifica ai suoi campi viene tracciata (Dirty Checking).
    \item Al \texttt{commit()}, le modifiche verranno sincronizzate col DB.
\end{itemize}

\subsubsection{3. Detached (Staccato)}
È l'incubo degli sviluppatori. L'oggetto ha un ID (quindi rappresenta una riga DB), ma l'\texttt{EntityManager} è stato chiuso o l'oggetto è stato espulso.
\begin{itemize}
    \item Le modifiche ai set non vengono salvate.
    \item Se provi ad accedere a collezioni Lazy, ottieni \texttt{LazyInitializationException}.
\end{itemize}

\subsubsection{4. Removed}
L'oggetto è marcato per la cancellazione. La \texttt{DELETE} SQL partirà al prossimo flush.

\section{Le Transizioni Critiche}

\subsubsection{persist() vs merge()}
\begin{itemize}
    \item \textbf{persist(entity):} Prende un oggetto \textit{Transient} e lo rende \textit{Managed}. Se l'oggetto aveva già un ID generato manualmente, potrebbe lanciare eccezione.
    \item \textbf{merge(entity):} Serve per salvare oggetti \textit{Detached}.
    \textbf{Attenzione:} \texttt{merge} non "riattacca" l'oggetto che gli passi. Ne crea una copia, copia i dati, salva la copia e restituisce la copia.
\end{itemize}

\begin{lstlisting}[language=Java, title={La trappola del merge}]
User u = new User("Mario");
u.setId(1L); // Detached (ha ID ma non è in sessione)

// SBAGLIATO
em.merge(u);
u.setName("Luigi"); // Modifica PERSA! 'u' è ancora Detached.

// CORRETTO
User managedU = em.merge(u);
managedU.setName("Luigi"); // Modifica salvata.
\end{lstlisting}

\subsection{Il Dirty Checking: L'Update Automatico}
Questa è la funzionalità più potente e pericolosa di Hibernate.

Quando un oggetto è \textbf{Managed}, Hibernate mantiene uno \textbf{Snapshot} (una copia segreta) dei suoi dati originali al momento del caricamento.
Quando fai \texttt{flush()} (o commit), Hibernate confronta l'oggetto attuale con lo Snapshot.

Se trova differenze, lancia l'\texttt{UPDATE} SQL automaticamente. \textbf{Non serve chiamare save()!}

\begin{lstlisting}[language=Java, title={Dirty Checking in Azione}]
@Transactional
public void updatePassword(Long userId, String newPass) {
    // 1. Caricamento (Diventa Managed)
    User u = repository.findById(userId).orElseThrow();
    
    // 2. Modifica dello stato
    u.setPassword(newPass);
    
    // 3. Fine Metodo -> Commit Automatico
    // Hibernate vede la differenza e fa UPDATE users SET password=...
}
\end{lstlisting}

\begin{interview}{Insidia del Dirty Checking}
\textbf{Domanda:} Ho caricato un'entità solo per calcolare un dato e stamparlo a video, ho modificato un campo ma non volevo salvarlo. Perché il DB è cambiato?

\textbf{Risposta:} Perché l'entità era \textbf{Managed} e la transazione ha fatto commit.
\textbf{Soluzione:} Usa \texttt{em.detach(entity)} se vuoi modificarlo senza salvare, oppure usa DTO (che non sono managed), oppure usa transazioni \texttt{readOnly=true}.
\end{interview}


\subsection{Sessione e Transazioni (Unit of Work)}
La Sessione è progettata per essere leggera e "usa e getta". Il pattern tipico è \textbf{Session-per-Request} (o Session-per-Transaction).
\begin{enumerate}
    \item Apre la Sessione (e la transazione).
    \item Esegue le operazioni di business.
    \item Committa e chiude la Sessione.
\end{enumerate}

\begin{interview}{La LazyInitializationException}
    \textbf{Domanda:} "Cos'è la \texttt{LazyInitializationException} e perché avviene?"
    
    \textbf{Risposta:} Avviene quando tenti di accedere a una collezione \textit{Lazy} (es. \texttt{user.getOrders()}) su un oggetto che è in stato \textbf{Detached}.
    
    \textbf{Scenario:}
    \begin{itemize}
        \item Il Service carica un \texttt{User} (Sessione aperta).
        \item Il Service restituisce l'oggetto al Controller (la Transazione/Sessione si chiude qui).
        \item Il Controller (o la View HTML) prova a chiamare \texttt{user.getOrders()}.
        \item Poiché la lista ordini non era stata caricata e la Sessione (il ponte col DB) è ormai chiusa, Hibernate non può eseguire la query e lancia l'eccezione.
    \end{itemize}
\end{interview}

\subsection{Flush: Sincronizzazione con il DB}
Le modifiche fatte agli oggetti Persistent non vengono inviate al Database istantaneamente. Vengono accumulate in memoria nel Persistence Context.
Il processo di invio fisico delle query SQL (INSERT/UPDATE/DELETE) si chiama \textbf{Flush}.

Il Flush avviene di default:
\begin{itemize}
    \item Prima del commit della transazione.
    \item Prima dell'esecuzione di una query JPQL/SQL (per garantire che la query legga dati aggiornati).
\end{itemize}

\section{Il Caching in Hibernate: Livello 1 e Livello 2}

Uno dei colli di bottiglia principali nelle applicazioni enterprise è l'accesso al database (I/O). Hibernate cerca di mitigare questo problema attraverso un meccanismo di \textbf{Caching} su due livelli, il cui obiettivo è ridurre il numero di query SQL inviate fisicamente al DB.

\subsection{Level 1 Cache (L1): La Cache di Sessione}
La Cache di primo livello è associata all'oggetto \texttt{Session} (o \texttt{EntityManager} in JPA).
Ha le seguenti caratteristiche:
\begin{itemize}
    \item \textbf{Obbligatoria:} È abilitata di default e non può essere disabilitata completamente.
    \item \textbf{Scope Transazionale:} Nasce quando apri una transazione (o sessione) e muore quando la chiudi (commit/rollback).
    \item \textbf{Visibilità:} I dati caricati nella cache L1 sono visibili \textit{solo} al thread che possiede quella sessione.
\end{itemize}

\textbf{Come funziona:}
Quando chiedi un'entità per ID (\texttt{findById}), Hibernate guarda prima nella L1 Cache (che è essenzialmente una Map in memoria).
\begin{enumerate}
    \item Se l'oggetto c'è, lo restituisce immediatamente (0 query).
    \item Se non c'è, fa la query al DB, salva l'oggetto in L1 e lo restituisce.
\end{enumerate}

\begin{lstlisting}[language=Java, caption=Funzionamento L1 Cache]
// Esempio in una singola transazione
@Transactional
public void demoL1() {
    // 1. Prima chiamata: Hibernate esegue la SELECT sul DB
    User u1 = entityManager.find(User.class, 1L);
    
    // 2. Seconda chiamata: Hibernate trova l'oggetto in L1 Cache.
    // NESSUNA QUERY viene inviata al DB.
    User u2 = entityManager.find(User.class, 1L);
    
    System.out.println(u1 == u2); // TRUE: È lo stesso identico oggetto in memoria
}
\end{lstlisting}

\begin{interview}{Posso disabilitare la cache L1?}
    \textbf{Domanda:} "La cache L1 mi sta consumando troppa memoria durante un batch job massivo. Posso spegnerla?"
    
    \textbf{Risposta:} Non puoi disabilitarla globalmente, perché è intrinseca al funzionamento di Hibernate (garantisce che all'interno di una transazione, l'identità dell'oggetto sia unica).
    Tuttavia, puoi gestirla manualmente per evitare \texttt{OutOfMemoryError}:
    \begin{itemize}
        \item \texttt{entityManager.clear()}: Svuota completamente la cache L1 (stacca tutti gli oggetti).
        \item \texttt{entityManager.detach(entity)}: Rimuove un singolo oggetto dalla cache.
    \end{itemize}
\end{interview}

\subsection{Level 2 Cache (L2): La Cache di Processo}
La Cache di secondo livello è associata alla \texttt{SessionFactory}.
Ha le seguenti caratteristiche:
\begin{itemize}
    \item \textbf{Opzionale:} Di default è disabilitata. Va configurata esplicitamente.
    \item \textbf{Scope Globale:} I dati sono condivisi tra \textit{tutte} le sessioni/transazioni dell'applicazione.
    \item \textbf{Provider Esterno:} Hibernate non implementa la cache L2 da solo, ma si appoggia a provider esterni come \textbf{EhCache}, \textbf{Infinispan}, \textbf{Redis} o \textbf{Caffeine}.
\end{itemize}

\textbf{Quando usarla?}
La L2 Cache è ideale per dati "Read-Mostly" (letti spesso, modificati raramente), come liste di regioni, categorie prodotti o configurazioni. Non è adatta per dati che cambiano freneticamente, a causa dell'overhead di invalidazione e sincronizzazione.

\subsection{Strategie di Concorrenza della Cache L2}
Quando più transazioni accedono alla Cache L2, bisogna decidere come gestire la concorrenza. Hibernate offre diverse strategie:

\begin{itemize}
    \item \textbf{READ\_ONLY:} La più veloce. Usala se i dati non cambiano \textbf{mai} (es. Giorni della settimana). Se provi a modificare l'entità, Hibernate lancia un'eccezione.
    \item \textbf{NONSTRICT\_READ\_WRITE:} Veloce ma non garantisce consistenza assoluta. Se due thread modificano lo stesso dato, c'è una piccola finestra in cui si potrebbero leggere dati vecchi. Buona per dati che cambiano di rado (es. Articoli blog).
    \item \textbf{READ\_WRITE:} Usa lock per garantire una forte consistenza (Read Committed). Più lenta della precedente.
    \item \textbf{TRANSACTIONAL:} Supporta transazioni XA complete (molto costosa, supportata solo da alcuni provider come EhCache).
\end{itemize}

\subsection{Confronto Rapido L1 vs L2}

\begin{table}[h]
\centering
\rowcolors{2}{gray!10}{white}
\renewcommand{\arraystretch}{1.3}
\begin{tabularx}{\textwidth}{|l|X|X|}
\hline
\rowcolor{deepblue} \textbf{\textcolor{white}{Caratteristica}} & \textbf{\textcolor{white}{Level 1 (L1)}} & \textbf{\textcolor{white}{Level 2 (L2)}} \\
\hline
\textbf{Scope} & Sessione (Transaction). & SessionFactory (Applicazione). \\
\hline
\textbf{Attivazione} & Default (Sempre attiva). & Opzionale (Va configurata). \\
\hline
\textbf{Condivisione} & Privata per Thread. & Condivisa tra tutti gli utenti. \\
\hline
\textbf{Contenuto} & Oggetti Java veri e propri. & Dati "disidratati" (array di valori/stringhe). \\
\hline
\textbf{Provider} & Interno a Hibernate. & Esterno (Redis, EhCache, Hazelcast). \\
\hline
\end{tabularx}
\end{table}

\begin{interview}{Query Cache: Un terzo livello?}
    \textbf{Domanda:} "Se attivo la L2 Cache, le query JPQL vengono cachate automaticamente?"
    
    \textbf{Risposta:} \textbf{NO.}
    La L2 Cache standard funziona solo per le lookup per ID (\texttt{findById}).
    Se esegui \texttt{SELECT p FROM Product p WHERE p.price > 100}, Hibernate eseguirà sempre la query SQL.
    
    Per cachare i risultati delle query complesse, bisogna attivare esplicitamente la \textbf{Query Cache} (\texttt{hibernate.cache.use\_query\_cache=true}) e annotare la singola query come "cacheable".
    \textit{Attenzione:} La Query Cache è spesso controproducente se le tabelle coinvolte vengono aggiornate frequentemente (perché la cache viene invalidata a ogni update sulla tabella).
\end{interview}

\begin{deepdive}{Perché la L1 Cache è importante?}
La L1 Cache garantisce l'\textbf{Identity Map Pattern}.
Se nella stessa transazione chiedi due volte l'utente con ID 1:
\begin{lstlisting}[language=Java]
User u1 = em.find(User.class, 1L); // Select SQL
User u2 = em.find(User.class, 1L); // Nessuna SQL!
System.out.println(u1 == u2); // TRUE: Sono lo stesso identico oggetto in memoria
\end{lstlisting}
Senza questo meccanismo, avresti due oggetti Java diversi che rappresentano la stessa riga DB, creando conflitti di dati.
\end{deepdive}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Advanced Mapping Strategy}

Se il Capitolo 1 riguardava il "Motore" (EntityManager), questo riguarda la "Carrozzeria".
Mappare oggetti Java su tabelle relazionali è un'operazione piena di compromessi. Un mapping sbagliato può rendere il database inconsistente o le query disastrosamente lente.

In questo capitolo definiremo il "Contratto" tra Java e SQL, esplorando le relazioni e le strategie di ereditarietà.

\section{Il Contratto Entity-Database}

Non basta annotare una classe con \texttt{@Entity}. Bisogna definire con precisione i vincoli.

\subsection{Strategie di Generazione delle Chiavi Primarie (Primary Keys)}

Per decenni, lo standard è stato utilizzare un numero intero progressivo (\texttt{Long id}) che si incrementa da solo (1, 2, 3...). Sebbene sia semplice e performante, questa scelta comporta dei rischi che un architetto moderno deve considerare:

\begin{itemize}
    \item \textbf{Sicurezza e Business Intelligence:} Se mi iscrivo al tuo sito e ottengo l'ID 1000, e il giorno dopo un mio amico si iscrive e ottiene 1050, so esattamente che hai avuto 50 nuovi utenti. È un'informazione riservata che stai esponendo pubblicamente nell'URL (es. \texttt{/users/1000}).
    \item \textbf{Merge dei Dati:} Se domani devi unire due database diversi (es. acquisizione aziendale), avrai sicuramente conflitti perché l'ID "1" esiste in entrambi i database per persone diverse.
\end{itemize}

Hibernate (JPA) offre diverse strategie per generare le chiavi, configurabili tramite l'annotazione \texttt{@GeneratedValue}. Vediamole nel dettaglio:

\subsubsection{1. GenerationType.IDENTITY (Auto-Increment)}
È la strategia classica di MySQL (\texttt{AUTO\_INCREMENT}). Il database assegna l'ID \textbf{dopo} aver inserito la riga.
\begin{itemize}
    \item \textbf{Come funziona:} Hibernate invia la \texttt{INSERT}, il DB salva, genera l'ID e lo restituisce a Hibernate.
    \item \textbf{Controindicazione (Importante):} Disabilita il \textbf{Batch Insert}. Poiché Hibernate deve conoscere l'ID dell'oggetto \textit{prima} di poterlo associare ad altri oggetti in memoria, non può raggruppare 100 insert in una volta sola. Deve farle una per una.
\end{itemize}

\subsubsection{2. GenerationType.SEQUENCE (Lo Standard Enterprise)}
È la strategia preferita per PostgreSQL e Oracle.
\begin{itemize}
    \item \textbf{Come funziona:} Il database mantiene un contatore separato (Sequence). Hibernate chiede alla sequenza: "Dammi i prossimi 50 ID". Il DB risponde. Hibernate assegna gli ID agli oggetti in memoria e poi fa le INSERT tutte insieme.
    \item \textbf{Vantaggio:} Permette il \textbf{Batch Insert} ed è molto performante.
\end{itemize}

\subsubsection{3. GenerationType.UUID (Lo Standard Moderno)}
L'ID non è più un numero, ma una stringa esadecimale a 128-bit unica al mondo (es. \texttt{550e8400-e29b-41d4-a716-446655440000}).
\begin{itemize}
    \item \textbf{Vantaggi:} Impossibile da indovinare (sicurezza), unico globalmente (merge facile), generabile da Java senza chiedere al Database.
    \item \textbf{Svantaggi:} Occupa più spazio su disco rispetto a un numero (16 byte vs 8 byte) e indicizzarlo è leggermente più lento.
\end{itemize}

\begin{lstlisting}[language=Java, title={Esempio completo di Mapping con UUID}]
@Entity
@Table(name = "users")
public class User {

    // Hibernate 6 genera automaticamente UUID ottimizzati (RFC 4122)
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    // ESEMPIO DI ALTRI VINCOLI UTILI SULLE COLONNE
    
    // nullable=false: Obbligatorio (NOT NULL)
    // unique=true: Non possono esserci due username uguali (UNIQUE INDEX)
    // updatable=false: Una volta creato, non può essere modificato
    @Column(nullable = false, unique = true, updatable = false)
    private String username;

    // precision=10, scale=2: FONDAMENTALE per i soldi (BigDecimal).
    // Significa: 10 cifre totali, di cui 2 decimali (es. 12345678.99).
    // Se lo ometti, il DB potrebbe arrotondare e farti perdere centesimi!
    @Column(precision = 10, scale = 2)
    private BigDecimal salary;
}
\end{lstlisting}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Strategia}} & \textcolor{white}{\textbf{Quando usarla}} \\
    \hline
    \texttt{IDENTITY} & Progetti semplici, DB MySQL, quando non serve il Batch Insert. \\
    \hline
    \texttt{SEQUENCE} & Progetti Enterprise su PostgreSQL/Oracle con alti volumi di scrittura. \\
    \hline
    \texttt{UUID} & Microservizi, sistemi distribuiti, o quando la sicurezza dell'ID è prioritaria. \\
    \hline
\end{tabularx}
\end{center}

\section{Relazioni Fondamentali: Owner vs Inverse}

Questa è la regola numero uno di Hibernate. Nelle relazioni bidirezionali, i due oggetti si puntano a vicenda, ma \textbf{solo uno comanda la Foreign Key}.

\begin{center}
\begin{tikzpicture}[
    node distance=1cm, auto, thick,
    % Stili sicuri
    box/.style={rectangle, draw=deepblue, fill=white, minimum height=1.5cm, text width=4cm, align=center},
    note/.style={rectangle, draw=none, text width=3cm, align=center, font=\scriptsize}
]
    % Nodi
    \node[box] (emp) {\textbf{Employee}\\(Owner Side)};
    \node[box, right=3cm of emp] (dept) {\textbf{Department}\\(Inverse Side)};

    % Frecce
    \draw[->, red, dashed] (emp) -- node[above] {\texttt{@JoinColumn}} node[below] {Possiede FK} (dept);
    \draw[->] (dept) -- node[above = 0.7cm] {\texttt{mappedBy}} node[below = 0.7cm] {Specchio} (emp);
\end{tikzpicture}
\end{center}

\begin{itemize}
    \item \textbf{Owner Side (@JoinColumn):} È l'entità che contiene fisicamente la chiave esterna. Hibernate guarda SOLO questo lato per salvare le modifiche.
    \item \textbf{Inverse Side (mappedBy):} È l'altro lato. Serve solo per navigare la relazione in Java.
\end{itemize}

\subsection{1. One-to-Many / Many-to-One}
Il caso classico: Un Dipartimento, Molti Impiegati.

\begin{lstlisting}[language=Java, title={Configurazione Corretta}]
// LATO OWNER (Chi ha la FK 'dept_id')
@Entity
public class Employee {
    @Id private UUID id;

    // SENIOR RULE: Sempre LAZY. Il default è EAGER (Male!)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "dept_id")
    private Department department;
}

// LATO INVERSE (Chi subisce il riferimento)
@Entity
public class Department {
    @Id private UUID id;

    // mappedBy punta al campo 'department' nella classe Employee
    @OneToMany(mappedBy = "department", 
               cascade = CascadeType.ALL, 
               orphanRemoval = true)
    private List<Employee> employees = new ArrayList<>();
}
\end{lstlisting}

\subsection{La Trappola Bidirezionale (Helper Methods)}
Se fai \texttt{dept.getEmployees().add(emp)} e salvi, \textbf{non succederà nulla nel DB}. Perché? Perché hai aggiornato il lato Inverse (che Hibernate ignora in scrittura).
Devi aggiornare il lato Owner (\texttt{emp.setDepartment(dept)}).

\begin{deepdive}{Helper Methods: Sincronizzazione}
Per evitare bug, incapsula la logica nell'entità Padre:

\begin{lstlisting}[language=Java]
// In Department.java
public void addEmployee(Employee employee) {
    this.employees.add(employee);
    employee.setDepartment(this); // Sincronizzo l'Owner!
}

public void removeEmployee(Employee employee) {
    this.employees.remove(employee);
    employee.setDepartment(null); // Dissocio
}
\end{lstlisting}
\end{deepdive}

\section{Relazioni Avanzate}

\subsection{2. One-to-One (Shared Primary Key)}
Relazione Utente $\leftrightarrow$ Profilo.
Evita di avere una FK in entrambe le tabelle. Usa \texttt{@MapsId}.
Significa: "La Primary Key del Profilo è ANCHE la Foreign Key verso l'Utente".

\begin{lstlisting}[language=Java]
@Entity
public class UserProfile {
    @Id private UUID userId; // Stesso ID dello User

    @OneToOne(fetch = FetchType.LAZY)
    @MapsId
    @JoinColumn(name = "user_id")
    private User user;
}
\end{lstlisting}

\subsection{3. Many-to-Many (Set vs List)}
Relazione Studente $\leftrightarrow$ Corso. Richiede una tabella di mezzo (\textit{Join Table}).

\begin{lstlisting}[language=Java]
@Entity
public class Student {
    @Id private UUID id;

    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    // CRUCIALE: Usa SET, mai LIST!
    private Set<Course> courses = new HashSet<>();
}
\end{lstlisting}

\begin{interview}{Perché Set e non List?}
\textbf{Domanda:} Perché l'uso di \texttt{List} è sconsigliato nelle \texttt{@ManyToMany}?

\textbf{Risposta:} Per un problema di performance sulle cancellazioni.
Se rimuovi un elemento da una \texttt{List}, Hibernate cancella \textbf{tutte} le righe della join table per quell'ID e reinserisce quelle rimaste (Delete All + Insert N-1).
Con \texttt{Set}, grazie all'unicità della chiave, Hibernate cancella esattamente la singola riga specifica.
\end{interview}

\section{Value Objects: @Embeddable}
Non tutto merita una tabella. Un indirizzo (Via, Città, CAP) ha senso solo se legato a un utente.

\begin{lstlisting}[language=Java]
@Embeddable
public class Address {
    private String street;
    private String city;
}

@Entity
public class User {
    @Id private UUID id;
    
    @Embedded
    private Address homeAddress; // Colonne: street, city

    // Se ho due indirizzi, devo rinominare le colonne!
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name="street", column=@Column(name="work_street")),
        @AttributeOverride(name="city", column=@Column(name="work_city"))
    })
    private Address workAddress;
}
\end{lstlisting}

\section{Ereditarietà (Inheritance Strategies)}
I DB relazionali non supportano \texttt{extends}. Hibernate offre 3 strategie.

\subsection{1. SINGLE\_TABLE (Default)}
Unica tabella gigante con una colonna discriminante (\texttt{DTYPE}).
\begin{itemize}
    \item \textbf{Pro:} Velocissimo (No Join).
    \item \textbf{Contro:} I campi delle sottoclassi devono essere \textbf{Nullable}. Viola l'integrità dei dati.
\end{itemize}

\subsection{2. JOINED (Normalizzato)}
Tabelle separate (Padre e Figli) collegate da FK.
\begin{itemize}
    \item \textbf{Pro:} Integrità referenziale, Not Null possibili.
    \item \textbf{Contro:} Query lente (Hibernate deve fare JOIN per caricare l'entità completa).
\end{itemize}

\subsection{3. TABLE\_PER\_CLASS}
Una tabella per ogni classe concreta, duplicando le colonne del padre.
\begin{itemize}
    \item \textbf{Contro:} Le query polimorfiche (\texttt{SELECT v FROM Veicolo v}) usano \texttt{UNION ALL}. Pessime performance. Da evitare.
\end{itemize}

\section{Riepilogo Best Practices}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Situazione}} & \textcolor{white}{\textbf{Soluzione Senior}} \\
    \hline
    \textbf{Chiavi Primarie} & Usa \texttt{UUID} per sistemi nuovi/distribuiti. \\
    \hline
    \textbf{Fetch Type} & Imposta \textbf{SEMPRE} \texttt{LAZY} su \texttt{@ManyToOne} e \texttt{@OneToOne}. \\
    \hline
    \textbf{Bidirezionalità} & Usa Helper Methods (`add/remove`) nel lato Inverse. \\
    \hline
    \textbf{ManyToMany} & Usa \texttt{Set<T>} e sovrascrivi \texttt{equals/hashCode} usando la Business Key (non l'ID). \\
    \hline
    \textbf{Soldi} & Usa \texttt{BigDecimal} con \texttt{precision} e \texttt{scale}. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{JPQL, HQL e Native Queries}

Mappare le entità è solo l'inizio. In un'applicazione reale, non puoi caricare l'intero database in memoria per filtrarlo con Java stream. Devi saper chiedere al Database esattamente ciò che ti serve.

Esistono tre linguaggi per parlare con Hibernate:
\begin{enumerate}
    \item \textbf{JPQL (Java Persistence Query Language):} Lo standard JPA. Opera su \textit{Entità} e \textit{Attributi}. È portabile (funziona su MySQL, Postgres, Oracle).
    \item \textbf{HQL (Hibernate Query Language):} Il dialetto proprietario di Hibernate. È un superset di JPQL (ha funzioni in più).
    \item \textbf{Native SQL:} SQL puro. Opera su \textit{Tabelle} e \textit{Colonne}. Dipende dal database specifico.
\end{enumerate}

\section{Sintassi JPQL: Pensare a Oggetti}

La differenza mentale fondamentale è che in JPQL non esistono le tabelle. Esistono solo le classi.

\begin{lstlisting}[language=Java, title={SQL vs JPQL}]
// SQL (Database centrico)
SELECT * FROM users u WHERE u.email_address = 'test@test.com';

// JPQL (Oggetto centrico)
// 'User' è la classe Java, 'email' è il campo Java (non la colonna!)
SELECT u FROM User u WHERE u.email = :email
\end{lstlisting}

\begin{deepdive}{Case Sensitivity}
In JPQL/HQL:
\begin{itemize}
    \item Le keyword (\texttt{SELECT}, \texttt{FROM}, \texttt{WHERE}) sono \textbf{case-insensitive}.
    \item I nomi delle Entità (\texttt{User}) e degli Attributi (\texttt{email}) sono \textbf{CASE-SENSITIVE}.
\end{itemize}
Scrivere \texttt{FROM user} (minuscolo) causerà \texttt{QuerySyntaxException} se la classe si chiama \texttt{User}.
\end{deepdive}

\section{Parametri Named: Sicurezza}
Mai concatenare stringhe nelle query. È la porta principale per la \textbf{SQL Injection}. Usa sempre i parametri nominati (Named Parameters).

\begin{lstlisting}[language=Java]
// Esempio con Spring Data @Query
@Query("SELECT u FROM User u WHERE u.status = :status AND u.age > :minAge")
List<User> findByStatusAndAge(
    @Param("status") UserStatus status, 
    @Param("minAge") int minAge
);
\end{lstlisting}

\section{Proiezioni DTO: Il Performance Booster}
Questo è il trucco che distingue i Senior.
Caricare un'Entity è costoso: Hibernate deve gestire il proxy, lo snapshot per il dirty checking e la cache L1.
Se devi solo mostrare una lista di nomi e email in una tabella, \textbf{non caricare le Entity}. Proietta su un DTO (o Record).

\subsection{La keyword 'new'}
Puoi istanziare oggetti Java direttamente dentro la query.

\begin{lstlisting}[language=Java, title={Costruzione DTO in Query}]
// Java Record (DTO leggero)
public record UserSummary(String username, String email) {}

// Query Ottimizzata
@Query("""
    SELECT new com.example.dto.UserSummary(u.username, u.email)
    FROM User u
    WHERE u.active = true
""")
List<UserSummary> findActiveSummaries();
\end{lstlisting}

\textbf{Vantaggi:}
\begin{itemize}
    \item \textbf{No Overhead:} Nessun oggetto entra nel Persistence Context.
    \item \textbf{No Dirty Checking:} Hibernate non traccia modifiche (risparmio CPU/RAM).
    \item \textbf{Network:} Scarichi dal DB solo le colonne che servono, non \texttt{SELECT *}.
\end{itemize}

\section{Native Query e Raw Mapping}
A volte JPQL non basta. Se devi usare \textit{Window Functions}, \textit{Common Table Expressions (CTE)}, o funzioni specifiche JSONB di Postgres, devi usare SQL Nativo.

\subsection{Mapping su Interfaccia (Spring Projection)}
Il modo più pulito per mappare il risultato di una Native Query senza creare classi DTO manuali.

\begin{lstlisting}[language=Java]
// 1. Definisci un'interfaccia con i getter che corrispondono agli ALIAS SQL
public interface SalesReport {
    String getCategory();     // corrisponde a c.name
    Double getTotalAmount();  // corrisponde a SUM(o.amount)
}

// 2. Scrivi la query Nativa
@Query(value = """
    SELECT c.name as category, SUM(o.amount) as totalAmount
    FROM orders o 
    JOIN categories c ON o.cat_id = c.id
    GROUP BY c.name
""", nativeQuery = true)
List<SalesReport> getSalesReport();
\end{lstlisting}

\begin{deepdive}{JPQL vs Native: Quando usare cosa?}
Usa JPQL per il 90\% dei casi (CRUD, ricerche, filtri). Mantiene il codice agnostico dal DB.
Usa Native Query solo per reportistica complessa o ottimizzazioni estreme dove l'SQL generato da Hibernate è inefficiente.
\end{deepdive}

\section{Modifying Queries (Bulk Update/Delete)}
Aggiornare 10.000 righe caricando le entity una a una è follia (10.000 SELECT + 10.000 UPDATE).
Si usa JPQL per fare un'unica UPDATE massiva.

\begin{lstlisting}[language=Java]
@Modifying(clearAutomatically = true) // FONDAMENTALE
@Query("UPDATE User u SET u.active = false WHERE u.lastLogin < :cutoffDate")
int deactivateInactiveUsers(@Param("cutoffDate") LocalDate cutoffDate);
\end{lstlisting}

\begin{interview}{Perché clearAutomatically = true?}
\textbf{Domanda:} Cosa succede se non metto \texttt{clearAutomatically = true}?

\textbf{Risposta:} \textbf{Inconsistenza dei dati.}
Le query \texttt{@Modifying} bypassano la cache di primo livello (L1) e scrivono direttamente sul DB.
Immagina di aver caricato l'utente Mario (active=true) in memoria.
Poi lanci la query di update che mette active=false sul DB.
Se non pulisci la cache, l'oggetto Java \texttt{mario} in memoria rimarrà \texttt{active=true}. Le logiche successive lavoreranno su dati vecchi.
\texttt{clearAutomatically} svuota il contesto, costringendo Hibernate a ricaricare i dati freschi alla prossima richiesta.
\end{interview}

\section{Pagination e Sorting}
Non scrivere mai \texttt{LIMIT} e \texttt{OFFSET} a mano in JPQL.
Spring Data e JPA gestiscono la paginazione in modo standard.

\begin{lstlisting}[language=Java]
// Nel Repository
@Query("SELECT u FROM User u WHERE u.dept = :dept")
Page<User> findByDept(@Param("dept") String dept, Pageable pageable);

// Nel Service
PageRequest pageRequest = PageRequest.of(0, 10, Sort.by("username"));
Page<User> page = repository.findByDept("IT", pageRequest);
\end{lstlisting}

\section{Riepilogo Best Practices}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Scenario}} & \textcolor{white}{\textbf{Soluzione Senior}} \\
    \hline
    Lettura Dati per UI (Read-Only) & Usa \textbf{DTO Projections} (keyword \texttt{new}). Evita di caricare Entity. \\
    \hline
    Query Complessa / DB Specific & Usa \textbf{Native Query} con Mapping su Interfaccia. \\
    \hline
    Aggiornamento Massivo & Usa \texttt{@Modifying} con \texttt{clearAutomatically=true}. \\
    \hline
    Parametri Query & Usa sempre \texttt{:paramName} (mai concatenazione stringhe). \\
    \hline
    Paginazione & Usa sempre \texttt{Pageable}, mai \texttt{findAll()}. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Transazioni e Concorrenza (JPA Internals)}

Fino ad ora abbiamo visto come mappare e interrogare i dati. Ma le applicazioni enterprise sono multi-utente. Cosa succede se due utenti modificano lo stesso record nello stesso millisecondo?

In questo capitolo scendiamo nel livello più basso: la gestione dell'integrità dei dati (ACID), i livelli di isolamento e le strategie di Locking (Ottimistico vs Pessimistico).

\section{Anatomia di una Transazione (Unit of Work)}

Prima di usare la magia di Spring (\texttt{@Transactional}), dobbiamo capire cosa succede "a mano".
In JPA, la transazione è gestita dall'interfaccia \texttt{EntityTransaction}.

\begin{lstlisting}[language=Java, title={Gestione Manuale (Cosa fa Spring per te)}]
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

try {
    // 1. BEGIN: Apre la connessione fisica e disabilita auto-commit
    tx.begin();

    // 2. BUSINESS LOGIC
    BankAccount conto = em.find(BankAccount.class, 1L);
    conto.setBalance(conto.getBalance() - 100); // Dirty Checking attivo
    
    // 3. FLUSH: Invia le SQL (UPDATE) al DB, ma non conferma
    em.flush(); 

    // 4. COMMIT: Rende le modifiche permanenti e visibili agli altri
    tx.commit();

} catch (Exception e) {
    // 5. ROLLBACK: Annulla tutto se c'è un errore
    if (tx.isActive()) tx.rollback();
} finally {
    em.close();
}
\end{lstlisting}

\begin{deepdive}{Flush vs Commit}
È vitale distinguere questi due momenti:
\begin{itemize}
    \item \textbf{Flush():} Sincronizza la memoria Java con il Database. Esegue le istruzioni SQL (\texttt{INSERT}, \texttt{UPDATE}). I dati sono nel DB, ma sono "sporchi" (bloccati dalla transazione corrente).
    \item \textbf{Commit():} Chiama implicitamente \texttt{flush()} e poi invia il comando di commit al DB, rendendo le modifiche definitive e rilasciando i lock.
\end{itemize}
\end{deepdive}

\section{Isolation Levels: I Fenomeni di Concorrenza}
Il database promette isolamento, ma quanto isolamento? Più isoli, più il sistema è lento.
JPA delega questo controllo al database sottostante, ma devi conoscere i rischi.

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Livello}} & \textcolor{white}{\textbf{Fenomeni Evitati}} \\
    \hline
    \textbf{READ UNCOMMITTED} & \textcolor{javared}{Nessuno.} Leggi dati non ancora committati (Dirty Read). Veloce ma pericoloso. \\
    \hline
    \textbf{READ COMMITTED} & Evita \textbf{Dirty Reads}. Leggi solo dati confermati. È il default di Postgres, Oracle e SQL Server. \\
    \hline
    \textbf{REPEATABLE READ} & Evita \textbf{Non-Repeatable Reads}. Se leggi una riga due volte nella stessa TX, ottieni lo stesso valore. Default di MySQL. \\
    \hline
    \textbf{SERIALIZABLE} & Evita \textbf{Phantom Reads}. Esecuzione sequenziale. Lento ma sicuro al 100\%. \\
    \hline
\end{tabularx}
\end{center}

\begin{interview}{Dirty Read vs Phantom Read}
\textbf{Domanda:} Qual è la differenza?
\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Dirty Read:} Leggo un dato modificato da un'altra transazione che poi fa Rollback. Ho letto un dato che "non è mai esistito".
    \item \textbf{Phantom Read:} Eseguo \texttt{SELECT COUNT(*)} e ottengo 10. Un altro utente inserisce una riga. Rifaccio la query e ottengo 11. I dati esistenti non sono cambiati, ma sono apparse righe "fantasma".
\end{itemize}
\end{interview}

\section{Gestione della Concorrenza: Il Locking}
Il problema principale nelle web app è il \textbf{Lost Update}.
\textit{Alice e Bob leggono lo stesso prodotto (Qty: 10). Entrambi vendono 1 unità. Entrambi salvano Qty: 9. Risultato finale: 9 (invece di 8).}

\subsection{1. Optimistic Locking (@Version)}
È la strategia "Web Scale". Non usiamo lock sul database. Usiamo una colonna \texttt{version}.

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    user/.style={rectangle, draw=black, fill=white, minimum width=2cm, align=center},
    db/.style={cylinder, draw=black, aspect=0.25, fill=gray!20, shape border rotate=90, align=center},
    msg/.style={rectangle, draw=gray, fill=white, font=\scriptsize, align=left}
]

    \node[user] (alice) {Alice};
    \node[user, right=4cm of alice] (bob) {Bob};
    \node[db, below=4cm of alice, xshift=2cm] (database) {Database\\(v=1)};

    % Timeline Alice
    \draw[->] (alice) -- node[left, font=\scriptsize] {1. Legge (v=1)} (database);
    \draw[->] (alice) -- node[left, font=\scriptsize, pos=0.3] {2. Salva (v=1 $\to$ 2)} (database);
    
    % Timeline Bob
    \draw[->, dashed] (bob) -- node[right, font=\scriptsize] {1. Legge (v=1)} (database);
    \draw[->, red, thick] (bob) -- node[right, font=\scriptsize, pos=0.3] {3. Salva (v=1 $\to$ 2) \textbf{ERROR!}} (database);

\end{tikzpicture}
\end{center}

\begin{lstlisting}[language=Java]
@Entity
public class Product {
    @Id private Long id;
    
    private int quantity;

    @Version // Gestito automaticamente da Hibernate
    private Long version; 
}
\end{lstlisting}

Quando Bob prova a salvare, Hibernate esegue:
\texttt{UPDATE product SET quantity=9, version=2 WHERE id=1 AND version=1}
Poiché Alice ha già portato la versione a 2, la condizione \texttt{WHERE version=1} fallisce (0 righe aggiornate). Hibernate lancia \textbf{\texttt{OptimisticLockException}}.
Spetta al codice applicativo catturare l'eccezione e chiedere a Bob di ricaricare la pagina.

\subsection{2. Pessimistic Locking}
In scenari critici (es. bonifici, biglietti concerto), non possiamo rischiare. Blocchiamo la riga fisicamente.

\begin{lstlisting}[language=Java]
// JPQL con Lock
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Optional<Product> findByIdWithLock(@Param("id") Long id);
\end{lstlisting}

Questo genera una SQL: \texttt{SELECT ... FOR UPDATE}.
Nessun altro potrà leggere o scrivere quella riga finché la transazione corrente non è finita.

\begin{deepdive}{Attenzione ai Deadlock}
Il Pessimistic Locking è pericoloso.
Se Transazione A blocca Risorsa 1 e vuole Risorsa 2.
E Transazione B blocca Risorsa 2 e vuole Risorsa 1.
Il sistema si congela (Deadlock).
\textbf{Best Practice:} Imposta sempre un timeout:
\texttt{@QueryHints(@QueryHint(name = "javax.persistence.lock.timeout", value = "3000"))}
\end{deepdive}

\section{Riepilogo Best Practices}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Scenario}} & \textcolor{white}{\textbf{Soluzione}} \\
    \hline
    Web App Standard (CRUD) & \textbf{Optimistic Locking} (\texttt{@Version}). Scalabilità massima, nessun lock DB. \\
    \hline
    Operazioni Critiche (Finanza) & \textbf{Pessimistic Locking} (\texttt{PESSIMISTIC\_WRITE}). Sicurezza totale, bassa scalabilità. \\
    \hline
    Reportistica Lunga & Usa \textbf{READ COMMITTED} o snapshot isolation per non bloccare chi scrive. \\
    \hline
    Gestione Errori & Cattura sempre \texttt{OptimisticLockException} nel Service e rilancia un errore leggibile per l'utente ("Dato modificato da altri, ricarica"). \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Hibernate Performance Tuning \& Caching}

Hibernate è famoso per essere facile da iniziare ma difficile da scalare. Se non configurato correttamente, può generare migliaia di query inutili (N+1 Problem) o consumare tutta la memoria heap.

In questo capitolo vedremo come trasformare un'applicazione lenta in una scheggia, usando strategie di fetching intelligenti e livelli di caching multipli.

\section{Il Problema N+1 Select: Il Killer Silenzioso}

È la causa numero uno dei rallentamenti nelle applicazioni Java.

\textbf{Scenario:} Hai una lista di \texttt{Ordini}. Ogni ordine ha una lista di \texttt{Articoli}.
La relazione è \texttt{LAZY} (come raccomandato).

\begin{lstlisting}[language=Java]
// 1. Carica 1000 ordini (1 Query)
List<Order> orders = orderRepository.findAll();

for (Order order : orders) {
    // 2. Accedi alla collezione Lazy
    // Hibernate esegue una query SELECT * FROM items WHERE order_id = ?
    System.out.println("Articoli: " + order.getItems().size());
}
\end{lstlisting}

\textbf{Risultato:} Hibernate esegue \textbf{1001 Query}.
1 per la lista + 1000 per i dettagli di ogni ordine. Il database viene bombardato.

\subsection{Soluzione 1: JOIN FETCH (JPQL)}
Forziamo il caricamento immediato in una sola query.

\begin{lstlisting}[language=Java]
@Query("SELECT o FROM Order o JOIN FETCH o.items")
List<Order> findAllWithItems();
\end{lstlisting}
\textbf{Risultato:} 1 Query singola con \texttt{INNER JOIN}.

\subsection{Soluzione 2: @EntityGraph (Dichiarativo)}
Se non vuoi scrivere JPQL, puoi usare l'annotazione JPA standard.

\begin{lstlisting}[language=Java]
// Nel Repository
@EntityGraph(attributePaths = {"items", "customer"})
List<Order> findAll();
\end{lstlisting}
Questo dice a Spring Data: "Esegui il findAll standard, ma fai una Left Join Fetch su items e customer".

\section{Batch Fetching: La via di mezzo intelligente}

A volte \texttt{JOIN FETCH} non va bene.
Se hai \textbf{due} collezioni (`items` e `historyLogs`) e provi a fare \texttt{JOIN FETCH} su entrambe, crei un \textbf{Prodotto Cartesiano} (le righe si moltiplicano esponenzialmente in memoria). Hibernate lancerà un errore \texttt{MultipleBagFetchException}.

\textbf{Soluzione Senior: @BatchSize}
Manteniamo il caricamento LAZY, ma ottimizzato. Invece di caricare gli articoli uno per uno, li carichiamo a pacchetti.

\begin{lstlisting}[language=Java]
@Entity
public class Order {
    @Id private Long id;

    @OneToMany(mappedBy = "order")
    @BatchSize(size = 20) // LA MAGIA
    private List<Item> items;
}
\end{lstlisting}

\textbf{Cosa succede ora nel loop?}
\begin{enumerate}
    \item Carichi 100 ordini.
    \item Accedi al primo \texttt{order.getItems()}.
    \item Hibernate vede che ci sono altri proxy in memoria e invece di caricare solo l'ID 1, carica gli ID 1, 2, 3... fino a 20.
    \item \textbf{SQL Generato:} \texttt{SELECT * FROM items WHERE order\_id IN (?, ?, ... 20 volte)}.
\end{enumerate}
\textbf{Risultato:} Invece di 1000 query, ne fai $1000 / 20 = 50$ query. Performance ottime senza prodotto cartesiano.

\section{LazyInitializationException: Il Nemico}

Questo errore accade quando accedi a un campo \texttt{LAZY} (Proxy) ma la sessione Hibernate è già chiusa.

\begin{deepdive}{L'Anti-Pattern "enable\_lazy\_load\_no\_trans"}
Molti sviluppatori trovano su StackOverflow questa proprietà da mettere nell'\texttt{application.properties}:
\texttt{hibernate.enable\_lazy\_load\_no\_trans=true}.

\textbf{NON FARLO MAI.}
Questa impostazione dice a Hibernate: "Se la sessione è chiusa, aprine una nuova temporanea, fai la query e richiudila".
Trasforma un errore visibile (l'eccezione) in un problema di performance invisibile (N+1 silenzioso). Se hai bisogno dei dati, caricali prima con \texttt{JOIN FETCH}.
\end{deepdive}

\section{Hibernate Caching Architecture}

Hibernate ha un'architettura di caching a due livelli.

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    box/.style={rectangle, draw=deepblue, fill=white, minimum width=3cm, minimum height=1cm, align=center},
    db/.style={cylinder, draw=black, aspect=0.25, fill=gray!20, shape border rotate=90, align=center}
]
    \node[box] (app) {Applicazione};
    \node[box, below=0.8cm of app] (l1) {\textbf{L1 Cache} (Session)};
    \node[box, below=0.8cm of l1, dashed] (l2) {\textbf{L2 Cache} (SessionFactory)};
    \node[db, below=0.8cm of l2] (database) {Database};

    \draw[->] (app) -- (l1);
    \draw[->] (l1) -- (l2);
    \draw[->] (l2) -- (database);
\end{tikzpicture}
\end{center}

\subsection{Level 1 Cache (Session Scope)}
\begin{itemize}
    \item \textbf{Abilitata:} Sempre (non disattivabile).
    \item \textbf{Vita:} Dura quanto la transazione.
    \item \textbf{Funzione:} Garantisce che \texttt{findById(1)} ritorni lo stesso oggetto Java se chiamato due volte nella stessa transazione.
\end{itemize}

\subsection{Level 2 Cache (Global Scope)}
\begin{itemize}
    \item \textbf{Abilitata:} No (va configurata).
    \item \textbf{Vita:} Dura quanto l'applicazione. Condivisa tra tutti gli utenti.
    \item \textbf{Provider:} EhCache (locale), Redis (distribuito).
    \item \textbf{Uso:} Ideale per dati "Reference" (es. Regioni, Province, Categorie prodotti) che vengono letti spesso e modificati raramente.
\end{itemize}

\begin{lstlisting}[language=Java, title={Abilitare L2 Cache su un'Entity}]
@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Product { ... }
\end{lstlisting}

\subsection{Query Cache}
La L2 Cache salva le \textit{Entità} per ID. Ma se fai una query \texttt{SELECT p FROM Product p WHERE p.price > 100}?
Hibernate non può usare la L2 Cache perché non conosce gli ID.
La \textbf{Query Cache} salva i risultati delle query (solo gli ID) basandosi sui parametri di input.
\textbf{Attenzione:} Se la tabella viene modificata spesso, la Query Cache si invalida continuamente, peggiorando le performance invece di migliorarle.

\section{Riepilogo Strategie di Performance}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Problema}} & \textcolor{white}{\textbf{Soluzione Senior}} \\
    \hline
    \textbf{N+1 Select} (Singola Relazione) & Usa \textbf{\texttt{JOIN FETCH}} in JPQL. \\
    \hline
    \textbf{N+1 Select} (Multiple Relazioni) & Usa \textbf{\texttt{@BatchSize(size=20)}} per evitare il prodotto cartesiano. \\
    \hline
    \textbf{LazyInitializationException} & Non riaprire la sessione. Progetta meglio la query iniziale caricando ciò che serve. \\
    \hline
    \textbf{Dati statici letti spesso} & Abilita la \textbf{L2 Cache} (es. Redis) con strategia READ\_ONLY. \\
    \hline
    \textbf{Reportistica pesante} & Non usare Hibernate. Usa \textbf{Native SQL} o JDBC Template per bypassare l'overhead dell'Entity Manager. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{DTO: Architettura, Mapping e Proiezioni JPA}

Finora abbiamo parlato di come mappare il DB sugli oggetti (Entity). Ma se provi a costruire un'applicazione Enterprise usando solo le Entity, fallirai.
Il \textbf{Data Transfer Object (DTO)} non è burocrazia: è l'unica barriera che protegge il tuo Database dal mondo esterno.

In questo capitolo vedremo:
\begin{itemize}
    \item \textbf{Il problema strutturale:} Perché le Entity nel Controller corrompono i dati.
    \item \textbf{Il flusso architetturale:} Come avviene lo "Swap" (Entity $\leftrightarrow$ DTO) nel Service.
    \item \textbf{JPA Projections:} Come usare i DTO per scrivere query SQL performanti senza caricare intere Entity in memoria.
\end{itemize}

\section{Il Design Pattern Architetturale}

Prima del codice, devi visualizzare il flusso dei dati. Un'applicazione Java ben fatta a strati funziona così:

\begin{center}
\begin{tcolorbox}[colback=white, colframe=deepblue, title=Il Flusso dei Dati (Data Flow)]
\textbf{Frontend (JSON)} $\xrightarrow{\text{Request}}$ \textbf{Controller} $\xrightarrow{\text{DTO}}$ \textbf{Service} $\xrightarrow{\text{Entity}}$ \textbf{Repository/DB}

\vspace{0.2cm}
\textbf{Frontend (JSON)} $\xleftarrow{\text{Response}}$ \textbf{Controller} $\xleftarrow{\text{DTO}}$ \textbf{Service} $\xleftarrow{\text{Entity}}$ \textbf{Repository/DB}
\end{tcolorbox}
\end{center}

\begin{itemize}
    \item Il \textbf{Controller} parla solo DTO. Non deve sapere cosa sia una Entity.
    \item Il \textbf{Repository} parla solo Entity (o Projections).
    \item Il \textbf{Service} è il "convertitore": è l'unico posto dove avviene lo \textbf{Swap}.
\end{itemize}

\section{Il Pericolo: Dirty Checking e Dati Esposti}

Perché non posso fare \texttt{return repository.findById(id)}?
Guardiamo cosa succede "sotto il cofano" di Hibernate quando fai questa operazione ingenua.

\begin{lstlisting}[language=Java, title={L'errore del Junior Dev: Entity nel Controller}]
@GetMapping("/users/{id}")
@Transactional // Spesso la transazione e' aperta fino alla vista (OSIV)
public UserEntity getUser(@PathVariable Long id) {
    // 1. Hibernate carica l'Entity. È in stato "MANAGED".
    // Significa che Hibernate osserva ogni modifica.
    UserEntity user = repository.findById(id).orElseThrow();

    // 2. Il Dev vuole nascondere la password hashata prima di mandare il JSON
    user.setPassword("*******"); 

    // 3. Ritorna l'oggetto. Jackson lo serializza.
    return user; 
    
    // 4. DISASTRO: Alla fine del metodo, Hibernate fa il "Flush".
    // Vede che la password in memoria è diversa da quella originale.
    // Esegue AUTOMATICAMENTE: UPDATE users SET password = '*******' ...
}
\end{lstlisting}

\textbf{Risultato:} Hai appena cancellato la password dell'utente dal Database semplicemente leggendo il suo profilo.
Usando un DTO, lavori su una copia scollegata (Detached). Puoi modificarla quanto vuoi, Hibernate non se ne accorgerà mai.

\section{Implementazione Moderna: Record e MapStruct}

Oggi non si scrivono più DTO a mano (troppo codice) né si usano mapper lenti basati su Reflection (ModelMapper). Lo standard industriale è \textbf{Java Records} + \textbf{MapStruct}.

\subsection{1. Definizione dei DTO (Java 14+ Records)}
I record sono immutabili, veloci e concisi.

\begin{lstlisting}[language=Java, title={DTO definition}]
// DTO per la risposta (Output)
public record UserResponse(
    Long id,
    String username,
    String email, // Niente password qui!
    LocalDateTime subscriptionDate
) {}

// DTO per la richiesta (Input)
public record UserRegistrationRequest(
    @NotBlank String username,
    @Email String email,
    @Size(min=8) String password
) {}
\end{lstlisting}

\subsection{2. Il Mapper (MapStruct)}
MapStruct genera il codice di conversione a \textbf{compile time}. È veloce come se lo scrivessi tu a mano.

\begin{lstlisting}[language=Java, title={UserMapper.java}]
@Mapper(componentModel = "spring")
public interface UserMapper {
    
    // Da Entity a DTO (Output)
    UserResponse toResponse(UserEntity entity);

    // Da DTO a Entity (Input)
    @Mapping(target = "id", ignore = true) // L'ID lo genera il DB
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    UserEntity toEntity(UserRegistrationRequest request);
}
\end{lstlisting}

\section{Lo "Swap": Il Service Layer in Azione}

Ecco il codice che devi scrivere per gestire correttamente la transizione.

\begin{lstlisting}[language=Java, title={UserService.java - La Logica di Business}]
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository repository;
    private final UserMapper mapper;

    // SCENARIO 1: LETTURA (Entity -> DTO)
    @Transactional(readOnly = true)
    public UserResponse getUserProfile(Long id) {
        // 1. Recupero Entity dal DB
        UserEntity entity = repository.findById(id)
            .orElseThrow(() -> new NotFoundException("Utente non trovato"));
        
        // 2. SWAP: Converto in DTO
        // Qui l'entity rimane nel contesto di persistenza, ma il DTO no.
        UserResponse dto = mapper.toResponse(entity);
        
        return dto;
    }

    // SCENARIO 2: SCRITTURA (DTO -> Entity)
    @Transactional
    public UserResponse registerUser(UserRegistrationRequest request) {
        // 1. SWAP: Converto il DTO in ingresso in una nuova Entity
        UserEntity newUser = mapper.toEntity(request);
        
        // 2. Business Logic (es. hash password)
        newUser.setPassword(BCrypt.hashpw(request.password(), BCrypt.gensalt()));
        
        // 3. Salvataggio
        UserEntity savedUser = repository.save(newUser);
        
        // 4. SWAP Finale: Ritorno il DTO dell'utente salvato
        return mapper.toResponse(savedUser);
    }
}
\end{lstlisting}

\section{DTO Projections: La "Magia" nelle Query}

Finora abbiamo caricato l'intera Entity per poi convertirla. Ma se la tabella \texttt{Users} ha 50 colonne e a me servono solo \texttt{nome} e \texttt{email}?
Caricare l'intera Entity è uno spreco di memoria RAM e banda di rete.

Qui entrano in gioco le \textbf{JPA Projections}. Possiamo istruire Hibernate per popolare \textbf{direttamente} il DTO tramite la query SQL, saltando completamente la fase di creazione dell'Entity.

\subsection{1. JPQL Constructor Expression (Class-based Projection)}
Questa è la tecnica più potente per reportistica e liste massive.

\begin{lstlisting}[language=Java, title={Repository con Query DTO}]
public interface UserRepository extends JpaRepository<UserEntity, Long> {

    // MAGIA: Hibernate esegue la SELECT e istanzia direttamente il Record!
    // Non viene creata nessuna Entity UserEntity.
    // La query SQL estrarrà SOLO le colonne username ed email.
    
    @Query("""
        SELECT new com.example.dto.UserSummary(u.username, u.email)
        FROM UserEntity u
        WHERE u.active = true
    """)
    List<UserSummary> findAllActiveSummaries();
}
\end{lstlisting}

\begin{deepdive}{Perché usare le Projections?}
Immagina di avere una lista di 10.000 utenti.
\begin{itemize}
    \item \textbf{Approccio Classico (findAll + MapStruct):} Hibernate istanzia 10.000 oggetti Entity (con tutti i campi, relazioni Lazy, proxy). Poi tu crei 10.000 DTO. Totale: 20.000 oggetti in heap + Overhead pesante.
    \item \textbf{Approccio Projection (new DTO...):} Hibernate esegue \texttt{SELECT col1, col2...}. Istanzia \textbf{soltanto} i 10.000 DTO leggeri. Nessuna Entity viene caricata nel Persistence Context.
    \textbf{Risultato:} Performance 10x più veloci e consumo di memoria dimezzato.
\end{itemize}
\end{deepdive}

\subsection{2. Interface-based Projections (Spring Data Magic)}
Se non vuoi scrivere la query JPQL a mano, Spring Data offre una magia ancora più oscura: le proiezioni tramite interfaccia.

\begin{lstlisting}[language=Java, title={Interface Projection}]
// 1. Definisci un'interfaccia con i getter che corrispondono ai campi dell'Entity
public interface UserNamesOnly {
    String getUsername();
    String getEmail();
}

// 2. Nel Repository usi l'interfaccia come tipo di ritorno
public interface UserRepository extends JpaRepository<UserEntity, Long> {
    
    // Spring genera al volo un proxy che implementa l'interfaccia
    // e ottimizza la query SQL per estrarre solo quei due campi.
    List<UserNamesOnly> findByActiveTrue();
}
\end{lstlisting}

\section{Riepilogo Best Practices}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Cosa fare}} & \textcolor{white}{\textbf{Perché}} \\
    \hline
    Usare \textbf{Record} per i DTO & Immutabilità, meno codice, serializzazione JSON pulita. \\
    \hline
    Usare \textbf{MapStruct} & Performance a compile-time (no reflection lenta). \\
    \hline
    Swap nel \textbf{Service Layer} & Mantiene la transazione atomica e il Controller pulito. \\
    \hline
    Usare \textbf{DTO Projections} & Per liste lunghe o report, evita di caricare Entity pesanti. \\
    \hline
    Validazione nel DTO Input & \texttt{@NotNull}, \texttt{@Size} vanno messi nel DTO, non nell'Entity. \\
    \hline
\end{tabularx}
\end{center}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{JPA Criteria API: Query Type-Safe e Dinamiche}

Fino ad ora abbiamo visto query scritte in \textbf{HQL/JPQL} (es. \texttt{"FROM User u WHERE u.age > 18"}).
Sebbene leggibili, queste query hanno due grossi difetti:
\begin{enumerate}
    \item \textbf{Non sono Type-Safe:} Sono semplici stringhe. Se scrivi \texttt{u.eta} invece di \texttt{u.age}, te ne accorgi solo a \textbf{Runtime} (quando l'app crasha), non durante la compilazione.
    \item \textbf{Difficili da comporre dinamicamente:} Se devi creare un filtro di ricerca con 10 campi opzionali (es. filtro e-commerce), concatenare stringhe con infiniti \texttt{if (prezzo != null) sql += " AND..."} diventa un incubo di manutenzione e rischio SQL Injection.
\end{enumerate}

La \textbf{Criteria API} risolve questi problemi permettendo di costruire query usando \textbf{Oggetti Java}.

\section{Architettura: I 3 Moschettieri}

Per scrivere una query Criteria, servono sempre tre componenti fondamentali ottenuti dall'\texttt{EntityManager}.

\begin{enumerate}
    \item \textbf{CriteriaBuilder (Il Fabbro):} È la factory. Serve a creare le parti della query (la query stessa, le clausole \texttt{where}, le espressioni logiche come \texttt{equal}, \texttt{gt}, \texttt{like}).
    \item \textbf{CriteriaQuery<T> (Il Contenitore):} Rappresenta la struttura della query (SELECT, FROM, WHERE, ORDER BY). È tipizzata sul risultato atteso.
    \item \textbf{Root<T> (La Radice):} Rappresenta la clausola \texttt{FROM}. È il punto di partenza per accedere alle colonne (attributi) dell'entità.
\end{enumerate}

\begin{lstlisting}[language=Java, caption=Scheletro base di una Criteria Query]
// 1. Otteniamo il Builder
CriteriaBuilder cb = entityManager.getCriteriaBuilder();

// 2. Creiamo la Query (il risultato sarà di tipo User)
CriteriaQuery<User> query = cb.createQuery(User.class);

// 3. Definiamo la Root (FROM User)
Root<User> root = query.from(User.class);

// 4. Costruiamo la logica (SELECT * FROM User)
query.select(root);

// 5. Esecuzione
List<User> results = entityManager.createQuery(query).getResultList();
\end{lstlisting}

\section{Filtraggio: La Clausola WHERE}

Invece di scrivere \texttt{age > 18}, usiamo i metodi del Builder.

\begin{lstlisting}[language=Java, caption=Clausola Where Semplice]
// Voglio: SELECT * FROM users WHERE username = 'Mario'

// Definisco la condizione (Il Predicato)
// root.get("username") accede al campo dell'entity
Predicate condition = cb.equal(root.get("username"), "Mario");

// Applico la condizione alla query
query.where(condition);
\end{lstlisting}

\begin{deepdive}{Root.get() vs Stringhe Magiche}
    Scrivere \texttt{root.get("username")} è ancora pericoloso: se rinomini il campo \texttt{username} in \texttt{loginName} nella classe Java ma dimentichi di aggiornare la stringa qui, avrai un errore a Runtime.
    La soluzione "Senior" è usare il \textbf{JPA Metamodel} (vedi Sezione \ref{sec:metamodel}).
\end{deepdive}

\section{Il vero potere: Query Dinamiche}

Questo è il motivo principale per cui si usa Criteria: costruire filtri complessi dove i parametri sono opzionali.

Immagina una form di ricerca utenti dove puoi filtrare per nome, email, o età minima. Se l'utente lascia un campo vuoto, quel filtro non deve essere applicato.

\begin{lstlisting}[language=Java, caption=Pattern List<Predicate>]
public List<User> searchUsers(String name, String email, Integer minAge) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> query = cb.createQuery(User.class);
    Root<User> root = query.from(User.class);

    // Lista per accumulare le condizioni (AND dinamico)
    List<Predicate> predicates = new ArrayList<>();

    // Aggiungo condizione SOLO se il parametro è presente
    if (name != null && !name.isEmpty()) {
        predicates.add(cb.like(root.get("name"), "%" + name + "%"));
    }

    if (email != null && !email.isEmpty()) {
        predicates.add(cb.equal(root.get("email"), email));
    }

    if (minAge != null) {
        predicates.add(cb.ge(root.get("age"), minAge)); // ge = greater or equal
    }

    // Converto la lista in un array e li unisco con AND
    query.where(cb.and(predicates.toArray(new Predicate[0])));

    return entityManager.createQuery(query).getResultList();
}
\end{lstlisting}

\begin{interview}{HQL vs Criteria: Quando usare quale?}
    \textbf{Domanda:} "Criteria sembra molto verboso (10 righe per una select). Perché non usare sempre HQL?"
    
    \textbf{Risposta:}
    \begin{itemize}
        \item \textbf{Usa HQL/JPQL} per query \textbf{statiche} e conosciute a priori. È più leggibile, conciso e facile da ottimizzare.
        \item \textbf{Usa Criteria} per query \textbf{dinamiche} (es. filtri di ricerca con campi opzionali), dove concatenare stringhe HQL porterebbe a un codice "spaghetti" e insicuro.
    \end{itemize}
\end{interview}

\section{Type Safety Totale: Il Metamodel}

Per eliminare le stringhe come \texttt{root.get("age")}, JPA permette di generare automaticamente delle classi "gemelle" (chiamate Metamodel) che contengono i nomi dei campi come costanti statiche tipizzate.
Solitamente si usa il plugin Maven \texttt{hibernate-jpamodelgen}.

Se hai una entity \texttt{User}, verrà generata una classe \texttt{User\_} (col trattino basso).

\begin{lstlisting}[language=Java, caption=Uso del Metamodel]
// Invece di: root.get("age")
// Scriviamo: root.get(User_.AGE)

// Se cambi il nome del campo 'age' nella classe User e ricompili,
// User_.AGE non esisterà più e avrai un ERRORE DI COMPILAZIONE.
// Bug preso prima di andare in produzione!
Predicate p = cb.gt(root.get(User_.AGE), 18);
\end{lstlisting}

\section{Proiezioni: Selezionare solo alcuni campi (DTO)}

Spesso non vogliamo caricare l'intera Entity (magari pesante), ma solo un paio di colonne per mostrarle in una lista.
Criteria permette di mappare il risultato direttamente su un DTO usando \texttt{construct}.

\begin{lstlisting}[language=Java, caption=Proiezione su DTO]
CriteriaQuery<UserDTO> query = cb.createQuery(UserDTO.class);
Root<User> root = query.from(User.class);

// SELECT new com.example.UserDTO(u.name, u.email) FROM User u
query.select(
    cb.construct(
        UserDTO.class,       // Classe di destinazione
        root.get("name"),    // Primo argomento costruttore
        root.get("email")    // Secondo argomento costruttore
    )
);

List<UserDTO> dtos = entityManager.createQuery(query).getResultList();
\end{lstlisting}

\begin{deepdive}{Criteria vs Specification (Spring Data)}
    Se usi Spring Data JPA, raramente scriverai codice Criteria "puro" come questo.
    Userai le \textbf{Specifications}.
    
    Una \texttt{Specification} è un wrapper funzionale attorno alla Criteria API.
    \begin{verbatim}
    public static Specification<User> hasName(String name) {
        return (root, query, cb) -> cb.equal(root.get("name"), name);
    }
    \end{verbatim}
    Questo permette di comporre query in modo molto elegante:
    \texttt{repo.findAll(hasName("Mario").and(isAdult()));}
    
    Tuttavia, sotto il cofano, Spring usa esattamente la Criteria API che abbiamo appena studiato.
\end{deepdive}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Esempio Pratico: Architettura Hibernate Pura}

Mentre JDBC richiede di scrivere SQL manualmente e gestire connessioni fisiche, Hibernate funge da ponte (ORM) tra il mondo degli oggetti Java e il mondo relazionale del DB.

In questo esempio "Vanilla" (senza Spring), dobbiamo gestire manualmente:
\begin{itemize}
    \item La configurazione XML.
    \item Il ciclo di vita della \texttt{SessionFactory} (pesante, una per app).
    \item Il ciclo di vita della \texttt{Session} (leggera, una per richiesta/transazione).
    \item I confini della Transazione (\texttt{begin}, \texttt{commit}, \texttt{rollback}).
\end{itemize}

\section{1. Configurazione (hibernate.cfg.xml)}

In Spring Boot questo file non esiste (si usa \texttt{application.properties}), ma in Hibernate puro è il cuore del sistema. Va messo nella cartella \texttt{src/main/resources}.

\begin{lstlisting}[language=XML, caption=hibernate.cfg.xml]
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <!-- 1. Connessione al Database (JDBC settings) -->
        <property name="connection.driver_class">org.postgresql.Driver</property>
        <property name="connection.url">jdbc:postgresql://localhost:5432/hiber_db</property>
        <property name="connection.username">admin</property>
        <property name="connection.password">secret</property>

        <!-- 2. Pool di Connessioni (C3P0 o HikariCP integrato) -->
        <property name="connection.pool_size">5</property>

        <!-- 3. SQL Dialect (Dice a Hibernate come tradurre l'HQL in SQL specifico) -->
        <property name="dialect">org.hibernate.dialect.PostgreSQLDialect</property>

        <!-- 4. Gestione del contesto (Thread corrente) -->
        <property name="current_session_context_class">thread</property>

        <!-- 5. Debugging -->
        <property name="show_sql">true</property> <!-- Stampa le query -->
        <property name="format_sql">true</property> <!-- Formatta l'output -->

        <!-- 6. Schema Generation (PERICOLOSO IN PROD!) -->
        <!-- 'update': crea le tabelle se non esistono, le aggiorna se cambiano -->
        <property name="hbm2ddl.auto">update</property>

        <!-- 7. Registrazione delle Entity -->
        <mapping class="com.example.model.User"/>
    </session-factory>
</hibernate-configuration>
\end{lstlisting}

\section{2. L'Entity (JPA Annotations)}

A differenza del DTO JDBC, questa classe è "viva". Hibernate ne monitora lo stato.
Usiamo le annotazioni standard JPA (\texttt{jakarta.persistence.*}) per massima portabilità.

\begin{lstlisting}[language=Java, caption=User.java (Entity)]
@Entity // Indica che questa classe mappa una tabella
@Table(name = "users") // Nome della tabella (opzionale se uguale alla classe)
public class User {

    @Id // Chiave Primaria
    @GeneratedValue(strategy = GenerationType.IDENTITY) // AUTO_INCREMENT
    private Long id;

    @Column(name = "username", nullable = false, unique = true)
    private String username;

    @Column(name = "email")
    private String email;

    // Costruttore vuoto: OBBLIGATORIO per Hibernate (usa la Reflection)
    public User() {}

    public User(String username, String email) {
        this.username = username;
        this.email = email;
    }

    // Getters e Setters (Fondamentali per i proxy di Hibernate)
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    // toString() per debug
    @Override
    public String toString() {
        return "User[id=" + id + ", user=" + username + "]";
    }
}
\end{lstlisting}

\section{3. Infrastructure: HibernateUtil}

La creazione della \texttt{SessionFactory} è un'operazione costosa (parsing XML, verifica schema DB). Va fatta una volta sola all'avvio (Pattern Singleton).

\begin{lstlisting}[language=Java, caption=HibernateUtil.java]
public class HibernateUtil {
    
    private static SessionFactory sessionFactory;

    public static SessionFactory getSessionFactory() {
        if (sessionFactory == null) {
            try {
                // Carica la configurazione e costruisce la factory
                Configuration configuration = new Configuration();
                configuration.configure(); // Cerca hibernate.cfg.xml di default
                
                sessionFactory = configuration.buildSessionFactory();
            } catch (Exception e) {
                e.printStackTrace();
                throw new RuntimeException("Errore inizializzazione Hibernate");
            }
        }
        return sessionFactory;
    }

    public static void shutdown() {
        if (sessionFactory != null) {
            sessionFactory.close(); // Chiude il pool di connessioni
        }
    }
}
\end{lstlisting}

\section{4. Il Repository (CRUD)}

Qui vediamo la gestione manuale della Transazione.
In JDBC scrivevamo SQL (\texttt{INSERT INTO...}). In Hibernate "persistiamo oggetti".

\begin{lstlisting}[language=Java, caption=UserRepository.java]
public class UserRepository {

    // CREATE
    public void save(User user) {
        Transaction transaction = null;
        // Otteniamo una sessione (Try-with-resources per chiuderla alla fine)
        try (Session session = HibernateUtil.getSessionFactory().openSession()) {
            
            // 1. Inizio Transazione
            transaction = session.beginTransaction();
            
            // 2. Salvataggio (L'oggetto diventa PERSISTENT)
            // Hibernate genererà la INSERT INTO users...
            session.persist(user);
            
            // 3. Commit (Le modifiche vanno sul DB)
            transaction.commit();
            
        } catch (Exception e) {
            // 4. Rollback in caso di errore
            if (transaction != null) {
                transaction.rollback();
            }
            e.printStackTrace();
        }
    }

    // READ (Find By ID)
    public User findById(Long id) {
        // Per le letture semplici la transazione è opzionale ma consigliata
        try (Session session = HibernateUtil.getSessionFactory().openSession()) {
            // get() o find() restituiscono l'oggetto o null
            return session.get(User.class, id);
        }
    }

    // READ (Query HQL - Hibernate Query Language)
    public List<User> findAll() {
        try (Session session = HibernateUtil.getSessionFactory().openSession()) {
            // Non stiamo selezionando tabelle, ma oggetti!
            // "FROM User" si riferisce alla CLASSE User, non alla tabella users
            return session.createQuery("FROM User", User.class).list();
        }
    }

    // UPDATE
    public void updateEmail(Long userId, String newEmail) {
        Transaction tx = null;
        try (Session session = HibernateUtil.getSessionFactory().openSession()) {
            tx = session.beginTransaction();

            // A. Carico l'oggetto (Stato: Persistent)
            User user = session.get(User.class, userId);
            
            if (user != null) {
                // B. Modifico il campo
                user.setEmail(newEmail);
                
                // C. NON serve chiamare session.update()!
                // Grazie al "Dirty Checking", Hibernate vede la modifica
                // e lancerà la UPDATE al commit.
            }
            
            tx.commit();
        } catch (Exception e) {
            if (tx != null) tx.rollback();
            e.printStackTrace();
        }
    }
}
\end{lstlisting}

\section{5. Esecuzione: Il Main}

\begin{lstlisting}[language=Java, caption=MainApp.java]
public class MainApp {
    public static void main(String[] args) {
        UserRepository repo = new UserRepository();

        System.out.println("--- START HIBERNATE ---");

        // 1. Creazione
        User user1 = new User("MarioRossi", "mario@test.com");
        repo.save(user1);
        System.out.println("Utente salvato con ID: " + user1.getId());

        // 2. Lettura
        User retrieved = repo.findById(user1.getId());
        System.out.println("Utente letto: " + retrieved);

        // 3. Modifica (Update automatico)
        System.out.println("Modifico email...");
        repo.updateEmail(user1.getId(), "nuova.email@test.com");

        // 4. Lista completa
        List<User> tutti = repo.findAll();
        System.out.println("Utenti nel DB: " + tutti.size());

        // 5. Chiusura Applicazione
        HibernateUtil.shutdown();
    }
}
\end{lstlisting}

\begin{deepdive}{HQL vs SQL}
Nel metodo \texttt{findAll}, abbiamo scritto \texttt{"FROM User"}.
\begin{itemize}
    \item \textbf{SQL:} Lavora su Tabelle e Colonne (\texttt{SELECT * FROM users}).
    \item \textbf{HQL (Hibernate QL):} Lavora su Classi e Campi (\texttt{FROM User}).
\end{itemize}
Hibernate traduce HQL in SQL a runtime. Se un giorno cambi il nome della tabella nel DB, con SQL devi riscrivere le query; con HQL basta cambiare l'annotazione \texttt{@Table} nell'Entity.
\end{deepdive}


\part{Le fondamenta che hanno portato a Spring}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{L'Ecosistema Web: Protocolli e Server}

Ora che abbiamo compilato e pacchettizzato la nostra applicazione, dobbiamo farla parlare con il mondo.
Non importa quanto sia complessa la tua logica di business in Java: se non comprendi come viaggiano i dati sulla rete, non sarai mai in grado di debuggare un problema di connessione, configurare un firewall o progettare una API RESTful corretta.

In questo capitolo esploreremo l'architettura fisica della rete e il linguaggio universale del web: il protocollo HTTP.

\section{Architettura Client-Server: Le basi fisiche}

Il Web si basa su un modello di interazione molto semplice: c'è qualcuno che chiede (Client) e qualcuno che risponde (Server).

\subsection{IP e DNS: L'indirizzo}
Ogni macchina collegata a una rete (Internet o Intranet) possiede un indirizzo IP (es. \texttt{192.168.1.50}). È l'equivalente dell'indirizzo civico di un palazzo.
Poiché gli umani faticano a ricordare numeri, usiamo il \textbf{DNS (Domain Name System)}, che funge da rubrica telefonica: traduce \texttt{google.com} nell'IP reale del server.

\subsection{La Porta (Port): Il varco d'ingresso}
Questo è un concetto vitale per chi sviluppa in Spring Boot.
Se l'IP è l'indirizzo del palazzo, la \textbf{Porta} è il numero dell'interno (o dell'ufficio).
Un server esegue molti servizi contemporaneamente:
\begin{itemize}
    \item Porta 80/443: Standard per il traffico Web (HTTP/HTTPS).
    \item Porta 3306: Standard per MySQL.
    \item Porta 22: SSH (amministrazione remota).
    \item \textbf{Porta 8080:} Standard per i Web Server Java (Tomcat).
\end{itemize}

\begin{interview}{Errore: Address already in use}
Cosa significa l'errore \texttt{BindException: Address already in use} all'avvio di Spring Boot?
Significa che un altro processo sulla tua macchina sta già occupando la porta 8080. Non possono esistere due processi in ascolto sulla stessa porta.
Soluzione: Uccidi il processo zombie o cambia la porta di Spring (\texttt{server.port=8081}).
\end{interview}

\section{Il Protocollo HTTP: La lingua del Web}

L'HyperText Transfer Protocol (HTTP) è un protocollo testuale. Non c'è magia binaria: client e server si scambiano stringhe di testo formattate in modo specifico.
Capire l'anatomia di questi messaggi è prerequisito per capire le Annotazioni di Spring MVC.

\subsection{Anatomia di una REQUEST (Richiesta)}
Quando il browser (o Postman) chiama il server, invia un pacchetto composto da tre parti:

\begin{enumerate}
    \item \textbf{Start Line:} Contiene il \textbf{Metodo} (Verbo), l'\textbf{URI} (il percorso) e la versione HTTP.
    \item \textbf{Headers:} Metadati (chiave-valore). Es: \texttt{Content-Type: application/json} (ti sto mandando un JSON), \texttt{Authorization: Bearer xyz} (sono loggato).
    \item \textbf{Body (Payload):} Il contenuto vero e proprio. Opzionale (es. presente in POST, assente in GET).
\end{enumerate}

\begin{deepdive}{I Verbi HTTP e l'Idempotenza}
Nei colloqui Senior, non chiedono "cos'è una GET", ma "cos'è l'idempotenza".
\begin{itemize}
    \item \textbf{GET:} Legge dati. È \textit{Safe} (non modifica il server) e \textit{Idempotente} (se la chiami 100 volte, il risultato è lo stesso).
    \item \textbf{POST:} Crea una nuova risorsa. \textbf{NON è Idempotente}. Se invii due volte la richiesta di pagamento, paghi due volte.
    \item \textbf{PUT:} Aggiorna una risorsa (sostituzione completa). È \textit{Idempotente} (se imposti \texttt{nome="Mario"} 100 volte, il nome resta "Mario").
    \item \textbf{DELETE:} Cancella una risorsa. È \textit{Idempotente} (cancellare il nulla restituisce sempre successo o 404, ma lo stato del server non cambia dopo la prima volta).
\end{itemize}
\end{deepdive}

\subsection{Anatomia di una RESPONSE (Risposta)}
Il server elabora e risponde con:

\begin{enumerate}
    \item \textbf{Status Line:} Contiene lo \textbf{Status Code} numerico.
    \item \textbf{Headers:} Es. \texttt{Set-Cookie} (salva questo dato), \texttt{Content-Type}.
    \item \textbf{Body:} L'HTML della pagina o il JSON dei dati.
\end{enumerate}

\subsection{Gli Status Codes: La grammatica della risposta}
Non puoi restituire sempre 200 OK. Devi essere semantico.
\begin{itemize}
    \item \textbf{2xx (Successo):} 200 OK (Standard), 201 Created (dopo una POST), 204 No Content (dopo una DELETE).
    \item \textbf{3xx (Redirezione):} 301 Moved Permanently, 302 Found (vai altrove).
    \item \textbf{4xx (Errore Client):} È colpa tua. 400 Bad Request (dati invalidi), 401 Unauthorized (chi sei?), 403 Forbidden (sai chi sono ma non puoi entrare), 404 Not Found.
    \item \textbf{5xx (Errore Server):} È colpa mia. 500 Internal Server Error (NullPointerException non gestita), 503 Service Unavailable.
\end{itemize}

\section{Statelessness e Sessioni}

Una caratteristica fondamentale di HTTP è di essere \textbf{Stateless} (Senza Stato).
Il server non ha memoria. Se fai una richiesta adesso, e ne fai un'altra tra un secondo, il server non sa che sei la stessa persona. Tratta ogni richiesta come se fosse la prima volta assoluta.

\textbf{Il problema:} Come facciamo a mantenere un utente "loggato" o un carrello della spesa pieno mentre navighiamo tra le pagine?

\subsection{La Soluzione Classica: I Cookie e la Sessione (Stateful)}
\begin{enumerate}
    \item Al primo login, il server crea un oggetto \texttt{HttpSession} in memoria RAM e gli assegna un ID unico (es. \texttt{JSESSIONID=123}).
    \item Il server invia questo ID al browser tramite l'header \texttt{Set-Cookie}.
    \item Il browser salva il biscottino e lo rimanda indietro automaticamente \textbf{ad ogni richiesta successiva}.
    \item Il server legge l'ID, recupera la memoria associata e "si ricorda" chi sei.
\end{enumerate}

\subsection{La Soluzione Moderna: Token JWT (Stateless)}
Nelle architetture a Microservizi e Cloud, la sessione server-side è un problema (se ho 10 server, quale server ha la mia sessione in memoria?).
Si preferisce l'approccio \textbf{Token-Based (JWT)}: tutto lo stato è criptato dentro un token che il client conserva e invia ogni volta. Il server non salva nulla in memoria.

\section{Web Server vs Application Server vs Reverse Proxy}

Spesso i termini vengono confusi. Facciamo chiarezza per capire l'architettura di produzione.

\begin{itemize}
    \item \textbf{Web Server (es. Apache HTTPD, Nginx):} 
    È specializzato nel servire contenuti \textbf{statici} (HTML, CSS, Immagini) alla massima velocità. Non sa eseguire Java o logica complessa. Spesso agisce da "portiere".
    
    \item \textbf{Application Server / Servlet Container (es. Apache Tomcat, Jetty):}
    È il motore che sa eseguire codice Java, gestire Servlet e connettersi ai Database. È "l'intelligenza".
\end{itemize}

\begin{interview}{Architettura di Produzione: Il Reverse Proxy}
In produzione, raramente esponi Tomcat (porta 8080) direttamente su Internet. È pericoloso e poco efficiente.
Si usa il pattern \textbf{Reverse Proxy}:
\begin{itemize}
    \item Davanti a tutto c'è \textbf{Nginx} (sulla porta 80/443).
    \item Nginx gestisce la crittografia HTTPS (certificati SSL) e serve le immagini statiche.
    \item Se la richiesta richiede logica Java, Nginx la "gira" (proxy pass) a \textbf{Tomcat} (che sta al sicuro sulla porta interna 8080).
\end{itemize}
Questo aggiunge sicurezza e permette il \textbf{Load Balancing} (Nginx può smistare il traffico su 10 Tomcat diversi).
\end{interview}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Java Enterprise e la Servlet API}

Quando si chiede a un principiante come funziona Spring Boot, di solito risponde: 
\textit{"Parte il metodo main e l'applicazione si avvia."}

Un sviluppatore più esperto invece dirà qualcosa come:
\textit{"Spring Boot avvia un Web Container embedded (come Tomcat), registra la DispatcherServlet, e questa inoltra le richieste ai Controller."}

In questo capitolo togliamo la patina di magia e osserviamo con calma cosa succede davvero sotto al cofano. 
La chiave per capirlo è la \textbf{Servlet API}: il livello più basso su cui si appoggia tutto il modello web di Java.
Ogni concetto che userai in Spring MVC (Header, Cookie, Sessione, Errori, Request/Response) deriva direttamente da qui, e Spring non fa altro che offrirti un modo più elegante per usarli.

\section{Il Web Container (Tomcat): Il motore nascosto}

La Java Standard Edition (J2SE) non sa gestire il web da sola. 
Offre solo le Socket, strumenti troppo basilari per costruire un server HTTP completo.

Per trasformare un'applicazione Java in un vero Web Server serve un software dedicato: il \textbf{Servlet Container} (o Web Container). 
I più diffusi sono Apache Tomcat, Jetty e Undertow.

Sono loro che:
\begin{itemize}
    \item ricevono le richieste HTTP,
    \item creano gli oggetti Request/Response,
    \item gestiscono i thread,
    \item e invocano il tuo codice al momento giusto.
\end{itemize}

\subsection{Il Modello "Thread-per-Request"}

Questa è la caratteristica architetturale più importante del modello servlet. 
Se ne comprendi il funzionamento, capisci metà delle performance di un'app Java.

Come fa Tomcat a gestire centinaia o migliaia di utenti contemporaneamente?

\begin{enumerate}
    \item \textbf{Il Thread Pool:} Quando parte, Tomcat crea un gruppo di thread (di solito circa 200 in Spring Boot) e li tiene pronti in attesa.
    \item \textbf{L'Assegnazione:} Ogni volta che arriva una richiesta HTTP, Tomcat assegna un thread libero per gestirla (es. \texttt{http-nio-8080-exec-1}).
    \item \textbf{Il Blocco:} Quel thread resta dedicato a quella richiesta. Se durante l'elaborazione bisogna attendere (es. lettura di un file grande, chiamata al database), il thread rimane fermo senza poter servire altri utenti.
    \item \textbf{Il Rilascio:} Quando la risposta è pronta, il thread torna nella pool e attende un nuovo lavoro.
\end{enumerate}

\begin{deepdive}{Thread Starvation: il vero limite del modello classico}
Cosa succede se arrivano più richieste dei thread disponibili?

La 201esima richiesta, se il pool ha 200 thread, finisce in una \textbf{coda}. 
Se i thread impiegano troppo a liberarsi (per esempio perché il database risponde lentamente), la coda cresce fino a riempirsi, e Tomcat inizia a rifiutare connessioni con errori come \textit{Connection Refused}.

Le operazioni bloccanti diventano quindi il principale collo di bottiglia della scalabilità. 
È esattamente per superare questo limite che sono nati strumenti non bloccanti come \texttt{WebClient} e lo stack reattivo.
\end{deepdive}

\begin{deepdive}{La novità dei Virtual Threads: lo stesso modello ma senza i suoi limiti}
I Virtual Threads rivoluzionano il modello tradizionale senza costringerti a cambiare stile di programmazione.

\begin{itemize}
    \item \textbf{Costano pochissimo:} Un Virtual Thread pesa molto meno di un thread classico, quindi l'applicazione può crearne anche decine di migliaia.
    \item \textbf{Il blocco non blocca:} Se una chiamata è bloccante (come JDBC o una REST call), il Virtual Thread può essere "sospeso" senza occupare risorse del sistema operativo.
    \item \textbf{Niente pool rigido:} Non serve più limitare i thread a poche centinaia. Si può avere praticamente un thread per ogni richiesta senza intasare la memoria.
    \item \textbf{Starvation ridotta:} Poiché il numero di thread non è più una risorsa scarsa, la probabilità di saturare la capacità del server diminuisce molto.
    \item \textbf{Codice semplice:} Si continua a scrivere codice imperativo, sequenziale, bloccante, ma con una scalabilità molto superiore.
\end{itemize}

\textbf{In breve:} i Virtual Threads mantengono la semplicità del modello servlet tradizionale ma eliminano i suoi principali limiti di performance.
\end{deepdive}

\section{La Servlet: il mattoncino fondamentale}

Una \textbf{Servlet} è una classe Java pensata per ricevere una richiesta HTTP e restituire una risposta. 
Per essere gestita da Tomcat, deve rispettare un contratto stabilito dalla Servlet API: può implementare direttamente 
\texttt{javax.servlet.Servlet} oppure, più spesso, estendere una delle classi già pronte offerte dal framework (come \texttt{HttpServlet}).

\subsection{Il Ciclo di Vita (Lifecycle)}

Le Servlet non vengono create con \texttt{new} dal tuo codice: è Tomcat che decide quando istanziarle e quando eliminarle.

\begin{enumerate}
    \item \textbf{init():} Viene chiamato una sola volta, al momento della creazione. Qui si inizializzano le risorse pesanti. 
    \item \textbf{service():} Viene chiamato per ogni richiesta in arrivo. Tomcat passa due oggetti chiave:
    \begin{itemize}
        \item \texttt{HttpServletRequest}: contiene tutti i dati in arrivo (header, parametri, corpo, cookie).
        \item \texttt{HttpServletResponse}: è l'oggetto su cui scrivere la risposta.
    \end{itemize}
    In base al tipo di richiesta (GET, POST, ecc.), \texttt{service()} delega a \texttt{doGet()} o \texttt{doPost()}.
    \item \textbf{destroy():} Chiamato allo spegnimento dell'applicazione per liberare le risorse.
\end{enumerate}

\begin{interview}{Le Servlet sono Thread-Safe?}
\textbf{No.}

Di solito esiste una sola istanza di una Servlet per tutta l'applicazione, e questa istanza è usata da tanti thread in parallelo. 
Per questo non bisogna mai salvare nei campi della classe dati che appartengono alla singola richiesta.

\begin{lstlisting}
public class BadServlet extends HttpServlet {
    private String user; // Variabile condivisa da tutti i thread!

    protected void doGet(...) {
        this.user = req.getParameter("user"); // Mario sovrascrive Luigi
    }
}
\end{lstlisting}

\textbf{Regola pratica:} le Servlet (e i Controller Spring) devono essere \textbf{stateless}. 
I dati della richiesta devono vivere solo nelle variabili locali dei metodi.
\end{interview}

\section{Dall'origine a Spring: perché serviva qualcosa di meglio}

Per apprezzare la comodità di Spring, basta guardare come si sviluppava prima.

\subsection{Era 1: CGI e Servlet "nude"}

In origine, ogni pagina web era generata da una Servlet.
\begin{lstlisting}
// Java che stampa HTML. Molto difficile da mantenere.
out.println("<html><body><h1>Ciao " + user + "</h1></body></html>");
\end{lstlisting}

Persino cambiare un colore richiedeva modificare codice Java e ricompilare.

\subsection{Era 2: JSP (JavaServer Pages)}

Per semplificare, si passò a scrivere HTML con dentro pezzi di Java.
\begin{lstlisting}
<html>
    <body>
        <h1>Ciao <\%= request.getParameter("user") \%></h1>
    </body>
</html>
\end{lstlisting}

Questo mescolava logica e grafica, generando il famoso \textit{spaghetti code}.

\subsection{Era 3: MVC (Model-View-Controller)}

La soluzione fu separare i ruoli:
\begin{itemize}
    \item \textbf{Model}: i dati dell'applicazione,
    \item \textbf{View}: la rappresentazione grafica,
    \item \textbf{Controller}: la Servlet che riceve la richiesta, chiama i servizi e passa i dati alla View.
\end{itemize}

\section{Il Pattern Front Controller e la DispatcherServlet}

Nel modello MVC originale bisognava configurare una Servlet per ogni funzionalità nel file \texttt{web.xml}:
\texttt{/login} $\to$ \texttt{LoginServlet} \\
\texttt{/cart} $\to$ \texttt{CartServlet} \\
\texttt{/home} $\to$ \texttt{HomeServlet}

Tutte queste Servlet duplicavano codice per logging, sicurezza, eccezioni, gestione degli input...

\subsection{Spring semplifica tutto: una Servlet per governarle tutte}

Spring applica il pattern \textbf{Front Controller}. 
Esiste una sola Servlet reale registrata nel Web Container: la \textbf{DispatcherServlet}.

\begin{enumerate}
    \item \textbf{Centralizza:} tutte le richieste entrano da lei.
    \item \textbf{Indirizza:} capisce quale Controller deve rispondere grazie alle mappature interne (\textbf{HandlerMapping}).
    \item \textbf{Standardizza:} gestisce conversioni, errori, JSON, sicurezza e molto altro, lasciando al Controller solo la logica applicativa.
\end{enumerate}

Ecco perché in Spring Boot non configuri più file \texttt{web.xml} e non estendi \texttt{HttpServlet}: 
Spring nasconde i dettagli della Servlet API, ma sotto il cofano Tomcat sta ancora invocando \texttt{doGet()} e \texttt{doPost()}.

\section{Riepilogo del Flusso: Prima di Spring vs Con Spring}

Comprendere tutti i pezzi è difficile finché non si osserva il flusso completo, confrontando come funzionava 
un'applicazione web in Java \textbf{prima di Spring} e come funziona \textbf{con Spring e Spring Boot}.
Questa sezione mette ordine mostrando i passaggi essenziali e il ruolo di ogni componente.

\subsection{Prima di Spring: Il Flusso Basato su Servlet Pure}

Senza Spring, il Web Container (Tomcat, Jetty, ecc.) era responsabile di quasi tutto. 
Lo sviluppatore doveva configurare manualmente ogni Servlet e occuparsi della maggior parte della logica.

\begin{enumerate}
    \item \textbf{Il Browser invia una richiesta HTTP.}
    \item \textbf{Il Web Container (Tomcat) riceve la richiesta} e crea gli oggetti
    \texttt{HttpServletRequest} e \texttt{HttpServletResponse}.
    \item \textbf{Tomcat sceglie quale Servlet invocare} consultando il file di configurazione \texttt{web.xml}.
    \item \textbf{La Servlet elabora la richiesta}: legge parametri, interagisce con servizi, gestisce errori.
    \item \textbf{La Servlet genera direttamente l'output}: HTML, JSON o qualunque testo.
    \item \textbf{Tomcat invia la risposta al client}.
\end{enumerate}

In questo modello:
\begin{itemize}
    \item ogni URL richiedeva una Servlet dedicata;
    \item la logica era spesso mescolata con la presentazione;
    \item bisognava gestire manualmente conversioni, errori, sicurezza, mapping, factory di oggetti, ecc.;
    \item il codice diventava velocemente difficile da mantenere.
\end{itemize}

\subsection{Con Spring: Il Flusso Mediato dalla DispatcherServlet}

Spring introduce una struttura che ripulisce il caos delle Servlet manuali. 
Al posto di decine di Servlet, ce n'è una sola: la \textbf{DispatcherServlet}.

\begin{enumerate}
    \item \textbf{Il Browser invia una richiesta HTTP.}
    \item \textbf{Tomcat (embedded) riceve la richiesta} e crea gli oggetti standard Request/Response.
    \item \textbf{Tomcat invoca la DispatcherServlet}, che è l'unica Servlet registrata da Spring.
    \item \textbf{La DispatcherServlet analizza la richiesta} (URL, metodo, parametri, header).
    \item \textbf{Trova il Controller corretto} consultando i suoi meccanismi interni (HandlerMapping).
    \item \textbf{Invoca il metodo del Controller} passando i dati già convertiti (es. JSON $\rightarrow$ POJO).
    \item \textbf{Il Controller restituisce un oggetto Java} (Model, DTO, ecc.).
    \item \textbf{La DispatcherServlet costruisce la risposta HTTP} (HTML, JSON, ecc.).
    \item \textbf{La risposta torna a Tomcat}, che la invia al client.
\end{enumerate}

In questo modello:
\begin{itemize}
    \item esiste una sola Servlet reale, la DispatcherServlet;
    \item i Controller sono semplici classi Java senza responsabilità infrastrutturali;
    \item Spring si occupa della conversione degli input, della serializzazione in output, della gestione degli errori, del binding dei parametri;
    \item l'applicazione è più ordinata, modulare e testabile.
\end{itemize}

\subsection{Vista d'insieme: Prima vs Dopo}

\paragraph{Prima di Spring}
\begin{center}
\texttt{Browser $\rightarrow$ Tomcat $\rightarrow$ TuaServlet $\rightarrow$ Tomcat $\rightarrow$ Browser}
\end{center}

\paragraph{Con Spring}
\begin{center}
\texttt{Browser $\rightarrow$ Tomcat $\rightarrow$ DispatcherServlet $\rightarrow$ Controller $\rightarrow$ DispatcherServlet $\rightarrow$ Tomcat $\rightarrow$ Browser}
\end{center}

La differenza fondamentale è che Spring prende il posto di tutte le Servlet manuali e si occupa lui della parte "difficile". 
Tu scrivi solo i Controller, mentre DispatcherServlet gestisce tutto il resto in modo coerente, standardizzato e pulito.



% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Architettura a Strati (N-Tier) in Spring}

Abbiamo appreso come il Web comunica tramite HTTP e come Java gestisce queste comunicazioni tramite le Servlet. Tuttavia, in un'applicazione Enterprise, sapere "come ricevere una richiesta" è solo l'inizio. La sfida principale è organizzare la complessità.

Se scrivessimo codice di validazione, logica di business, calcoli e query SQL tutto all'interno di un'unica classe, creeremmo quello che viene definito \textbf{"God Class Anti-Pattern"}. Un codice monolitico, fragile e impossibile da testare.

La soluzione standard nell'ingegneria del software è l'\textbf{Architettura a Strati (Layered Architecture)}.

\section{Il Principio: Separation of Concerns (SoC)}

Il principio guida è la \textbf{Separazione delle Responsabilità}. Ogni componente deve avere un unico motivo per cambiare.
Possiamo immaginare l'architettura di Spring come un ristorante ben organizzato:

\begin{enumerate}
    \item \textbf{La Reception (DispatcherServlet):} Accoglie i clienti e li smista ai tavoli corretti.
    \item \textbf{Il Cameriere (@Controller):} Prende l'ordine specifico, controlla che sia comprensibile e lo porta in cucina.
    \item \textbf{Lo Chef (@Service):} Esegue la ricetta. Non vede il cliente, si concentra solo sulla preparazione.
    \item \textbf{Il Magazziniere (@Repository):} Fornisce gli ingredienti grezzi presi dagli scaffali (Database).
\end{enumerate}

\section{1. Presentation Layer (L'Interfaccia)}

È lo strato più esterno. In Spring, questo livello non è gestito da un singolo componente, ma dalla collaborazione di due attori distinti: l'infrastruttura e l'applicativo.

\subsection{L'Infrastruttura: La \texttt{DispatcherServlet}}
La \texttt{DispatcherServlet} è il vero "Front Controller". È una \textbf{Servlet} standard di Java EE che funge da punto di ingresso unico.
\begin{itemize}
    \item \textbf{Routing:} Analizza l'URL in ingresso e consulta l'\textit{Handler Mapping} per decidere quale Controller chiamare.
    \item \textbf{Gestione degli Errori:} Intercetta le eccezioni non gestite per mostrare pagine di errore o JSON coerenti.
    \item \textbf{Gestione della Risposta:} Scrive fisicamente i byte della risposta HTTP (headers, status code 200/404/500).
\end{itemize}

\subsection{L'Applicativo: Il \texttt{@Controller} / \texttt{@RestController}}
Il Controller è un semplice oggetto Java (POJO) che definisce l'interfaccia dell'applicazione.
\textbf{Responsabilità:}
\begin{itemize}
    \item \textbf{Mapping:} Definisce la "forma" delle API (es. \texttt{@GetMapping("/users")}).
    \item \textbf{Deserializzazione:} Riceve i dati in ingresso. Qui entra in gioco il pattern \textbf{DTO (Data Transfer Object)}. Il Controller non dovrebbe ricevere le entità del database, ma oggetti "usa e getta" ottimizzati per la richiesta.
    \item \textbf{Validazione:} Verifica la correttezza formale (es. "L'email ha una @?", "La password è di 8 caratteri?").
    \item \textbf{Delega:} Passa i dati puliti al Service Layer.
\end{itemize}

\begin{quote}
\textbf{Nota Bene:} Il Controller è "ignorante" riguardo alla logica di business. Non sa \textit{come} si crea un utente, sa solo \textit{chi} chiamare per farlo.
\end{quote}

\section{2. Business Logic Layer (Il Cuore)}

Questo livello è rappresentato dalle classi annotate con \textbf{\texttt{@Service}}. Qui risiede il valore dell'applicazione.

\textbf{Responsabilità:}
\begin{itemize}
    \item \textbf{Logica di Dominio:} Implementa le regole aziendali (es. "Non si possono emettere fatture nei giorni festivi").
    \item \textbf{Orchestrazione:} Coordina più Repository o servizi esterni (es. "Salva l'ordine su DB" $\rightarrow$ "Scala i soldi dalla carta di credito" $\rightarrow$ "Invia Email").
    \item \textbf{Gestione delle Transazioni (\texttt{@Transactional}):} È fondamentale. Il Service garantisce l'atomicità: se l'invio dell'email fallisce, il salvataggio dell'ordine deve essere annullato (Rollback).
    \item \textbf{Indipendenza:} Il codice del Service non deve mai dipendere da oggetti HTTP (come \texttt{HttpServletRequest}).
\end{itemize}

\section{3. Persistence Layer (I Dati)}

Questo livello gestisce l'accesso ai dati ed è annotato con \textbf{\texttt{@Repository}}.
In Spring Data JPA, questo strato è spesso definito tramite \textbf{Interfacce}.

\textbf{Responsabilità:}
\begin{itemize}
    \item \textbf{CRUD:} Fornire operazioni di base (Create, Read, Update, Delete).
    \item \textbf{Astrazione:} Nascondere i dettagli del database (SQL, NoSQL, File). Il Service chiede "dammi l'utente", il Repository decide se fare una \texttt{SELECT} SQL o una chiamata a MongoDB.
    \item \textbf{Traduzione Eccezioni:} Converte gli errori tecnici del driver (es. \texttt{ConstraintViolationException}) in eccezioni generiche di Spring.
\end{itemize}

\section{Riepilogo del Flusso di una Richiesta}

\begin{enumerate}
    \item \textbf{HTTP Request} $\rightarrow$ Arriva alla \texttt{DispatcherServlet}.
    \item \texttt{DispatcherServlet} $\rightarrow$ Trova e chiama il \texttt{UserController}.
    \item \texttt{UserController} $\rightarrow$ Valida il DTO e chiama \texttt{UserService}.
    \item \texttt{UserService} $\rightarrow$ Apre una transazione e chiama \texttt{UserRepository}.
    \item \texttt{UserRepository} $\rightarrow$ Esegue SQL sul Database e restituisce una \texttt{Entity}.
    \item \textbf{Ritorno:} I dati risalgono la catena, vengono convertiti in JSON e inviati come \textbf{HTTP Response}.
\end{enumerate}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Dal Codice Rigido all'Inversion of Control}

Siamo arrivati al culmine della nostra preparazione. Abbiamo un'architettura a strati, sappiamo come funziona il web, ma c'è ancora un problema fondamentale nel modo in cui scriviamo codice Java "standard".

Il problema è la parola chiave più comune del linguaggio: \textbf{\texttt{new}}.

In questo capitolo vedremo perché istanziare manualmente le dipendenze è il nemico numero uno della manutenibilità e come un semplice cambio di prospettiva (l'Inversione del Controllo) abbia dato vita a tutto l'ecosistema Spring.

\section{Analisi del Tight Coupling (Accoppiamento Stretto)}

Torniamo al nostro Business Layer. Immagina di dover scrivere un servizio per processare pagamenti.
L'approccio istintivo di un programmatore Java base è questo:

\begin{lstlisting}[caption=Il problema della dipendenza diretta]
public class PaymentService {
    // Dipendenza diretta: PaymentService CONOSCE e CREA PaypalProvider
    private PaypalProvider provider = new PaypalProvider();

    public void pay(double amount) {
        provider.sendMoney(amount);
    }
}
\end{lstlisting}

Questo codice sembra innocuo, ma architettonicamente è un disastro. Perché?
Si è creato un \textbf{Tight Coupling} (Accoppiamento Stretto) tra \texttt{PaymentService} e \texttt{PaypalProvider}.

\subsection{I 3 problemi capitali del "new"}
\begin{enumerate}
    \item \textbf{Rigidità:} Se domani l'azienda decide di passare da PayPal a Stripe, devi aprire la classe \texttt{PaymentService}, modificare il codice sorgente, ricompilare e ridistribuire l'applicazione. Hai violato l'Open/Closed Principle.
    \item \textbf{Configurazione Impossibile:} Se \texttt{PaypalProvider} ha bisogno di una password per funzionare, chi gliela passa? Il \texttt{PaymentService} dovrebbe leggere file di configurazione? Non è il suo lavoro.
    \item \textbf{Testabilità (Il punto critico):} Questo è il motivo principale per cui usiamo Spring.
\end{enumerate}

\section{L'Incubo della Testabilità}

Proviamo a scrivere uno Unit Test per il codice sopra.

\begin{lstlisting}
@Test
public void testPayment() {
    PaymentService service = new PaymentService();
    service.pay(100.0); 
    // AIUTO! Questo metodo chiama DAVVERO i server di PayPal!
    // Stiamo addebitando soldi veri sulla carta di credito durante i test.
}
\end{lstlisting}

Poiché \texttt{PaymentService} crea l'istanza di \texttt{PaypalProvider} al suo interno tramite \texttt{new}, non c'è modo per noi (dall'esterno) di intervenire e sostituire PayPal con un oggetto finto (Mock) per il test.
Siamo bloccati. Il codice non è testabile in isolamento.

\section{Inversion of Control (IoC): La Filosofia}

Per risolvere il problema, dobbiamo ribaltare il paradigma.
Invece di lasciare che sia l'oggetto a cercare e creare le sue dipendenze (Controllo Attivo), facciamo in modo che le dipendenze gli vengano fornite dall'esterno (Controllo Passivo).

Questo principio si chiama \textbf{Inversion of Control (IoC)}.
Spesso viene riassunto con l'\textbf{Hollywood Principle}:
\begin{quote}
    \textit{"Non chiamarci, ti chiameremo noi."}
\end{quote}

In termini software:
\begin{itemize}
    \item \textbf{Senza IoC:} La classe A chiede "Ho bisogno di un oggetto B, me lo creo".
    \item \textbf{Con IoC:} La classe A dichiara "Ho bisogno di un oggetto B". Qualcuno (un Container, un Framework, o il Main) glielo passerà quando serve.
\end{itemize}

\section{Dependency Injection (DI): La Tecnica}

L'IoC è il principio astratto. La \textbf{Dependency Injection (DI)} è il modo pratico in cui lo implementiamo in Java.
L'idea è semplice: spostiamo la creazione delle dipendenze fuori dalla classe e le passiamo ("iniettiamo") attraverso il costruttore o i setter.

\subsection{Refactoring verso la DI}

Passo 1: Astrarre la dipendenza (usare un'interfaccia).
\begin{lstlisting}
public interface PaymentProvider {
    void sendMoney(double amount);
}
\end{lstlisting}

Passo 2: Usare la Constructor Injection.
\begin{lstlisting}[caption=Codice disaccoppiato con DI]
public class PaymentService {
    private final PaymentProvider provider;

    // Non uso 'new'. Chiedo 'chiunque implementi l'interfaccia'.
    public PaymentService(PaymentProvider provider) {
        this.provider = provider;
    }

    public void pay(double amount) {
        provider.sendMoney(amount);
    }
}
\end{lstlisting}

\subsection{Il Risultato: Flessibilità Totale}
Ora guardiamo cosa succede.

\textbf{In Produzione:}
\begin{lstlisting}
PaymentProvider realPaypal = new PaypalProvider("api-key-reale");
PaymentService service = new PaymentService(realPaypal);
\end{lstlisting}

\textbf{Nei Test:}
\begin{lstlisting}
// Posso passare un oggetto finto che non chiama internet!
PaymentProvider mockProvider = new MockPaymentProvider();
PaymentService service = new PaymentService(mockProvider);
\end{lstlisting}

Abbiamo disaccoppiato la logica di business (\texttt{PaymentService}) dall'implementazione tecnica (\texttt{PaypalProvider}).

\section{Il ruolo del Container (Spring)}

La Dependency Injection è bellissima, ma sposta il problema un livello più in alto.
Chi fa \texttt{new}? Chi collega tutti questi oggetti?

Se hai 100 classi, scrivere a mano nel \texttt{main} tutto il cablaggio è un incubo:
\begin{lstlisting}
Repo r = new Repo();
Service s = new Service(r);
Controller c = new Controller(s);
...
\end{lstlisting}

Qui entra in gioco \textbf{Spring Framework}.
Spring è, essenzialmente, un gigantesco \textbf{Container IoC} (o DI Container).

\begin{enumerate}
    \item Tu dichiari le classi (i Bean) e le loro dipendenze (tramite annotazioni o costruttori).
    \item All'avvio dell'applicazione, Spring legge tutto, crea le istanze nell'ordine giusto e le inietta dove servono.
    \item Tu non scrivi mai più \texttt{new Service()}. Chiedi a Spring l'istanza pronta.
\end{enumerate}

\begin{deepdive}{Riassunto: Perché Spring?}
Ora hai la risposta completa per il colloquio.
Usiamo Spring perché fornisce un \textbf{Container IoC} che gestisce automaticamente la \textbf{Dependency Injection}.
Questo ci permette di scrivere codice \textbf{Disaccoppiato} (Loose Coupling) e facilmente \textbf{Testabile}, delegando al framework la gestione del ciclo di vita e della configurazione degli oggetti.
\end{deepdive}

\part{Ecosistema Spring}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Guida Completa alle Dipendenze Maven}
Selezionare le dipendenze su \textit{Spring Initializr} può sembrare un gioco a crocette, ma ogni spunta porta con sé un intero ecosistema. In questo capitolo analizziamo nel dettaglio le dipendenze standard di mercato per lo sviluppo Enterprise, divise per area di competenza.

\section{Comprendere gli Scope di Maven}
Prima di vedere le librerie, è fondamentale capire \textit{quando} queste vengono caricate. Inserire una dipendenza nello scope sbagliato può gonfiare il JAR finale o causare crash all'avvio.

\begin{itemize}
    \item \textbf{compile} (Default): La libreria serve per compilare il codice ed è presente nel JAR finale. (Es. \texttt{spring-boot-starter-web}).
    \item \textbf{runtime}: La libreria NON serve per compilare (il codice Java non la vede direttamente), ma serve all'esecuzione. (Es. Driver JDBC, Logback).
    \item \textbf{provided}: La libreria serve per compilare, ma ci si aspetta che l'ambiente dove girerà l'app la fornisca. (Es. \texttt{lombok}, Server Tomcat esterno).
    \item \textbf{test}: Disponibile solo nella cartella \texttt{src/test}. (Es. \texttt{JUnit}, \texttt{Mockito}).
\end{itemize}

% -----------------------------------------------------------
% AREA WEB
% -----------------------------------------------------------
\section{Area 1: Sviluppo Web e API}

\subsection{Standard MVC (Imperativo)}
\textbf{Quando usarlo:} Per il 90\% delle applicazioni REST API standard, architettura bloccante (thread-per-request).

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
\end{lstlisting}

\textbf{Il "Calderone" include:}
\begin{enumerate}
    \item \textbf{Spring MVC}: Il core del framework (Controller, DispatcherServlet).
    \item \textbf{Tomcat (Embedded)}: Il server web di default.
    \item \textbf{Jackson (ObjectMapper)}: Per la serializzazione JSON automatica.
    \item \textbf{Logback}: Framework di logging.
\end{enumerate}

\subsection{Reactive Web (WebFlux)}
\textbf{Quando usarlo:} Applicazioni ad alta concorrenza, streaming dati, chat, architettura non bloccante (Event Loop).

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
\end{lstlisting}

\begin{deepdive}{Web vs WebFlux}
\textbf{Attenzione:} Non mischiarli se non sai esattamente cosa stai facendo.
\begin{itemize}
    \item \texttt{starter-web} usa \textbf{Tomcat} e l'API Servlet (Bloccante).
    \item \texttt{starter-webflux} usa \textbf{Netty} (Non bloccante/Asincrono).
\end{itemize}
Se li includi entrambi, Spring Boot di default configurerà l'applicazione come MVC (Tomcat), "spegnendo" la parte reattiva di default a meno di configurazioni specifiche.
\end{deepdive}

% -----------------------------------------------------------
% AREA DATI
% -----------------------------------------------------------
\section{Area 2: Persistenza e Dati}

\subsection{JPA e Database Relazionali}
Per interagire con SQL Server, MySQL, Postgres, Oracle.

\begin{lstlisting}[language=XML]
<!-- 1. ORM e Astrazioni -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- 2. Driver (Sceglierne UNO solo) -->
<dependency>
    <groupId>com.mysql</groupId> <!-- Oppure org.postgresql -->
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>
\end{lstlisting}

\textbf{Cosa succede sotto il cofano:}
\begin{itemize}
    \item Viene avviato \textbf{HikariCP} (Connection Pool).
    \item Viene configurato \textbf{Hibernate Core} come implementazione JPA.
    \item Vengono scansionati i \texttt{Repository} per creare le query automaticamente.
\end{itemize}

\subsection{Database Migrations (Flyway)}
In produzione non si usa \texttt{ddl-auto=update}. Si usano strumenti di versionamento del DB.

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
<!-- Se usi MySQL 8+ o MariaDB recenti potrebbe servire anche: -->
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-mysql</artifactId>
</dependency>
\end{lstlisting}

\begin{interview}{Perché usare Flyway invece di Hibernate ddl-auto?}
Hibernate tenta di indovinare come aggiornare lo schema, ma su database complessi può fare danni (es. droppare colonne con dati). Flyway esegue script SQL numerati (es. \texttt{V1\_\_init.sql}, \texttt{V2\_\_add\_column.sql}) in ordine garantito, assicurando che tutti gli ambienti (Dev, Test, Prod) abbiano esattamente lo stesso schema.
\end{interview}

\subsection{Redis (Cache e Sessioni)}
Per caching veloce o gestione sessioni distribuite.

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
\end{lstlisting}
\textbf{Nota:} Include i client \textbf{Lettuce} o \textbf{Jedis} per connettersi a Redis.

% -----------------------------------------------------------
% AREA UTILITY
% -----------------------------------------------------------
\section{Area 3: Utility e Qualità del Codice}

\subsection{Lombok (Riduzione Boilerplate)}
Essenziale per pulire il codice da getter/setter/costruttori.

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional> <!-- Non serve a chi usa la tua libreria -->
</dependency>
\end{lstlisting}

\subsection{Validazione Dati (JSR-380)}
Per usare annotazioni come \texttt{@NotNull}, \texttt{@Email}, \texttt{@Size} nei DTO. Dalla versione Spring Boot 2.3 non è più incluso in \texttt{web}, va aggiunto a parte!

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
\end{lstlisting}

\subsection{MapStruct (Mapping DTO $\leftrightarrow$ Entity)}
Lo standard industriale per convertire Entità in DTO e viceversa. Molto più performante di \textit{ModelMapper} perché genera codice Java puro in compilazione, senza usare Reflection a runtime.

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct</artifactId>
    <version>1.5.5.Final</version>
</dependency>
<!-- NOTA: Richiede configurazione nel plugin maven-compiler per funzionare con Lombok -->
\end{lstlisting}

% -----------------------------------------------------------
% AREA SICUREZZA
% -----------------------------------------------------------
\section{Area 4: Sicurezza}

\subsection{Spring Security}
Il framework di sicurezza de-facto.

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
\end{lstlisting}
\textbf{Effetto immediato:} Al riavvio dell'app, tutte le chiamate HTTP richiedono autenticazione (Basic Auth) e viene generata una password nella console.

\subsection{Gestione JWT (JSON Web Tokens)}
Spring Security non ha supporto nativo completo per \textbf{generare} JWT (lo ha per validarli via OAuth2 Resource Server). Spesso si usano librerie esterne per crearli e firmarli.

\begin{lstlisting}[language=XML]
<!-- Libreria standard per creare/parsare JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
\end{lstlisting}

% -----------------------------------------------------------
% AREA OPS
% -----------------------------------------------------------
\section{Area 5: Monitoring e Ops}

\subsection{Spring Boot Actuator}
Fondamentale per andare in produzione (Kubernetes, AWS).

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
\end{lstlisting}

\textbf{Cosa offre:}
\begin{itemize}
    \item Endpoint \texttt{/actuator/health}: Dice al load balancer se l'app è viva.
    \item Endpoint \texttt{/actuator/metrics}: Espone metriche (CPU, RAM, Thread) per Prometheus/Grafana.
    \item Endpoint \texttt{/actuator/env}: Mostra le proprietà di configurazione caricate.
\end{itemize}

% -----------------------------------------------------------
% AREA TESTING
% -----------------------------------------------------------
\section{Area 6: Testing}

\begin{lstlisting}[language=XML]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
\end{lstlisting}

\textbf{Il "Calderone" di Test include:}
\begin{center}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{deepblue} \textcolor{white}{\textbf{Libreria}} & \textcolor{white}{\textbf{Scopo}} \\ \hline
\textbf{JUnit 5} & Motore di esecuzione dei test (Jupiter). \\ \hline
\textbf{Mockito} & Framework per creare oggetti finti (Mock) e simulare comportamenti. \\ \hline
\textbf{AssertJ} & Libreria per asserzioni fluenti (es. \texttt{assertThat(result).isEqualTo("OK")}). \\ \hline
\textbf{Hamcrest} & Libreria di "matchers" (usata spesso con MockMvc). \\ \hline
\textbf{JSONassert} & Per verificare che due stringhe JSON siano uguali (ignorando l'ordine dei campi). \\ \hline
\textbf{Spring Test} & Utilities per caricare l'ApplicationContext durante i test (\texttt{@SpringBootTest}). \\ \hline
\end{tabularx}
\end{center}

\begin{deepdive}{Escludere Vintage Engine}
Nelle versioni recenti di Spring Boot, JUnit 4 è supportato via "Vintage Engine". Se usi solo JUnit 5, puoi escluderlo per pulizia:
\begin{lstlisting}[language=XML, basicstyle=\ttfamily\tiny]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.junit.vintage</groupId>
            <artifactId>junit-vintage-engine</artifactId>
        </exclusion>
    </exclusions>
</dependency>
\end{lstlisting}
\end{deepdive}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Spring Core e Inversion of Control}

Spring non è solo una collezione di librerie, è un modo diverso di concepire il flusso di un'applicazione. Al centro di tutto c'è lo \textbf{Spring Container}, che gestisce la creazione e il cablaggio degli oggetti (Bean).

\section{IoC Container: BeanFactory vs ApplicationContext}

L'\textbf{Inversion of Control (IoC)} è il principio secondo cui il controllo del flusso del programma non è in mano allo sviluppatore, ma al framework. "Don't call us, we'll call you".

In Spring, il container IoC è responsabile di istanziare, configurare e assemblare i Bean. Esistono due interfacce principali:

\begin{enumerate}
    \item \textbf{BeanFactory:} L'interfaccia radice. Fornisce il meccanismo di base per la DI.
    \begin{itemize}
        \item Caricamento \textbf{Lazy}: I bean vengono creati solo quando richiesti con \texttt{getBean()}.
        \item Usata raramente oggi (solo in dispositivi con risorse estremamente limitate).
    \end{itemize}
    \item \textbf{ApplicationContext:} Estende BeanFactory. È il container utilizzato nelle applicazioni Enterprise.
    \begin{itemize}
        \item Caricamento \textbf{Eager}: I bean Singleton vengono istanziati all'avvio dell'applicazione (permettendo di rilevare subito errori di configurazione).
        \item Aggiunge supporto per Eventi, AOP, Internazionalizzazione (i18n).
    \end{itemize}
\end{enumerate}

\section{Dependency Injection: Constructor vs Setter vs Field}

Se IoC è il principio (la filosofia), la \textbf{Dependency Injection (DI)} è il pattern implementativo.
Esistono tre modi per iniettare le dipendenze, ma non sono equivalenti.

\subsection{1. Field Injection (Sconsigliata)}

Questa metodologia è estremamente diffusa nei tutorial online per la sua brevità, ma in ambito professionale è considerata una \textbf{cattiva pratica} (\textit{"Bad Smell"}) e dovrebbe essere evitata.

\begin{lstlisting}[language=Java, frame=single, basicstyle=\small\ttfamily]
@Service
public class OrderService {
    @Autowired
    private UserRepository repo; // Field Injection
}
\end{lstlisting}

\subsubsection*{Cosa succede "Dietro le Quinte"?}

L'apparente semplicità della Field Injection nasconde un processo intrusivo basato sulla \textbf{Java Reflection API}. Quando Spring incontra l'annotazione \texttt{@Autowired} su un campo privato, esegue una serie di operazioni che bypassano le normali regole di incapsulamento di Java:

\begin{enumerate}
    \item \textbf{Istanziazione del Bean:} Spring crea un'istanza di \texttt{OrderService} chiamando il costruttore di default (spesso vuoto o implicito). In questo preciso momento, l'oggetto esiste ma è in uno stato inconsistente: il campo \texttt{repo} è ancora \texttt{null}.
    \item \textbf{Scansione e Reflection:} Il container ispeziona la classe, individua il campo annotato e utilizza la \textit{Reflection} per forzarne l'accessibilità. Esegue un'operazione equivalente a \texttt{field.setAccessible(true)}, rendendo di fatto accessibile ciò che avevi dichiarato \texttt{private}.
    \item \textbf{Iniezione Forzata:} Spring inietta l'istanza di \texttt{UserRepository} direttamente nel campo, modificando lo stato interno dell'oggetto dall'esterno.
\end{enumerate}

\subsubsection*{Perché è considerata "Bad Practice"?}

Capire il meccanismo interno chiarisce perché questo approccio è sconsigliato:

\begin{itemize}
    \item \textbf{Violazione dell'Incapsulamento:} Stai permettendo al framework di violare la privacy dell'oggetto, modificandone i campi senza passare per un costruttore o un metodo setter.
    \item \textbf{Difficoltà nei Test Unitari:} Poiché non esiste un costruttore per passare le dipendenze (mock), per testare questa classe sei costretto a usare a tua volta la Reflection o ad avviare l'intero contesto di Spring (test di integrazione) anche per logiche semplici.
    \item \textbf{Impossibilità di usare \texttt{final}:} I campi iniettati in questo modo non possono essere dichiarati \texttt{final}, rendendo l'oggetto mutabile e potenzialmente non thread-safe.
    \item \textbf{Rischio di NullPointerException:} Se istanzi la classe manualmente (es. \texttt{new OrderService()}) senza usare il container di Spring, il campo \texttt{repo} rimarrà \texttt{null}, causando errori a runtime.
\end{itemize}

\subsection{2. Setter Injection (Per dipendenze opzionali)}
Utile se la dipendenza può cambiare a runtime o non è strettamente necessaria.
\begin{lstlisting}
private UserRepository repo;

@Autowired
public void setRepo(UserRepository repo) {
    this.repo = repo;
}
\end{lstlisting}

\subsection{3. Constructor Injection (Raccomandata)}
È lo standard industriale moderno (e da Spring 4.3 \texttt{@Autowired} è opzionale se c'è un solo costruttore).
\begin{lstlisting}
@Service
public class OrderService {
    private final UserRepository repo; // Immutabile!

    public OrderService(UserRepository repo) {
        this.repo = repo;
    }
}
\end{lstlisting}
\textbf{Vantaggi:} Garantisce che l'oggetto sia sempre in uno stato valido (non può esistere senza le sue dipendenze), permette l'uso di \texttt{final} e facilita i test (basta passare un mock nel costruttore).

\section{Spring Beans: Scopes}

Lo \textbf{Scope} definisce il ciclo di vita e la visibilità di un Bean.

\begin{interview}{Qual è la differenza tra Singleton e Prototype?}
\begin{itemize}
    \item \textbf{Singleton (Default):} Spring crea \textbf{una sola istanza} del Bean per container. Ogni volta che viene richiesto, viene restituito lo stesso oggetto condiviso.
    \begin{itemize}
        \item \textbf{Attenzione:} I bean Singleton devono essere \textbf{Stateless} (senza stato modificabile). Se salvi dati dell'utente in un campo di un Singleton, avrai gravi problemi di concorrenza (tutti gli utenti vedranno i dati dell'altro).
    \end{itemize}
    \item \textbf{Prototype:} Spring crea una \textbf{nuova istanza} ogni volta che il bean viene richiesto.
    \item \textbf{Web Scopes:} \texttt{Request} (uno per richiesta HTTP), \texttt{Session} (uno per sessione utente), \texttt{Application}.
\end{itemize}
\end{interview}

\section{Lazy Initialization e Dipendenze Circolari}

Di default, Spring Boot inizializza tutti i bean all'avvio (Eager). Questo è ottimo per rilevare errori subito, ma può rallentare lo startup.
L'annotazione \texttt{@Lazy} indica a Spring di creare il bean solo quando viene richiesto per la prima volta.

\begin{interview}{Come risolvi l'errore "BeanCurrentlyInCreationException"?}
Questo errore indica una \textbf{Dipendenza Circolare}: A dipende da B, e B dipende da A.
Spring non riesce a istanziare A perché gli serve B, ma non può creare B perché gli serve A.

\textbf{Soluzione:}
\begin{enumerate}
    \item \textbf{Refactoring (Migliore):} Riprogettare le classi per eliminare il ciclo (spesso indica cattivo design).
    \item \textbf{@Lazy (Workaround):} Iniettare una delle dipendenze con \texttt{@Lazy}.
\end{enumerate}

\begin{lstlisting}
@Service
public class ServiceA {
    private final ServiceB serviceB;
    
    // Spring inietta un Proxy al posto dell'oggetto reale.
    // L'oggetto reale ServiceB verra' creato solo alla prima chiamata metodo.
    public ServiceA(@Lazy ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}
\end{lstlisting}
\end{interview}

\section{Lifecycle Hooks: @PostConstruct e @PreDestroy}

Un Bean non viene solo fatto con \texttt{new}. Attraversa un ciclo complesso.

\textbf{Il Ciclo di Vita Semplificato:}
\begin{enumerate}
    \item \textbf{Istanziazione:} Spring chiama il costruttore.
    \item \textbf{Popolamento Proprietà:} Spring inietta le dipendenze.
    \item \textbf{Post-Initialization (@PostConstruct):} Qui puoi eseguire logica di avvio (es. riempire una cache). Nota: Non puoi farlo nel costruttore perché le dipendenze potrebbero non essere ancora pronte.
    \item \textbf{Bean Ready:} Il bean è in uso.
    \item \textbf{Pre-Destruction (@PreDestroy):} Prima che il container si spenga, Spring chiama questo metodo per pulire le risorse (chiudere connessioni, thread pool).
\end{enumerate}

\begin{lstlisting}
@Component
public class CacheService {
    
    @PostConstruct
    public void init() {
        System.out.println("Bean creato e dipendenze iniettate. Carico la cache...");
    }

    @PreDestroy
    public void cleanup() {
        System.out.println("Container in chiusura. Pulisco risorse...");
    }
}
\end{lstlisting}

\section{Spring AOP (Aspect Oriented Programming)}

La OOP è ottima per separare la logica business, ma pessima per la logica trasversale (\textbf{Cross-Cutting Concerns}) come Logging, Sicurezza e Transazioni. AOP permette di separare queste logiche.

\begin{interview}{Concetti chiave AOP}
\begin{itemize}
    \item \textbf{Aspect:} Il modulo che contiene la logica trasversale (es. \texttt{LoggingAspect}).
    \item \textbf{Join Point:} Un punto nel programma dove l'aspetto può intervenire (in Spring, è sempre l'esecuzione di un metodo).
    \item \textbf{Pointcut:} Un'espressione che definisce \textit{dove} applicare l'aspetto (es. "tutti i metodi nel package \texttt{com.service.*}").
    \item \textbf{Advice:} L'azione da compiere (\texttt{@Before}, \texttt{@After}, \texttt{@Around}).
\end{itemize}
\end{interview}

\begin{deepdive}{@Transactional e AOP}
Quando metti \texttt{@Transactional} su un metodo, Spring non modifica il tuo metodo.
Usa AOP per creare un \textbf{Proxy} dinamico che avvolge la tua classe.
\begin{enumerate}
    \item Il Proxy intercetta la chiamata (\textbf{Advice Around}).
    \item Apre la connessione DB (\textbf{Before}).
    \item Chiama il tuo metodo.
    \item Se eccezione $\to$ Rollback, altrimenti Commit (\textbf{AfterReturning/Throwing}).
\end{enumerate}
\end{deepdive}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Spring Boot: Convention over Configuration}

Immagina Spring Framework come una scatola gigante di Lego sparsi sul pavimento. Puoi costruire qualsiasi cosa, ma devi cercare ogni singolo pezzo, decidere come incastrarlo e configurarlo. È potente, ma lento.

\textbf{Spring Boot} è come comprare il set "Castello di Harry Potter": i pezzi sono già organizzati in buste numerate e hai le istruzioni predefinite. La filosofia si chiama \textbf{Convention over Configuration}:

\begin{itemize}
    \item \textbf{Configurazione classica (Spring):} "Ho bisogno di un database, ecco il driver, ecco l'url, ecco il pool di connessioni, ecco l'username..."
    \item \textbf{Convenzione (Spring Boot):} "Vedo che hai aggiunto il driver di MySQL nel progetto. Presumo tu voglia un database MySQL locale. L'ho configurato io per te."
\end{itemize}

\section{Il Punto di Partenza: @SpringBootApplication}

Questa annotazione, situata nella classe `Main`, è la "chiave di accensione" della tua applicazione.

\begin{deepdive}{Analisi: @SpringBootApplication}
Non è una singola annotazione, ma un contenitore che ne raggruppa tre fondamentali:
\begin{enumerate}
    \item \texttt{@Configuration}: Indica che la classe può definire Bean.
    \item \texttt{@ComponentScan}: Istruisce Spring a cercare componenti (\texttt{@Controller}, \texttt{@Service}) nel package corrente e nei suoi sotto-package.
    \item \texttt{@EnableAutoConfiguration}: \textbf{È qui che avviene la magia.} Ordina a Boot di analizzare le librerie nel classpath e configurare l'applicazione di conseguenza.
\end{enumerate}
\end{deepdive}

\begin{lstlisting}[caption=La classe Main standard]
@SpringBootApplication
public class MiaApplicazione {
    public static void main(String[] args) {
        // Avvia l'applicazione e il server Tomcat integrato
        SpringApplication.run(MiaApplicazione.class, args);
    }
}
\end{lstlisting}

\section{Come Funziona l'Auto-Configurazione?}

Molti pensano che l'auto-configurazione sia magia nera. In realtà, è deterministica e basata sull'annotazione \texttt{@Conditional}.

\begin{deepdive}{Concetto Chiave: L'Analogia dell'Arredatore}
Immagina di assumere un arredatore (Spring Boot) per casa tua. L'arredatore entra in cucina e fa questo ragionamento:
\begin{enumerate}
    \item "Vedo che c'è un attacco del gas (\textit{Libreria nel classpath})..."
    \item "...e vedo che NON hai ancora comprato un fornello (\textit{@ConditionalOnMissingBean})."
    \item "\textbf{Allora} installerò io un fornello standard per te (\textit{Auto-Configuration})."
\end{enumerate}
Se tu avessi già comprato un fornello personalizzato (definito un tuo Bean), l'arredatore non avrebbe fatto nulla.
\end{deepdive}

Ecco come appare questo ragionamento nel codice interno di Spring Boot:

\begin{lstlisting}[caption=Logica interna (Semplificata)]
@Configuration
// 1. Esegui solo se trovi la classe di Jackson (JSON)
@ConditionalOnClass(ObjectMapper.class) 
public class JacksonAutoConfig {

    @Bean
    // 2. Crea questo Bean SOLO se l'utente non ne ha creato uno suo
    @ConditionalOnMissingBean 
    public ObjectMapper objectMapper() {
        return new ObjectMapper(); // Versione standard
    }
}
\end{lstlisting}

\section{Gestire le Configurazioni: Properties}

Invece di scrivere valori direttamente nel codice ("Hardcoding"), Spring Boot usa \texttt{application.yml} (o \texttt{.properties}).

\begin{interview}{Differenza tra @Value e @ConfigurationProperties}
\begin{itemize}
    \item \textbf{@Value("\$\{chiave\}")}:
    \begin{itemize}
        \item Inietta un \textbf{singolo valore}.
        \item \textit{Pro:} Veloce per configurazioni isolate.
        \item \textit{Contro:} Non Type-Safe, difficile da mantenere se i valori sono molti.
    \end{itemize}
    
    \item \textbf{@ConfigurationProperties(prefix = "app")}:
    \begin{itemize}
        \item Mappa una gerarchia di proprietà su una \textbf{classe Java (POJO)}.
        \item \textit{Pro:} \textbf{Type-Safe}, supporta validazione, autocompletamento IDE.
        \item \textit{Uso:} Ideale per configurazioni complesse (es. parametri mail server, database custom).
    \end{itemize}
\end{itemize}
\end{interview}

\begin{lstlisting}[caption=Esempio Best Practice con ConfigurationProperties]
// Nel file application.yml:
// server-mail:
//   host: smtp.gmail.com
//   port: 587

@Configuration
@ConfigurationProperties(prefix = "server-mail") 
public class MailConfig {
    
    private String host;
    private int port; // Converte automaticamente in int!

    // Getter e Setter obbligatori
    public void setHost(String host) { this.host = host; }
    public void setPort(int port) { this.port = port; }
}
\end{lstlisting}

\section{Eseguire Task Periodici: @Scheduled}

Per eseguire operazioni batch o ricorrenti (es. invio report settimanale, pulizia cache).
\textbf{Nota:} Richiede \texttt{@EnableScheduling} su una classe di configurazione.

\begin{lstlisting}[caption=Esempi di Scheduling]
@Component
public class JobService {

    // Esegui ogni 5 secondi (5000 ms) dalla FINE dell'esecuzione precedente
    @Scheduled(fixedDelay = 5000)
    public void puliziaVeloce() {
        System.out.println("Pulizia cache...");
    }

    // Sintassi CRON: Secondi Minuti Ore Giorno Mese GiornoSettimana
    // "Alle ore 04:00:00 di ogni giorno"
    @Scheduled(cron = "0 0 4 * * *")
    public void reportNotturno() {
        System.out.println("Invio report...");
    }
}
\end{lstlisting}

\begin{deepdive}{Attenzione: Il Thread Singolo}
Di default, lo scheduler di Spring usa un \textbf{singolo thread} per tutti i task \texttt{@Scheduled} dell'applicazione.
Se hai due task programmati allo stesso orario, o se uno si blocca, \textbf{tutti gli altri task si bloccheranno o saranno ritardati}.

\textbf{Soluzione:} Configurare un \texttt{ThreadPoolTaskScheduler} custom per permettere l'esecuzione parallela.
\end{deepdive}

\section{Monitoraggio: Spring Actuator}

In produzione, devi sapere se l'applicazione è viva. Actuator espone endpoint REST pronti all'uso.
Basta aggiungere la dipendenza \texttt{spring-boot-starter-actuator}.

\begin{itemize}
    \item \texttt{/actuator/health}: Stato di salute (\textbf{UP/DOWN}). Controlla connessioni DB, disco, code.
    \item \texttt{/actuator/metrics}: Metriche dettagliate (CPU, RAM, Thread attivi).
    \item \texttt{/actuator/loggers}: Permette di cambiare il livello di log a runtime (es. da INFO a DEBUG) senza riavviare.
\end{itemize}

\begin{deepdive}{Security Warning}
Gli endpoint di Actuator espongono dettagli sensibili.
In produzione, \textbf{non devono mai} essere accessibili pubblicamente.
\begin{enumerate}
    \item Usa Spring Security per proteggerli (richiedi ruolo ADMIN).
    \item Oppure esponili su una porta diversa e bloccala dal firewall esterno: \texttt{management.server.port=8081}.
\end{enumerate}
\end{deepdive}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{L'Ecosistema Spring: Storia e Rivoluzione Boot}

Arrivati a questo punto, dobbiamo fare un passo indietro e guardare la mappa completa.
Spring non è una singola libreria, è un "universo" di progetti costruiti sopra un nucleo comune.

Un Senior Developer deve saper distinguere tra il Framework, Boot e le versioni che definiscono la compatibilità del JDK, comprendendo le rivoluzioni introdotte con la versione 3.

\section{Architettura a Moduli}
Il cuore di Spring è il container di \textbf{Inversion of Control (IoC)}. Tutto il resto sono moduli che si agganciano a questo nucleo.

\begin{enumerate}
    \item \textbf{Spring Core Container:} Gestisce i Bean, la Dependency Injection (DI) e il ciclo di vita dell'applicazione. (Moduli: \texttt{spring-core}, \texttt{spring-beans}, \texttt{spring-context}).
    \item \textbf{Spring AOP:} Programmazione Orientata agli Aspetti (usata per Transazioni e Sicurezza).
    \item \textbf{Data Access/Integration:} JDBC, ORM (Hibernate), Transaction Management.
    \item \textbf{Web:} Spring MVC (Servlet-based) e Spring WebFlux (Reactive).
    \item \textbf{Test:} Moduli per Unit e Integration Testing (MockMvc, TestContext).
\end{enumerate}

\section{Spring Framework vs Spring Boot}
Questa è la domanda di riscaldamento classica.

\begin{interview}{Differenza tra Spring e Spring Boot}
\textbf{Domanda:} Spring Boot sostituisce Spring Framework?

\textbf{Risposta:} \textbf{Assolutamente no.}
\begin{itemize}
    \item \textbf{Spring Framework} è il motore. Fornisce le funzionalità (DI, MVC, Transaction). Richiede molta configurazione manuale (XML o classi Java con tanti \texttt{@Bean}).
    \item \textbf{Spring Boot} è l'automobile assemblata. È un tool "opinionated" (con opinioni forti) che:
    \begin{enumerate}
        \item \textbf{Auto-Configuration:} Configura automaticamente Spring basandosi sulle librerie presenti nel classpath.
        \item \textbf{Embedded Server:} Include Tomcat/Jetty dentro il JAR (non serve installare un server esterno).
        \item \textbf{Starters:} Gestisce le dipendenze in gruppi logici (es. \texttt{spring-boot-starter-web}).
    \end{enumerate}
\end{itemize}
\end{interview}

\section{Evoluzione delle Versioni (Timeline)}
Prima di arrivare a oggi, ecco da dove veniamo:

\subsection{Spring Framework 4 (Legacy)}
Baseline Java 6. Introdotto il supporto completo a Java 8 e \texttt{@RestController}. Oggi è debito tecnico.

\subsection{Spring Framework 5 (Era Boot 2.x)}
Baseline Java 8. Ha introdotto lo stack \textbf{Reactive} (WebFlux). È stata la versione standard fino al 2022.

\section{GraalVM e Native Images}

Fino a ieri, Java funzionava in un modo. Oggi, con Spring Boot 3 e GraalVM, può funzionare in un modo completamente diverso. Capire questa differenza è essenziale per il Cloud moderno.

\subsection{L'Analogia del Traduttore (JIT vs AOT)}
Per capire la differenza tecnica, usiamo un'analogia semplice. Immagina di dover leggere un libro scritto in Russo (il Codice Java) a un pubblico che parla solo Italiano (la CPU/Hardware).

\begin{enumerate}
    \item \textbf{Approccio Classico (JVM - JIT): Il Traduttore Simultaneo.}
    \begin{itemize}
        \item Tu inizi a leggere il libro in Russo.
        \item Un interprete (la JVM) ascolta e traduce frase per frase in Italiano mentre parli.
        \item \textbf{Problema:} All'inizio l'interprete è lento, deve scaldarsi, capire il contesto.
        \item \textbf{Vantaggio:} Se capisce che una frase si ripete spesso, impara a tradurla velocissimamente (Ottimizzazione a Runtime).
    \end{itemize}

    \item \textbf{Approccio GraalVM (Native - AOT): Il Libro Già Tradotto.}
    \begin{itemize}
        \item Prima ancora di salire sul palco (durante la Build), traduci tutto il libro in Italiano e lo stampi.
        \item Sul palco leggi direttamente l'Italiano.
        \item \textbf{Vantaggio:} Inizi a leggere all'istante. Non serve l'interprete.
        \item \textbf{Svantaggio:} Se il libro cambia, devi ristamparlo tutto.
    \end{itemize}
\end{enumerate}

\subsection{Come funziona tecnicamente (Sotto il cofano)}

\subsubsection{1. Il vecchio mondo: JIT (Just-In-Time)}
Il codice Java viene compilato in \textbf{Bytecode} (\texttt{.class}). Questo non è comprensibile dalla CPU. Serve la JVM che lo avvia e lo traduce mentre l'applicazione gira.
\begin{itemize}
    \item \textbf{Avvio Lento:} La JVM deve caricare migliaia di classi in memoria.
    \item \textbf{Consumo RAM:} La JVM stessa occupa memoria (overhead) solo per esistere.
\end{itemize}

\subsubsection{2. Il nuovo mondo: AOT (Ahead-Of-Time)}
Qui entra in gioco \textbf{GraalVM}.
GraalVM prende il tuo Bytecode, prende tutte le librerie (Spring, Hibernate, ecc.), prende persino pezzi della JVM (come il Garbage Collector) e \textbf{compila tutto staticamente} in un unico file binario (Codice Macchina: 0 e 1).

Il risultato è un file \texttt{.exe} (o binario Linux) che non ha bisogno di Java installato per girare.

\begin{deepdive}{Perché Spring Boot 3 è fondamentale qui?}
GraalVM ha un limite enorme: il \textbf{"Mondo Chiuso"}.
Per creare il file binario, deve sapere ESATTAMENTE quali classi userai.
Ma Java è dinamico! Usa la \textbf{Reflection} (carica classi in base a stringhe di testo, es. i file di config). GraalVM non riesce a vedere queste classi "nascoste" e le elimina per risparmiare spazio. Risultato: l'app crasha.

\textbf{Soluzione:} Spring Boot 3, durante la compilazione, analizza il tuo codice e crea una "mappa" per GraalVM, dicendogli: \textit{"Ehi, non buttare via la classe User, mi servirà!"}.
\end{deepdive}

\subsection{Confronto Visivo: Il Ciclo di Vita}

\begin{tcolorbox}[colback=white, colframe=deepblue, title=Differenza nel Build Process]
\textbf{Processo Standard (JVM):}
\begin{enumerate}
    \item Scrivi Codice Java.
    \item Compiler \texttt{javac} $\rightarrow$ Crea \texttt{.class} (Bytecode).
    \item \textbf{Esecuzione:} Lanci \texttt{java -jar app.jar}. La JVM parte e interpreta.
\end{enumerate}

\tcbline

\textbf{Processo Native (GraalVM):}
\begin{enumerate}
    \item Scrivi Codice Java.
    \item Spring Boot AOT Engine $\rightarrow$ Analizza e genera configurazioni.
    \item GraalVM Native Compiler $\rightarrow$ Macina per minuti (è lento a compilare!).
    \item \textbf{Risultato:} Crea un file binario \texttt{app.exe}.
    \item \textbf{Esecuzione:} Lanci \texttt{./app.exe}. Parte in 50 millisecondi.
\end{enumerate}
\end{tcolorbox}

\subsection{Tabella Decisiva: Quando usare cosa?}
Ai colloqui chiedono: "Perché non usiamo sempre GraalVM?". Ecco la risposta da Senior.

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Fattore}} & \textcolor{white}{\textbf{JVM Classica}} & \textcolor{white}{\textbf{GraalVM Native}} \\
    \hline
    \textbf{Tempo di Avvio} & Lento (secondi) & \textbf{Istantaneo} (ms) \\
    \hline
    \textbf{Memoria RAM} & Alta (occupa molto) & \textbf{Bassissima} \\
    \hline
    \textbf{Throughput} & \textbf{Migliore} (Il JIT ottimizza in base all'uso reale) & Inferiore (Il codice è statico) \\
    \hline
    \textbf{Build Time} & Veloce (secondi) & Lento (minuti e molta RAM) \\
    \hline
    \textbf{Use Case Ideale} & Web App tradizionali, Monoliti, Servizi "sempre accesi". & \textbf{Serverless} (AWS Lambda), Container Kubernetes che scalano a zero. \\
    \hline
\end{tabularx}
\end{center}


\section{La Rivoluzione di Spring Boot 3}
Rilasciato a Novembre 2022, Spring Boot 3 (basato su Framework 6) rappresenta il cambiamento più traumatico e importante degli ultimi 10 anni.
Si fonda su tre pilastri che devi conoscere a fondo: \textbf{Jakarta EE}, \textbf{GraalVM} e \textbf{Micrometer}.

\subsection{1. La Grande Migrazione: Javax vs Jakarta}
Se provi a migrare un progetto da Spring Boot 2.7 a 3.0, il codice non compilerà. Ti troverai migliaia di errori sugli \texttt{import}.

\subsubsection{Storia di un divorzio legale}
Fino al 2017, Java Enterprise Edition (Java EE) era proprietà di \textbf{Oracle}. I pacchetti si chiamavano \texttt{javax.*} (es. \texttt{javax.persistence}).
Oracle ha donato Java EE alla \textbf{Eclipse Foundation}, ma \textbf{non ha ceduto il marchio "Java"}.
La fondazione ha dovuto rinominare tutto: Java EE è diventato \textbf{Jakarta EE} e i pacchetti \texttt{javax.*} sono diventati \textbf{\texttt{jakarta.*}}.

\subsubsection{L'Impatto Tecnico}
Spring Boot 3 richiede \textbf{Jakarta EE 10}.

\begin{lstlisting}[language=Java, title={Il cambiamento degli Import}]
// SPRING BOOT 2 (Old)
import javax.persistence.Entity;
import javax.servlet.http.HttpServletRequest;

// SPRING BOOT 3 (New)
import jakarta.persistence.Entity;
import jakarta.servlet.http.HttpServletRequest;
\end{lstlisting}

\begin{deepdive}{Tomcat 9 vs Tomcat 10}
Questo cambio impatta anche i server.
\begin{itemize}
    \item \textbf{Tomcat 9:} Parla \texttt{javax}. Supporta Spring Boot 2.
    \item \textbf{Tomcat 10:} Parla \texttt{jakarta}. Supporta Spring Boot 3.
\end{itemize}
Non puoi deployare un WAR Boot 2 su Tomcat 10: otterrai errori \texttt{ClassNotFoundException}.
\end{deepdive}

\subsection{2. GraalVM e Native Images}
Spring Boot 3 è stato progettato ossessivamente per supportare le \textbf{Native Images} tramite GraalVM.

\subsection{3. Observability: Micrometer}
Nei sistemi distribuiti, monitorare è difficile.
\textbf{Micrometer} è diventato lo standard unificato dentro Spring Boot 3 per due aspetti:

\subsubsection{Metrics (Numeri)}
Raccoglie dati come "Utilizzo CPU", "Numero richieste HTTP", "Errori 500" e li invia a sistemi come Prometheus o Datadog. È un'interfaccia facade: cambi il sistema di monitoraggio senza cambiare il codice.

\subsubsection{Tracing (Il viaggio della richiesta)}
Prima si usava Spring Cloud Sleuth. Ora è tutto nativo in Micrometer Tracing.
Assegna automaticamente ID alle richieste per seguirle tra i microservizi:
\begin{itemize}
    \item \textbf{Trace ID:} Identifica l'intera transazione attraverso N servizi.
    \item \textbf{Span ID:} Identifica la singola operazione (es. query al DB).
\end{itemize}

\section{Tabella Riepilogativa Versioni}
Da stampare e tenere sulla scrivania.

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|c|c|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Versione Boot}} & \textcolor{white}{\textbf{Spring Fwk}} & \textcolor{white}{\textbf{Java Min}} & \textcolor{white}{\textbf{Note Chiave}} \\
    \hline
    \textbf{2.7.x} & 5.3.x & Java 8 & Ultima versione ramo 2.x. "Ponte" per la migrazione. Usa \texttt{javax}. \\
    \hline
    \textbf{3.0} & 6.0 & \textbf{Java 17} & Jakarta EE namespace, AOT/GraalVM nativo. \\
    \hline
    \textbf{3.2} & 6.1 & Java 17/21 & Supporto ai \textbf{Virtual Threads} (Project Loom). \\
	\hline
	\textbf{4.0} & 7.0 & Java 17+ & Fortemente raccomandato Java 25. Richiede Jakarta EE 11 (Tomcat 11+). \\
	\hline
\end{tabularx}
\end{center}

\begin{deepdive}{Spring Boot 3.2 e i Virtual Threads}
Da Spring Boot 3.2 (con Java 21), Spring supporta i \textbf{Virtual Threads}.
Basta una riga: \texttt{spring.threads.virtual.enabled=true}.
Tomcat smette di usare i thread pesanti del sistema operativo e usa i virtual threads leggeri della JVM, permettendo di gestire milioni di connessioni concorrenti con lo stile di programmazione classico, senza dover riscrivere tutto in Reactive/WebFlux.
\end{deepdive}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Spring JDBC Template: SQL Control \& Performance}

Abbiamo visto come Hibernate/JPA semplifichi la vita mappando oggetti. Ma c'è un prezzo da pagare: overhead di memoria, query imprevedibili e difficoltà nel gestire operazioni massive (Batch).

\textbf{Spring JDBC Template} è il bisturi chirurgico del framework.
Non è un ORM. È un layer sottile sopra il JDBC standard che rimuove il "boilerplate code" (aprire/chiudere connessioni, gestire eccezioni) lasciandoti il \textbf{controllo totale dell'SQL}.

\section{Quando scegliere JDBC Template vs JPA?}

\begin{tcolorbox}[colback=white, colframe=deepblue, title=Il Dilemma Architetturale]
\textbf{Usa JPA/Hibernate quando:}
\begin{itemize}
    \item Stai facendo CRUD standard (Create, Read, Update, Delete).
    \item Hai un grafo di oggetti complesso da caricare/salvare.
    \item Vuoi sfruttare la cache di primo/secondo livello.
\end{itemize}

\textbf{Usa Spring JDBC Template quando:}
\begin{itemize}
    \item \textbf{Performance Estreme:} Devi inserire 100.000 record in pochi secondi (Batch).
    \item \textbf{SQL Complesso:} Reportistica, Window Functions, CTE, Join su 10 tabelle dove JPA impazzirebbe.
    \item \textbf{Controllo:} Vuoi sapere esattamente quale query viene eseguita, byte per byte.
\end{itemize}
\end{tcolorbox}

\section{JdbcTemplate vs NamedParameterJdbcTemplate}

La differenza fondamentale risiede nella gestione dei parametri: il classico \texttt{JdbcTemplate} usa il binding posizionale, mentre il \texttt{NamedParameterJdbcTemplate} usa il binding nominale.

\subsection{Approccio Classico (JdbcTemplate)}
Utilizza il segnaposto \texttt{?} (standard JDBC). I parametri dipendono rigorosamente dall'ordine in cui vengono passati nell'array. Questo approccio è fragile: basta scambiare due parametri dello stesso tipo per corrompere i dati senza errori di compilazione.

\begin{lstlisting}[language=Java, caption={Binding Posizionale}]
// Rischioso: l'ordine dei ? e' l'unica garanzia
String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
jdbcTemplate.update(sql, "Mario", "mario@email.com");
\end{lstlisting}

\subsection{Approccio Moderno (NamedParameterJdbcTemplate)}
Utilizza i placeholder con nome (es. \texttt{:email}). L'ordine non ha importanza, conta solo la corrispondenza della chiave. Inoltre, permette di mappare automaticamente interi oggetti Java sui parametri della query.

\begin{lstlisting}[language=Java, caption={Binding Nominale}]
// Sicuro: mappa esplicitamente il parametro al valore
String sql = "INSERT INTO users (name, email) VALUES (:name, :email)";

MapSqlParameterSource params = new MapSqlParameterSource()
    .addValue("email", "mario@email.com")
    .addValue("name", "Mario");

namedJdbcTemplate.update(sql, params);
\end{lstlisting}

\subsection{Perché usare NamedParameterJdbcTemplate?}
\begin{itemize}
    \item \textbf{Leggibilità:} Il codice SQL dichiara esplicitamente cosa si aspetta (es. \texttt{:scadenza} vs \texttt{?}).
    \item \textbf{Refactoring:} Aggiungere o rimuovere colonne non richiede di rinumerare gli indici dei parametri.
    \item \textbf{Supporto POJO:} Tramite \texttt{BeanPropertySqlParameterSource}, è possibile passare un intero oggetto Java e Spring mapperà automaticamente i campi ai parametri SQL con lo stesso nome.
\end{itemize}

\section{Lettura Dati (The RowMapper)}
In JDBC non c'è "magia". Devi spiegare a Spring come trasformare una riga del ResultSet (SQL) in un Oggetto Java. Questo si fa con il \textbf{RowMapper}.

\subsection{1. Lettura Singola (QueryForObject)}
\begin{lstlisting}[language=Java]
public Optional<UserDTO> findByEmail(String email) {
    String sql = "SELECT id, username, email FROM users WHERE email = :email";

    MapSqlParameterSource params = new MapSqlParameterSource()
            .addValue("email", email);

    try {
        UserDTO user = jdbcTemplate.queryForObject(sql, params, new UserRowMapper());
        return Optional.ofNullable(user);
    } catch (EmptyResultDataAccessException e) {
        return Optional.empty(); // Gestione esplicita del "Not Found"
    }
}
\end{lstlisting}

\subsection{2. Il RowMapper (Manuale vs Automatico)}

\begin{deepdive}{RowMapper vs BeanPropertyRowMapper}
Esiste una classe chiamata \texttt{BeanPropertyRowMapper} che mappa automaticamente le colonne ai campi usando la Reflection.
\textbf{Consiglio Senior:} Non usarla in loop critici o ad alto traffico. La Reflection è lenta. Scrivi il tuo Mapper manuale (è noioso, ma è il più veloce in assoluto).
\end{deepdive}

\begin{lstlisting}[language=Java, title={Best Practice: Mapper come Lambda o Classe Statica}]
// Definizione pulita e riutilizzabile
private static final RowMapper<UserDTO> USER_MAPPER = (rs, rowNum) -> {
    return new UserDTO(
        rs.getLong("id"),
        rs.getString("username"),
        rs.getString("email")
    );
};

// Utilizzo per liste
public List<UserDTO> findAllActive() {
    String sql = "SELECT * FROM users WHERE active = true";
    // params vuoti
    return jdbcTemplate.query(sql, MapSqlParameterSource.create(), USER_MAPPER); 
}
\end{lstlisting}

\section{Scrittura Dati e Chiavi Generate}
Le INSERT sono banali, tranne quando devi recuperare l'ID autogenerato (AUTO\_INCREMENT) dal database. In JPA è automatico, qui serve il \textbf{KeyHolder}.

\begin{lstlisting}[language=Java, title={Insert con ritorno dell'ID}]
public Long createUser(CreateUserRequest req) {
    String sql = """
        INSERT INTO users (username, email, password) 
        VALUES (:username, :email, :pwd)
    """;

    MapSqlParameterSource params = new MapSqlParameterSource()
            .addValue("username", req.username())
            .addValue("email", req.email())
            .addValue("pwd", req.password()); // Hashala prima!

    KeyHolder keyHolder = new GeneratedKeyHolder();

    // update restituisce il numero di righe modificate
    jdbcTemplate.update(sql, params, keyHolder);

    // Recupero magico dell'ID
    return Objects.requireNonNull(keyHolder.getKey()).longValue();
}
\end{lstlisting}

\section{Batch Processing: La Killer Feature}
Questo è il motivo principale per cui si usa JDBC Template.
Se devi inserire 10.000 record:
\begin{itemize}
    \item \textbf{JPA \texttt{saveAll}:} Spesso esegue 10.000 insert separate o usa dirty checking pesante. Lento.
    \item \textbf{JDBC Batch:} Invia un unico pacchetto al DB. Velocità 10x-50x superiore.
\end{itemize}

\begin{lstlisting}[language=Java, title={Batch Insert Ottimizzato}]
public void bulkInsert(List<UserDTO> users) {
    String sql = "INSERT INTO users (username, email) VALUES (:username, :email)";

    // 1. Trasformiamo la lista di oggetti in un array di parametri
    SqlParameterSource[] batchParams = SqlParameterSourceUtils.createBatch(users);

    // 2. Esecuzione atomica
    int[] updateCounts = jdbcTemplate.batchUpdate(sql, batchParams);
    
    System.out.println("Inseriti " + updateCounts.length + " record.");
}
\end{lstlisting}

\section{Gestione delle Eccezioni}
JDBC standard lancia \texttt{SQLException}, che è una \textit{Checked Exception} (ti obbliga al try-catch ovunque).
Spring JDBC Template avvolge tutto e lancia \textbf{\texttt{DataAccessException}}, che è \textit{Unchecked} (Runtime).

Inoltre, Spring traduce i codici di errore criptici del DB (es. ORA-0001, SQLState 23505) in eccezioni Java parlanti:
\begin{itemize}
    \item \texttt{DuplicateKeyException} (Violazione Unique Constraint)
    \item \texttt{QueryTimeoutException}
    \item \texttt{BadSqlGrammarException}
\end{itemize}

\begin{interview}{Exception Translation}
\textbf{Domanda:} Perché l'Exception Translation di Spring è vantaggiosa?
\textbf{Risposta:}
Perché disaccoppia il codice dal vendor del Database.
Se migri da Oracle a PostgreSQL, i codici di errore SQL cambiano, ma Spring continuerà a lanciarti la stessa \texttt{DuplicateKeyException}. Il tuo blocco \texttt{try-catch} nel Service non deve essere riscritto.
\end{interview}

\section{Riepilogo e Cheat Sheet}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Operazione}} & \textcolor{white}{\textbf{Metodo JdbcTemplate}} \\
    \hline
    Leggere 1 riga (o null) & \texttt{queryForObject} (gestire \texttt{EmptyResult...}) \\
    \hline
    Leggere N righe & \texttt{query} (ritorna \texttt{List<T>}) \\
    \hline
    Insert / Update / Delete & \texttt{update} \\
    \hline
    Insert con ritorno ID & \texttt{update} con \texttt{KeyHolder} \\
    \hline
    Insert Massivo & \texttt{batchUpdate} \\
    \hline
    Eseguire DDL (Create table) & \texttt{execute} \\
    \hline
\end{tabularx}
\end{center}

\begin{deepdive}{Senior Tip: Transazioni}
Ricorda che \texttt{JdbcTemplate} partecipa pienamente al Transaction Manager di Spring.
Se metti \texttt{@Transactional} sul metodo del Service che chiama il DAO JDBC, tutte le operazioni (anche i batch) saranno atomiche. Se il batch fallisce a metà, viene fatto il rollback di tutto.
\end{deepdive}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Spring Data JPA: The Abstraction Layer}

Se JDBC Template è il bisturi, \textbf{Spring Data JPA} è il pilota automatico.
Riduce il codice di accesso ai dati del 90\%, eliminando completamente l'implementazione dei DAO.

Ma attenzione: Spring Data JPA \textbf{non è} un ORM.
È un livello di astrazione aggiuntivo che si posiziona sopra Hibernate (che è l'ORM), il quale a sua volta sta sopra JDBC.

\section{La Gerarchia: Capire lo Stack}
Ai colloqui chiedono spesso la differenza tra JPA, Hibernate e Spring Data.

\begin{enumerate}
    \item \textbf{JPA (Java Persistence API):} È solo una specifica (un documento PDF e interfacce). Non fa nulla da sola.
    \item \textbf{Hibernate:} È l'implementazione della specifica JPA. È il motore che genera l'SQL.
    \item \textbf{Spring Data JPA:} È un framework che genera automaticamente i Repository (le classi DAO) basandosi sulle interfacce che definisci.
\end{enumerate}

\section{Il Repository Pattern}
Invece di scrivere classi \texttt{UserDaoImpl}, definisci solo un'interfaccia.

\begin{lstlisting}[language=Java, title={Il potere di JpaRepository}]
// Estendendo JpaRepository erediti GRATIS:
// save, saveAll, findById, findAll, delete, count, existsById...
public interface UserRepository extends JpaRepository<UserEntity, Long> {
    // Il corpo è vuoto! Spring crea un proxy a runtime che implementa tutto.
}
\end{lstlisting}

\section{Query Creation Strategies}
Spring Data offre tre modi per definire le query. Un Senior sa quando usarne uno e quando passare all'altro.

\subsection{1. Derived Queries (Query Methods)}
Spring analizza il \textbf{nome del metodo} e genera l'SQL.
\begin{lstlisting}[language=Java]
// SELECT * FROM users WHERE email = ? AND active = true
Optional<UserEntity> findByEmailAndActiveTrue(String email);

// SELECT * FROM users WHERE created_at > ? ORDER BY username DESC
List<UserEntity> findByCreatedAtAfterOrderByUsernameDesc(LocalDateTime date);
\end{lstlisting}
\textbf{Pro:} Velocissimo da scrivere.
\textbf{Contro:} Se la query è complessa, il nome del metodo diventa illeggibile (\texttt{findByUserAddressCityAndActiveTrueAnd...}).

\subsection{2. @Query (JPQL e Native)}
Quando il nome del metodo diventa troppo lungo, usa \texttt{@Query}.
Qui scrivi in \textbf{JPQL} (Java Persistence Query Language), che lavora sulle \textit{Entity}, non sulle tabelle.

\begin{lstlisting}[language=Java]
@Query("SELECT u FROM UserEntity u WHERE u.email = :email AND u.active = true")
Optional<UserEntity> cercaUtenteAttivo(@Param("email") String email);
\end{lstlisting}

\begin{deepdive}{Native Queries}
Se devi usare funzionalità specifiche del DB (es. JSONB di Postgres o funzioni proprietarie), puoi usare SQL nativo:
\texttt{@Query(value = "SELECT * FROM users u ...", nativeQuery = true)}.
Tuttavia, perdi la portabilità del codice tra database diversi.
\end{deepdive}

\section{Paginazione e Ordinamento}
Non fare mai \texttt{findAll()} su una tabella con un milione di righe. Spring Data ha il supporto nativo per la paginazione.

\begin{lstlisting}[language=Java, title={Pagination Repository}]
// Nel Repository
Page<UserEntity> findByActiveTrue(Pageable pageable);

// Nel Service (Pagina 0, 10 elementi, ordinati per ID decrescente)
public Page<UserDTO> getUsers(int page, int size) {
    Pageable pageRequest = PageRequest.of(page, size, Sort.by("id").descending());
    
    Page<UserEntity> userPage = repository.findByActiveTrue(pageRequest);
    
    // map() converte automaticamente il contenuto della pagina
    return userPage.map(mapper::toDTO);
}
\end{lstlisting}

\begin{interview}{List vs Page vs Slice}
\textbf{Domanda:} Che differenza c'è nel ritornare \texttt{Page<T>} o \texttt{Slice<T>}?
\textbf{Risposta:}
\begin{itemize}
    \item \textbf{\texttt{Page<T>}:} Esegue la query dei dati \textbf{PIÙ} una query \texttt{COUNT(*)} separata per sapere il numero totale di pagine. È costoso su grandi dataset.
    \item \textbf{\texttt{Slice<T>}:} Esegue solo la query dei dati (spesso chiedendo N+1 righe per sapere se c'è una pagina successiva). Non sa quante pagine ci sono in totale. Ideale per "Infinite Scroll" (Mobile/Social).
\end{itemize}
\end{interview}

\section{Performance: Il problema N+1}
Il killer silenzioso delle applicazioni Spring Data JPA.

\textbf{Scenario:} Hai \texttt{User} (1) $\rightarrow$ \texttt{Orders} (N). La relazione è \texttt{LAZY} (Best Practice).
\begin{enumerate}
    \item Chiami \texttt{findAll()} sugli utenti (1 Query).
    \item Cicli sugli utenti e chiami \texttt{user.getOrders().size()}.
    \item Hibernate esegue \textbf{una query aggiuntiva per OGNI utente} per caricare gli ordini.
    \item Se hai 100 utenti, fai 101 Query.
\end{enumerate}

\subsection{Soluzione 1: @EntityGraph}
Dici a Spring di caricare la relazione LAZY in una singola query (EAGER fetch) solo per quel metodo.

\begin{lstlisting}[language=Java]
// Override del findAll per caricare anche gli ordini in un colpo solo
@EntityGraph(attributePaths = {"orders"})
List<UserEntity> findAll();
\end{lstlisting}

\subsection{Soluzione 2: JPQL Fetch Join}
\begin{lstlisting}[language=Java]
@Query("SELECT u FROM UserEntity u JOIN FETCH u.orders")
List<UserEntity> findAllWithOrders();
\end{lstlisting}

\section{Modifying Queries (Update/Delete massivi)}
Di default, le query JPQL sono solo di lettura (SELECT). Se vuoi fare UPDATE o DELETE massivi senza caricare le entità in memoria:

\begin{lstlisting}[language=Java]
@Modifying // Obbligatorio per INSERT/UPDATE/DELETE
@Query("UPDATE UserEntity u SET u.active = false WHERE u.lastLogin < :date")
int disattivaUtentiInattivi(@Param("date") LocalDateTime date);
\end{lstlisting}
\textbf{Nota:} Questo metodo scavalca il contesto di persistenza. Le entity in memoria non saranno aggiornate. Spesso si usa insieme a \texttt{@Modifying(clearAutomatically = true)} per pulire la cache di primo livello.

\section{JPA Auditing}
Non gestire manualmente \texttt{createdAt} e \texttt{updatedAt}.
\begin{enumerate}
    \item Aggiungi \texttt{@EnableJpaAuditing} sulla classe main.
    \item Usa le annotazioni sulle Entity (o su una classe base \texttt{BaseEntity}).
\end{enumerate}

\begin{lstlisting}[language=Java]
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;
    
    // Se usi Spring Security, popola automaticamente l'utente!
    @CreatedBy
    private String createdBy;
}
\end{lstlisting}

\section{Riepilogo Best Practices}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Feature}} & \textcolor{white}{\textbf{Consiglio Senior}} \\
    \hline
    Derived Queries & Solo per query semplici (max 2 parametri). \\
    \hline
    Relazioni & Sempre \texttt{LAZY} di default. Usa \texttt{@EntityGraph} o \texttt{JOIN FETCH} quando servono i dati. \\
    \hline
    Loop su relazioni & Mai farlo dentro un ciclo for senza fetch join (N+1 Problem). \\
    \hline
    Paginazione & Non ritornare mai \texttt{List} su tabelle potenzialmente grandi. Usa \texttt{Pageable}. \\
    \hline
    Projections & Usa Interfacce o DTO Records nelle query per evitare di caricare Entity intere in sola lettura. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Spring Transaction Management}

Gestire le transazioni manualmente (aprire connessione, \texttt{con.setAutoCommit(false)}, commit, rollback, close) è verboso e incline a errori.
Spring offre un approccio dichiarativo tramite l'annotazione \textbf{\texttt{@Transactional}}.

Tuttavia, usare questa annotazione senza capire cosa succede "sotto il cofano" è la causa principale di bug silenziosi e dati corrotti in produzione.

\section{Under the Hood: Il Proxy Pattern}
Questa è la prima domanda tecnica ai colloqui.
\textbf{Come funziona @Transactional?} Spring non riscrive il bytecode della tua classe "magicamente". Usa il pattern \textbf{AOP (Aspect Oriented Programming)} tramite \textbf{Proxy}.

Quando annoti un metodo (o una classe) con \texttt{@Transactional}, Spring crea un oggetto wrapper (Proxy) attorno alla tua classe.

\begin{deepdive}{Il flusso di chiamata del Proxy}
Immagina di avere un \texttt{UserService}.
\begin{enumerate}
    \item Il Controller chiama \texttt{userService.save(user)}.
    \item In realtà, sta chiamando il \textbf{Proxy} generato da Spring.
    \item Il Proxy apre la transazione DB.
    \item Il Proxy chiama il metodo reale \texttt{save()} della tua classe.
    \item Se il metodo reale finisce con successo, il Proxy esegue il \textbf{COMMIT}.
    \item Se il metodo lancia un'eccezione (Runtime), il Proxy esegue il \textbf{ROLLBACK}.
\end{enumerate}
\end{deepdive}

\begin{interview}{La Trappola della Self-Invocation}
\textbf{Domanda:} Ho un metodo A non transazionale che chiama un metodo B annotato con \texttt{@Transactional} \textit{nella stessa classe}. La transazione partirà?

\begin{lstlisting}[language=Java]
public void metodoA() {
    metodoB(); // Chiamata interna
}

@Transactional
public void metodoB() { ... }
\end{lstlisting}

\textbf{Risposta:} \textbf{NO.}
La chiamata \texttt{metodoB()} avviene tramite \texttt{this.metodoB()}. Stai chiamando il metodo direttamente sull'istanza, scavalcando il Proxy. Spring non può intercettare la chiamata e non aprirà nessuna transazione.
\textbf{Soluzione:} Spostare \texttt{metodoB} in un altro Service (Bean diverso) o iniettare il Service in se stesso (brutto ma funzionante).
\end{interview}

\section{Propagation Levels (Propagazione)}
Il parametro \texttt{propagation} definisce come la transazione deve comportarsi se ne esiste già un'altra attiva.

\subsection{1. REQUIRED (Default)}
Il più usato.
\begin{itemize}
    \item \textbf{Se c'è una transazione attiva:} Il metodo si aggancia a quella esistente.
    \item \textbf{Se NON c'è:} Ne crea una nuova.
    \item \textbf{Conseguenza:} Se il metodo interno fallisce, fa rollback di \textit{tutta} la transazione (anche quella del chiamante).
\end{itemize}

\subsection{2. REQUIRES\_NEW (Transazione Indipendente)}
Il metodo sospende la transazione corrente (se esiste) e ne apre una \textbf{nuova e indipendente}.
\begin{itemize}
    \item \textbf{Use Case:} Log di Audit o salvataggio errori.
    \item Esempio: Sto salvando un ordine (TX 1). L'ordine fallisce. Voglio salvare l'errore su tabella \texttt{error\_logs} (TX 2). Se usassi REQUIRED, il rollback dell'ordine cancellerebbe anche il log dell'errore. Con REQUIRES\_NEW, il log viene salvato (committato) anche se l'ordine principale fa rollback.
\end{itemize}

\subsection{3. MANDATORY}
Esige che ci sia già una transazione aperta. Se non c'è, lancia un'eccezione.
Utile per metodi che non devono mai essere chiamati da soli ma solo come parte di un processo più grande.

\subsection{4. SUPPORTS / NOT\_SUPPORTED}
\begin{itemize}
    \item \textbf{SUPPORTS:} Se c'è una TX la usa, altrimenti esegue senza TX (modalità lettura non critica).
    \item \textbf{NOT\_SUPPORTED:} Sospende la TX corrente ed esegue senza TX (es. invio email lento o chiamata a sistema esterno che non deve tenere bloccata la connessione DB).
\end{itemize}

\section{Rollback Rules (Eccezioni)}
Spring, di default, fa rollback \textbf{SOLO} per le \texttt{RuntimeException} (Unchecked) e per gli \texttt{Error}.
\textbf{NON fa rollback} per le \texttt{Checked Exception} (es. \texttt{IOException}, \texttt{SQLException} custom).

\begin{lstlisting}[language=Java, title={Configurare il Rollback}]
// Sbagliato (Default): Non fa rollback se lancia IOException
@Transactional
public void salvaFile() throws IOException { ... }

// Corretto: Forza il rollback anche per le Checked Exception
@Transactional(rollbackFor = Exception.class)
public void salvaFileSicuro() throws IOException { ... }

// Caso opposto: NON fare rollback per una Runtime specifica
@Transactional(noRollbackFor = IllegalArgumentException.class)
public void ignoraErroriMinori() { ... }
\end{lstlisting}

\section{Isolation Levels (Concorrenza)}
Cosa succede se due transazioni toccano gli stessi dati contemporaneamente? L'isolamento definisce "quanto" una transazione vede delle modifiche dell'altra.

\begin{enumerate}
    \item \textbf{READ\_UNCOMMITTED:} Leggi anche i dati non ancora committati (Dirty Read). Pericolosissimo, quasi mai usato.
    \item \textbf{READ\_COMMITTED (Default in Postgres/Oracle):} Leggi solo i dati committati. Previene Dirty Read.
    \item \textbf{REPEATABLE\_READ (Default in MySQL):} Assicura che se leggi una riga due volte nella stessa TX, otterrai lo stesso valore (previene \textit{Non-Repeatable Read}).
    \item \textbf{SERIALIZABLE:} Il livello massimo. Esegue le transazioni come se fossero sequenziali. Lento (uso pesante di lock), ma garantisce consistenza totale (previene \textit{Phantom Read}).
\end{enumerate}

\section{Read-Only Optimization}
\begin{lstlisting}[language=Java]
@Transactional(readOnly = true)
public List<User> findAll() { ... }
\end{lstlisting}

Perché metterlo? Non è solo documentazione.
\begin{itemize}
    \item \textbf{JPA/Hibernate:} Disabilita il \textit{Dirty Checking}. Hibernate non perderà tempo a controllare se hai modificato le entity caricate, risparmiando memoria e CPU.
    \item \textbf{Database (es. MySQL Replicas):} In architetture Master-Slave, il driver JDBC potrebbe instradare le query \texttt{readOnly} verso le Repliche (Slave) di lettura, alleggerendo il Master.
\end{itemize}

\section{Riepilogo Best Practices}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Situazione}} & \textcolor{white}{\textbf{Soluzione}} \\
    \hline
    Chiamata interna (Self-invocation) & Non usare \texttt{@Transactional} (o auto-inject del service). \\
    \hline
    Metodi privati & \texttt{@Transactional} non funziona sui metodi private (il proxy non li vede). \\
    \hline
    Salvataggio Log/Audit indipendenti & Usa \texttt{propagation = REQUIRES\_NEW}. \\
    \hline
    Checked Exception custom & Usa \texttt{rollbackFor = MyException.class}. \\
    \hline
    Operazioni di sola lettura & Sempre \texttt{readOnly = true} per performance. \\
    \hline
    Transazioni lunghe (es. report) & Evitale. Tengono la connessione al DB occupata. Spostale in Job asincroni. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Esempio Pratico: Architettura Spring Data JPA}

Siamo arrivati al livello di astrazione più alto e più diffuso nel mercato odierno.
Se con Hibernate puro dovevamo gestire manualmente la \texttt{SessionFactory} e le Transazioni, \textbf{Spring Data JPA} nasconde tutta questa complessità.

Il cuore di Spring Data è il concetto di \textbf{Repository}: non serve più scrivere l'implementazione della classe DAO. Basta definire un'\textbf{Interfaccia} e Spring genererà l'implementazione a Runtime usando i Proxy Dinamici.

\section{1. Configurazione (application.properties)}

In un progetto Spring Boot, non serve \texttt{hibernate.cfg.xml}. Tutto si configura nel file properties principale. Spring Boot configurerà automaticamente il \texttt{DataSource}, l'\texttt{EntityManagerFactory} e il \texttt{TransactionManager}.

\begin{lstlisting}[language=Java, caption=src/main/resources/application.properties]
# 1. Connessione DB (HikariCP e' il default in Spring Boot)
spring.datasource.url=jdbc:postgresql://localhost:5432/spring_db
spring.datasource.username=admin
spring.datasource.password=secret
spring.datasource.driver-class-name=org.postgresql.Driver

# 2. Configurazione JPA / Hibernate
# update: aggiorna lo schema se l'entity cambia (comodo in dev)
# validate: verifica che il DB corrisponda all'Entity (obbligatorio in prod)
spring.jpa.hibernate.ddl-auto=update

# Mostra le query SQL formattate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# 3. Dialect (Spesso Spring lo indovina da solo, ma meglio esplicitarlo)
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
\end{lstlisting}

\section{2. L'Entity (Standard JPA)}

L'Entity rimane quasi identica all'esempio Hibernate puro. Spring Data usa le annotazioni standard di JPA.

\begin{lstlisting}[language=Java, caption=User.java]
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    private String email;
    
    private boolean active;

    // Costruttori, Getter, Setter, toString...
}
\end{lstlisting}

\section{3. Il Repository (La Magia)}

Qui avviene la rivoluzione. Invece di scrivere una classe \texttt{UserRepositoryImpl} con 100 righe di codice per aprire sessioni e fare query, creiamo un'\textbf{Interfaccia}.

\begin{lstlisting}[language=Java, caption=UserRepository.java]
// Estendendo JpaRepository ereditiamo SUBITO metodi come:
// save(), findById(), findAll(), delete(), count()...
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    // --- A. DERIVED QUERIES (Query derivate dal nome) ---
    // Spring analizza il nome del metodo e crea la query JPQL automaticamente!
    
    // SELECT * FROM users WHERE email = ?
    Optional<User> findByEmail(String email);

    // SELECT * FROM users WHERE active = true AND username LIKE ?
    List<User> findByActiveTrueAndUsernameContaining(String partialName);

    // --- B. CUSTOM JPQL QUERY (@Query) ---
    // Quando il nome del metodo diventa troppo lungo o complesso
    @Query("SELECT u FROM User u WHERE u.active = true ORDER BY u.username")
    List<User> findAllActiveUsers();

    // --- C. NATIVE QUERY (SQL Puro) ---
    // Da usare solo se strettamente necessario (accoppia al DB specifico)
    @Query(value = "SELECT * FROM users u WHERE u.email LIKE '%@gmail.com'", 
           nativeQuery = true)
    List<User> findGmailUsers();
}
\end{lstlisting}

\begin{interview}{Come funziona findByEmail() se non l'ho implementato?}
    \textbf{Domanda:} "Come fa Java a eseguire un metodo che è definito solo in un'interfaccia senza classe concreta?"
    
    \textbf{Risposta:} Al bootstrap dell'applicazione, Spring Data usa la \textbf{Java Dynamic Proxy API}.
    Crea al volo una classe in memoria che implementa l'interfaccia \texttt{UserRepository}.
    Quando chiami \texttt{findByEmail}, il proxy intercetta la chiamata, analizza il nome del metodo (parsing), genera l'SQL corrispondente e lo esegue tramite l'\texttt{EntityManager} sottostante.
\end{interview}

\section{4. Ottimizzazioni: Paginazione e Proiezioni}

Un errore da Junior è caricare \texttt{findAll()} su una tabella con un milione di record. Spring Data offre soluzioni integrate.

\subsection{Paginazione}
Basta aggiungere un parametro \texttt{Pageable} al metodo del repository.

\begin{lstlisting}[language=Java, caption=Repository con Paginazione]
// Restituisce una "Pagina" di utenti (dati + metadati come totalPages)
Page<User> findByActiveTrue(Pageable pageable);
\end{lstlisting}

\subsection{Proiezioni (DTO)}
Spesso non serve caricare l'intera Entity (magari ha relazioni pesanti). Possiamo definire un'interfaccia (o un Record) con solo i getter che ci servono. Spring scriverà una SELECT ottimizzata.

\begin{lstlisting}[language=Java, caption=Proiezione Interface-based]
// 1. Definiamo la "vista" ridotta
public interface UserSummary {
    String getUsername();
    String getEmail();
    // L'ID e la password NON verranno caricati dal DB
}

// 2. Usiamola nel Repository
List<UserSummary> findByActiveTrue();
\end{lstlisting}

\section{5. Il Service Layer (Transazioni)}

In Spring, il Repository non dovrebbe gestire le transazioni. La logica transazionale appartiene al \textbf{Service}.
L'annotazione \texttt{@Transactional} fa tutto il lavoro sporco (apre, committa, rollbacka).

\begin{lstlisting}[language=Java, caption=UserService.java]
@Service
public class UserService {

    private final UserRepository userRepo;

    // Constructor Injection (Best Practice rispetto a @Autowired)
    public UserService(UserRepository userRepo) {
        this.userRepo = userRepo;
    }

    @Transactional(readOnly = true) // Ottimizzazione per sole letture
    public Page<User> getAllActive(int page, int size) {
        return userRepo.findByActiveTrue(PageRequest.of(page, size));
    }

    @Transactional // Default: Read-Write
    public void registerUser(User user) {
        if (userRepo.findByEmail(user.getEmail()).isPresent()) {
            throw new IllegalArgumentException("Email già esistente");
        }
        userRepo.save(user);
        // Al termine del metodo avviene il COMMIT automatico.
        // Se viene lanciata una RuntimeException, avviene il ROLLBACK.
    }
}
\end{lstlisting}

\begin{deepdive}{@Transactional e il Proxy}
    Quando metti \texttt{@Transactional} su un metodo, Spring avvolge il tuo Service in un Proxy (CGLIB o JDK).
    
    Il flusso reale è:
    \begin{enumerate}
        \item Il chiamante invoca il metodo sul Proxy.
        \item Il Proxy apre la transazione DB.
        \item Il Proxy chiama il metodo reale del tuo Service.
        \item Se il metodo finisce bene $\to$ Proxy fa Commit.
        \item Se il metodo lancia eccezione $\to$ Proxy fa Rollback.
    \end{enumerate}
    \textbf{Attenzione:} Se chiami un metodo transazionale da un altro metodo \textbf{della stessa classe} (es. \texttt{this.registerUser()}), il Proxy viene saltato e la transazione non parte! (Self-Invocation Problem).
\end{deepdive}

\section{6. Esecuzione: CommandLineRunner}

In un'app Spring Boot, non c'è il \texttt{public static void main} classico per la logica. Si usa un Bean che implementa \texttt{CommandLineRunner}, che viene eseguito all'avvio.

\begin{lstlisting}[language=Java, caption=DataLoader.java]
@Component
public class DataLoader implements CommandLineRunner {

    private final UserService userService;

    public DataLoader(UserService userService) {
        this.userService = userService;
    }

    @Override
    public void run(String... args) throws Exception {
        System.out.println("--- SPRING BOOT DATA DEMO ---");

        User u = new User();
        u.setUsername("SpringMaster");
        u.setEmail("master@spring.io");
        u.setActive(true);

        userService.registerUser(u);
        System.out.println("Utente registrato!");

        // Test Paginazione
        Page<User> page = userService.getAllActive(0, 10);
        System.out.println("Utenti attivi trovati: " + page.getTotalElements());
        
        page.getContent().forEach(user -> 
            System.out.println(" - " + user.getUsername())
        );
    }
}
\end{lstlisting}

\begin{interview}{Differenza tra CrudRepository e JpaRepository?}
    \textbf{Domanda:} "Vedo usare entrambi. Quale devo estendere?"
    
    \textbf{Risposta:}
    \begin{itemize}
        \item \textbf{CrudRepository:} È l'interfaccia base. Offre solo metodi CRUD (\texttt{save}, \texttt{findById}, \texttt{findAll}).
        \item \textbf{PagingAndSortingRepository:} Estende CrudRepository aggiungendo la paginazione.
        \item \textbf{JpaRepository:} Estende le precedenti ed aggiunge metodi specifici per JPA (es. \texttt{flush()}, \texttt{saveAndFlush()}, gestione batch).
    \end{itemize}
    \textbf{Consiglio:} Nel 99\% dei casi, estendi \textbf{JpaRepository} perché offre il set completo di funzionalità.
\end{interview}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Spring MVC \& REST API}

\section{Architettura e il Front Controller}

Spring MVC (Model-View-Controller) è il modulo web originale di Spring. Anche se oggi costruiamo principalmente API REST (che non hanno una "View" nel senso di HTML, ma restituiscono JSON), l'architettura sottostante rimane la stessa.

Tutto ruota attorno a un design pattern fondamentale: il \textbf{Front Controller Pattern}.

\subsection{Il DispatcherServlet}
In una classica applicazione Java Servlet (pre-Spring), ogni URL doveva essere mappato a una specifica Servlet nel \texttt{web.xml}. Questo diventava ingestibile rapidamente.

Spring risolve il problema con un'unica, onnipotente Servlet chiamata \textbf{DispatcherServlet}.
Questa riceve \textbf{tutte} le richieste HTTP in ingresso e ha il compito di smistarle al Controller giusto.

\begin{center}
\begin{tikzpicture}[
    node distance=2cm,
    auto,
    % Stili dei nodi
    font=\small\sffamily,
    block/.style={
        rectangle, 
        draw=deepblue, 
        fill=white, 
        text width=2.5cm, 
        align=center, 
        rounded corners, 
        minimum height=1.2cm, 
        line width=0.8pt
    },
    dispatcher/.style={
        rectangle, 
        draw=javared, 
        fill=javared!10, 
        text width=2.8cm, 
        align=center, 
        rounded corners, 
        minimum height=1.5cm, 
        line width=1.2pt, 
        font=\bfseries\sffamily
    },
    cloud/.style={
        draw=gray, 
        ellipse, 
        fill=codebg, 
        node distance=3cm, 
        minimum height=1.2cm,
        text width=2cm,
        align=center
    },
    % Stili delle frecce
    request_arrow/.style={
        ->, >=stealth, deepblue, thick, rounded corners
    },
    response_arrow/.style={
        ->, >=stealth, javagreen, thick, dashed, rounded corners
    },
    label_text/.style={
        font=\scriptsize, color=black!80, align=center
    }
]

    % --- POSIZIONAMENTO NODI ---
    
    % 1. Dispatcher al Centro
    \node[dispatcher] (dispatcher) {Dispatcher\\Servlet};

    % 2. Client a Sinistra
    \node[cloud, left=3.5cm of dispatcher] (client) {\textbf{Client}\\(Browser/App)};

    % 3. HandlerMapping in Alto
    \node[block, above=2.5cm of dispatcher] (mapping) {\textbf{Handler}\\Mapping};

    % 4. Controller a Destra (Include logicamente l'Adapter per semplicità visiva)
    \node[block, right=3.5cm of dispatcher] (controller) {\textbf{Rest}\\Controller};


    % --- FRECCE (Flusso Logico) ---

    % 1. Request Client -> Dispatcher (Spostata verso l'alto)
    \draw[request_arrow] ([yshift=2mm]client.east) -- ([yshift=2mm]dispatcher.west) 
        node[midway, above, label_text] {1. HTTP Request};

    % 2. Dispatcher -> Mapping (Spostata a sinistra)
    \draw[request_arrow] ([xshift=-2mm]dispatcher.north) -- ([xshift=-2mm]mapping.south) 
        node[midway, left, label_text] {2. Chi gestisce?};

    % 3. Mapping -> Dispatcher (Spostata a destra)
    \draw[response_arrow] ([xshift=2mm]mapping.south) -- ([xshift=2mm]dispatcher.north) 
        node[midway, right, label_text] {3. RestController\\Method};

    % 4. Dispatcher -> Controller (Spostata verso l'alto)
    \draw[request_arrow] ([yshift=2mm]dispatcher.east) -- ([yshift=2mm]controller.west) 
        node[midway, above, label_text] {4. Esegui logica};

    % 5. Controller -> Dispatcher (Spostata verso il basso)
    \draw[response_arrow] ([yshift=-2mm]controller.west) -- ([yshift=-2mm]dispatcher.east) 
        node[midway, below, label_text] {5. Return DTO\\(JSON Object)};

    % 6. Response Dispatcher -> Client (Spostata verso il basso)
    % Nota: Qui avviene la magia di Jackson (HttpMessageConverter)
    \draw[response_arrow] ([yshift=-2mm]dispatcher.west) -- ([yshift=-2mm]client.east) 
        node[midway, below, label_text] {6. HTTP Response\\(JSON)};

\end{tikzpicture}
\end{center}

\subsection{Il Flusso della Richiesta}
\begin{enumerate}
    \item La richiesta arriva al \texttt{DispatcherServlet}.
    \item Il Dispatcher consulta l'\texttt{HandlerMapping} per sapere quale metodo di quale Controller deve invocare (basandosi su URL e verbo HTTP).
    \item Il Dispatcher invoca il \textbf{Controller}.
    \item Il Controller esegue la logica di business (spesso chiamando un \textit{Service}).
    \item Il Controller restituisce un oggetto (es. \texttt{UserDto}).
    \item Poiché è una REST API (\texttt{@RestController}), Spring usa un \texttt{HttpMessageConverter} (di solito \textbf{Jackson}) per trasformare l'oggetto in JSON.
    \item La risposta JSON torna al Client.
\end{enumerate}

\begin{interview}{DispatcherServlet e ApplicationContext}
    \textbf{Domanda:} "Come fa il DispatcherServlet a conoscere i tuoi Bean?"
    
    \textbf{Risposta:} All'avvio di Spring Boot, il DispatcherServlet viene inizializzato e collegato all'\texttt{WebApplicationContext}. Questo contesto contiene tutti i bean definiti con \texttt{@Controller}, \texttt{@Service}, \texttt{@Repository}, rendendoli disponibili per l'iniezione delle dipendenze e per il mapping delle richieste.
\end{interview}

\section{Controller e Endpoint}

Il Controller è il componente che espone i punti di accesso (Endpoint) della tua applicazione al mondo esterno. In un'architettura REST, ogni metodo del controller corrisponde solitamente a una combinazione di URL + Verbo HTTP.

\subsection{@Controller vs @RestController}
Spesso si crea confusione su quale annotazione usare.

\begin{itemize}
    \item \textbf{@Controller:} È l'annotazione originale di Spring MVC. I metodi di questa classe, di default, restituiscono una \texttt{String} che rappresenta il \textbf{nome della vista} (es. "index.html" o "home.jsp"). Per restituire dati grezzi, bisognava aggiungere \texttt{@ResponseBody} su ogni metodo.
    \item \textbf{@RestController:} Introdotta in Spring 4.0, è un'annotazione di convenienza che combina \texttt{@Controller} + \texttt{@ResponseBody}. I metodi restituiscono oggetti che vengono automaticamente serializzati in JSON (o XML) nel corpo della risposta HTTP.
\end{itemize}

\begin{deepdive}{Dietro le quinte}
    \texttt{@RestController} è definita letteralmente così:
    \begin{verbatim}
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @Controller
    @ResponseBody
    public @interface RestController {}
    \end{verbatim}
    Questo dimostra che è solo "zucchero sintattico".
\end{deepdive}

\subsection{Definizione degli Endpoint}
Per mappare le richieste HTTP ai metodi Java, usiamo le annotazioni di mapping.
È buona norma definire il percorso base a livello di classe e i percorsi specifici a livello di metodo.

\begin{lstlisting}[language=Java, caption=Struttura tipica di un Controller REST]
@RestController
@RequestMapping("/api/v1/users") // Base path per tutti i metodi
public class UserController {

    private final UserService userService;

    // Injection via costruttore (Best Practice)
    public UserController(UserService userService) {
        this.userService = userService;
    }

    // GET /api/v1/users
    @GetMapping
    public List<UserDto> getAllUsers() {
        return userService.findAll();
    }

    // GET /api/v1/users/{id}
    @GetMapping("/{id}")
    public UserDto getUserById(@PathVariable Long id) {
        return userService.findById(id);
    }

    // POST /api/v1/users
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED) // Restituisce 201 invece di 200
    public UserDto createUser(@RequestBody UserDto userDto) {
        return userService.save(userDto);
    }

    // DELETE /api/v1/users/{id}
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT) // Restituisce 204 (Body vuoto)
    public void deleteUser(@PathVariable Long id) {
        userService.delete(id);
    }
}
\end{lstlisting}

\subsection{Gli Stereotipi di Spring}
Ai colloqui chiedono spesso la differenza tra le varie annotazioni di componente.

\begin{interview}{Component - Service - Repository - Controller}
    \textbf{Domanda:} "Tecnicamente \texttt{@Service} e \texttt{@Repository} sono alias di \texttt{@Component}. Perché li distinguiamo?"
    
    \textbf{Risposta:} È vero che per il Container di Spring sono tutti Bean gestiti allo stesso modo (Singleton, Lazy/Eager, ecc.), ma hanno semantiche e funzionalità extra diverse:
    
    \begin{enumerate}
        \item \textbf{@Component:} Annotazione generica per bean non categorizzabili (es. una classe di Utility, un Mapper).
        \item \textbf{@Controller / @RestController:} Indica che la classe gestisce richieste Web. Il \texttt{DispatcherServlet} scansiona specificamente queste classi per mappare gli URL.
        \item \textbf{@Service:} Semanticamente indica che la classe contiene "Business Logic". Attualmente non aggiunge funzionalità tecniche extra rispetto a Component, ma serve a chiarire l'architettura.
        \item \textbf{@Repository:} Indica che la classe interagisce con il DB (DAO pattern).
        \textbf{Funzionalità Extra:} Abilita la \textit{PersistenceExceptionTranslation}. Se il driver JDBC lancia un'eccezione SQL nativa (es. \texttt{SQLException}), Spring la intercetta e la traduce in una \texttt{DataAccessException} (unchecked e comune a tutti i DB), disaccoppiando il codice dalla tecnologia sottostante.
    \end{enumerate}
\end{interview}

\section{Gestione dei Dati (Request \& Response)}

Un'API REST è, essenzialmente, un meccanismo per scambiare dati. Spring MVC offre diversi modi per estrarre informazioni dalla richiesta HTTP in ingresso e formattare la risposta in uscita.

\subsection{Input: PathVariable vs RequestParam}
Questa è una distinzione fondamentale nel design delle API REST.

\begin{itemize}
    \item \textbf{@PathVariable:} Si usa quando il dato è parte integrante dell'identità della risorsa (RESTful style).
    \textit{Esempio:} \texttt{/users/123} (123 identifica l'utente).
    
    \item \textbf{@RequestParam:} Si usa per filtrare, ordinare o configurare la richiesta. I dati viaggiano nella "Query String".
    \textit{Esempio:} \texttt{/users?role=ADMIN\&active=true}.
\end{itemize}

\begin{lstlisting}[language=Java, caption=Differenza di utilizzo]
// 1. PathVariable (Parte dell'URI)
// Chiamata: GET /products/42
@GetMapping("/products/{id}")
public Product getProduct(@PathVariable Long id) { ... }

// 2. RequestParam (Query String)
// Chiamata: GET /products?category=BOOKS&sort=price
@GetMapping("/products")
public List<Product> searchProducts(
    @RequestParam String category, // Obbligatorio di default
    @RequestParam(required = false, defaultValue = "name") String sort // Opzionale
) { ... }
\end{lstlisting}

\subsection{Input: @RequestBody e Deserializzazione}
Per le operazioni di scrittura (POST, PUT), i dati complessi viaggiano nel corpo (Body) della richiesta, solitamente in formato JSON.
L'annotazione \texttt{@RequestBody} dice a Spring: "Prendi il JSON nel body e trasformalo in questo oggetto Java".

\begin{deepdive}{Il ruolo di Jackson (ObjectMapper)}
    Spring non fa la conversione da solo. Delega il lavoro a una libreria esterna chiamata \textbf{Jackson} (inclusa di default in Spring Boot).
    
    Quando usi \texttt{@RequestBody}, dietro le quinte agisce un componente chiamato \texttt{MappingJackson2HttpMessageConverter}.
    
    \textbf{Requisiti affinché funzioni:}
    \begin{enumerate}
        \item La classe Java (DTO) deve avere un \textbf{Costruttore di Default} (vuoto), affinché Jackson possa istanziarla.
        \item I campi devono avere i \textbf{Getter/Setter} (o essere pubblici), oppure Jackson non potrà scriverci dentro (a meno di configurazioni specifiche sulla visibilità).
    \end{enumerate}
\end{deepdive}

\subsection{Controllare il JSON: @JsonProperty e @JsonIgnore}
Spesso il nome del campo nel database o nella classe Java non deve corrispondere a quello esposto nell'API.

\begin{lstlisting}[language=Java, caption=Personalizzazione JSON]
public class UserDto {
    
    // Nel JSON sarà "user_email" invece di "email"
    @JsonProperty("user_email")
    private String email;

    // Questo campo NON verrà mai inviato al client (Sicurezza)
    @JsonIgnore
    private String password;
}
\end{lstlisting}

\subsection{Output: Content Negotiation}
Come fa Spring a sapere se restituire JSON o XML?

\begin{interview}{Come funziona la Content Negotiation?}
    \textbf{Domanda:} "La stessa API può restituire i dati sia in JSON che in XML. Come decide Spring quale formato usare?"
    
    \textbf{Risposta:} Spring guarda l'header HTTP \textbf{Accept} inviato dal client.
    
    \begin{itemize}
        \item Se il client invia \texttt{Accept: application/json} $\to$ Restituisce JSON (Default).
        \item Se il client invia \texttt{Accept: application/xml} $\to$ Restituisce XML (se la libreria \textit{Jackson XML} è presente nel classpath).
        \item Se l'header manca, Spring usa il formato di default (JSON).
    \end{itemize}
    
    Questo meccanismo è gestito dall'interfaccia \texttt{HttpMessageConverter}. Spring cicla su tutti i converter disponibili e sceglie il primo capace di scrivere il tipo di risposta richiesto.
\end{interview}

\section{DTO Pattern (Data Transfer Object)}

Una regola d'oro nello sviluppo di API REST Enterprise è: \textbf{Non esporre mai le tue Entity JPA (@Entity) direttamente come risposta del Controller.}

Le Entity rappresentano il tuo Database (struttura interna).
I DTO rappresentano il contratto della tua API (struttura pubblica).
Questi due mondi devono rimanere disaccoppiati.

\subsection{I 3 Grandi Problemi delle Entity nei Controller}
Se restituisci `return userRepository.findAll()` direttamente, incorri in tre problemi fatali:

\begin{enumerate}
    \item \textbf{Sicurezza (Data Leakage):} La tua Entity `User` contiene probabilmente campi come `password`, `salt`, `created\_at` o flag interni. Se la serializzi in JSON, Jackson invierà tutto al client, inclusa la password hashata. Usare `@JsonIgnore` sull'Entity è una pezza, non una soluzione (sporchi il modello di dominio con logica di presentazione).
    
    \item \textbf{Accoppiamento (Tight Coupling):} Se domani rinomini una colonna nel DB o spacchi una tabella in due per performance, spacchi automaticamente l'API usata dai client Front-end. Col DTO, puoi cambiare il DB quanto vuoi, basta rimappare il DTO correttamente.
    
    \item \textbf{Eccezioni di Serializzazione (Infinite Recursion):} Questo è un classico.
\end{enumerate}

\begin{deepdive}{Deep Dive: Infinite Recursion e Lazy Loading}
    Le Entity hanno spesso relazioni bidirezionali (es. Utente $\leftrightarrow$ Ordini).
    \begin{itemize}
        \item \textbf{Infinite Recursion:} Jackson inizia a serializzare l'Utente, trova la lista di Ordini, entra nell'Ordine, trova il riferimento all'Utente, torna all'Utente... Boom: \texttt{StackOverflowError}.
        \item \textbf{LazyInitializationException:} Se hai una relazione \texttt{FetchType.LAZY}, i dati non sono caricati in memoria. Quando Jackson prova a leggerli nel Controller (fuori dalla transazione del Service), Hibernate lancia l'eccezione perché la sessione col DB è chiusa.
    \end{itemize}
    \textbf{Soluzione:} Il DTO è un POJO piatto (senza logica JPA), quindi Jackson lo serializza senza problemi.
\end{deepdive}

\subsection{Implementazione: Entity vs DTO}

\begin{lstlisting}[language=Java, caption=Il problema (Entity) vs La soluzione (DTO)]
// --- ENTITY (Modello DB) ---
@Entity
public class User {
    @Id
    private Long id;
    private String username;
    private String password; // PERICOLO!
    
    @OneToMany(mappedBy = "user")
    private List<Order> orders; // Rischio Lazy/Recursion
}

// --- DTO (Modello API) ---
public class UserResponseDto {
    private Long id;
    private String username;
    // Niente password!
    private int ordersCount; // Magari al client serve solo il numero, non la lista
}
\end{lstlisting}

\subsection{Strategie di Mapping}
Come copiamo i dati dall'Entity al DTO?

\begin{interview}{MapStruct vs ModelMapper vs BeanUtils}
    \textbf{Domanda:} "Come gestisci la conversione tra Entity e DTO?"
    
    \textbf{Risposta:} Evito \texttt{BeanUtils} (copia shallow, pericolosa) e \texttt{ModelMapper} (usa Reflection a runtime, lento e difficile da debuggare).
    
    Preferisco \textbf{MapStruct}.
    \begin{itemize}
        \item Lavora a \textbf{Compile Time} (genera codice Java reale durante la build).
        \item È \textbf{Type-Safe}: se cambi un campo e dimentichi di aggiornare il mapper, la build fallisce (ottimo per il refactoring).
        \item È estremamente \textbf{veloce} (zero overhead di reflection).
    \end{itemize}
\end{interview}

\begin{lstlisting}[language=Java, caption=Esempio MapStruct]
@Mapper(componentModel = "spring")
public interface UserMapper {
    
    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    // Mapping automatico per nomi uguali
    @Mapping(target = "userId", source = "id") 
    UserDto toDto(User entity);
    
    User toEntity(UserDto dto);
}
\end{lstlisting}

\section{Validazione dei Dati}

Uno dei principi cardine della sicurezza e della stabilità è: \textbf{Mai fidarsi dell'input utente}.
Invece di riempire il codice di controlli manuali (`if (dto.getEmail() == null)...`), Spring Boot supporta lo standard \textbf{Jakarta Validation} (implementato da Hibernate Validator).

Questo permette di definire le regole di validazione in modo \textit{dichiarativo} direttamente sui campi del DTO tramite annotazioni.

\subsection{Le Annotazioni Principali}
Per attivare la validazione, è necessario aggiungere la dipendenza \texttt{spring-boot-starter-validation}. Ecco le annotazioni più comuni:

\begin{lstlisting}[language=Java, caption=DTO con Validazione]
public class UserRegistrationDto {

    @NotBlank(message = "Il nome non può essere vuoto")
    private String firstName;

    @Email(message = "Formato email non valido")
    @NotBlank
    private String email;

    @Size(min = 8, max = 20, message = "La password deve essere tra 8 e 20 caratteri")
    private String password;

    @Min(value = 18, message = "Devi essere maggiorenne")
    private int age;
    
    // @Pattern per Regex complesse (es. Codice Fiscale)
    @Pattern(regexp = "^[A-Z]{6}[0-9]{2}...", message = "Codice Fiscale invalido")
    private String fiscalCode;
}
\end{lstlisting}

\begin{interview}{NotNull vs NotEmpty vs NotBlank}
    \textbf{Domanda:} "Qual è la differenza tra queste tre annotazioni per le Stringhe? Quale useresti per un campo 'username'?"
    
    \textbf{Risposta:} È una trappola classica.
    \begin{itemize}
        \item \textbf{@NotNull:} Impedisce solo il valore \texttt{null}. Accetta stringhe vuote \texttt{""} o stringhe di soli spazi \texttt{"   "}. Spesso inutile da solo per le stringhe.
        \item \textbf{@NotEmpty:} Impedisce \texttt{null} e stringhe di lunghezza 0 (\texttt{""}). Accetta però stringhe di soli spazi \texttt{"   "}.
        \item \textbf{@NotBlank:} È la più restrittiva. Impedisce \texttt{null}, vuote e stringhe composte \textbf{solo da spazi}. Inoltre \textbf{trimma} la stringa prima del controllo.
    \end{itemize}
    \textbf{Conclusione:} Per i campi testuali obbligatori (nome, email, username), si usa quasi sempre \textbf{@NotBlank}.
\end{interview}

\subsection{Attivare la Validazione nel Controller}
Aver annotato il DTO non basta. Bisogna istruire Spring di eseguire i controlli nel momento in cui riceve la richiesta.
Si usa l'annotazione \textbf{@Valid} (o \texttt{@Validated}) prima del parametro \texttt{@RequestBody}.

\begin{lstlisting}[language=Java, caption=Trigger della Validazione]
@PostMapping
public UserDto register(@Valid @RequestBody UserRegistrationDto dto) {
    // Se arrivo qui, SONO SICURO che il dto è valido.
    // Non serve fare if(dto.getEmail() == null).
    return userService.register(dto);
}
\end{lstlisting}

\subsection{Cosa succede se la validazione fallisce?}
Se un campo non rispetta le regole:
\begin{enumerate}
    \item Il metodo del controller \textbf{NON} viene eseguito.
    \item Spring lancia automaticamente un'eccezione di tipo \textbf{MethodArgumentNotValidException}.
    \item Di default, Spring Boot risponde con un HTTP 400 Bad Request e un JSON standard (che però è spesso troppo verboso e poco leggibile per il frontend).
\end{enumerate}

\begin{deepdive}{Gestione Manuale con BindingResult}
    Esiste un modo per non far lanciare l'eccezione e gestire l'errore manualmente dentro il metodo.
    Basta aggiungere un oggetto \texttt{BindingResult} \textbf{immediatamente dopo} il DTO validato.
    
    \begin{small}
    \begin{verbatim}
    public ResponseEntity<?> create(@Valid @RequestBody UserDto dto, 
                                    BindingResult result) {
        if (result.hasErrors()) {
            return ResponseEntity.badRequest().body("Errore nei dati!");
        }
        // ...
    }
    \end{verbatim}
    \end{small}
    
    \textbf{Nota:} Sebbene utile a fini didattici, nei progetti reali si preferisce lasciar lanciare l'eccezione e gestirla centralmente (come vedremo nella prossima sezione), per tenere pulito il codice del controller.
\end{deepdive}

\section{Gestione Globale degli Errori (Exception Handling)}

Un cattivo esempio di Controller è quello pieno di blocchi \texttt{try-catch}.
Questo approccio porta a duplicazione del codice e risposte di errore incoerenti (un endpoint restituisce un messaggio stringa, l'altro un JSON, l'altro nulla).

Spring MVC risolve il problema intercettando le eccezioni a livello globale tramite il pattern AOP (Aspect Oriented Programming), usando l'annotazione \textbf{@ControllerAdvice} (o la specializzazione \textbf{@RestControllerAdvice}).

\subsection{L'architettura Centralizzata}
L'idea è semplice:
\begin{enumerate}
    \item Il Controller esegue solo l'Happy Path (il caso in cui tutto va bene).
    \item Se qualcosa va storto (es. ID non trovato), il Service lancia un'eccezione (es. \texttt{UserNotFoundException}).
    \item L'eccezione risale la pila fino a uscire dal Controller.
    \item Un componente globale cattura l'eccezione e la trasforma in una \texttt{ResponseEntity} formattata correttamente.
\end{enumerate}

\subsection{Implementazione: @RestControllerAdvice}

\begin{lstlisting}[language=Java, caption=Global Exception Handler]
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 1. Gestione eccezioni custom (es. Risorsa non trovata)
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    // 2. Gestione errori di Validazione (@Valid fallito)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationErrors(
            MethodArgumentNotValidException ex) {
            
        Map<String, String> errors = new HashMap<>();
        
        // Estrae i messaggi di errore dai campi del DTO
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });
        
        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }

    // 3. Catch-all per errori imprevisti (NullPointer, DB down...)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        // Loggare sempre l'errore reale sui server log!
        return new ResponseEntity<>("Errore interno del server", 
                                    HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
\end{lstlisting}

\subsection{Standardizzazione: RFC 7807 (Problem Details)}
Inventarsi un formato JSON per gli errori (come l'oggetto \texttt{ErrorResponse} sopra) va bene, ma esiste uno standard IETF internazionale chiamato \textbf{Problem Details for HTTP APIs} (RFC 7807).

\begin{deepdive}{Novità Spring Boot 3: ProblemDetail}
    Dalla versione 6 di Spring Framework (Spring Boot 3), c'è il supporto nativo per questo standard. Non serve più creare DTO custom per gli errori.
    
    Puoi restituire direttamente l'oggetto \texttt{ProblemDetail}:
    
    \begin{small}
    \begin{verbatim}
    @ExceptionHandler(UserNotFoundException.class)
    public ProblemDetail handleNotFound(UserNotFoundException ex) {
        return ProblemDetail.forStatusAndDetail(
            HttpStatus.NOT_FOUND, 
            ex.getMessage()
        );
    }
    \end{verbatim}
    \end{small}
    
    Il JSON risultante sarà standard e automaticamente arricchito (con campi come \texttt{type}, \texttt{title}, \texttt{status}, \texttt{detail}, \texttt{instance}).
\end{deepdive}

\begin{interview}{Gestione 404 vs 500}
    \textbf{Domanda:} "Se cerco un utente con ID 99 e non esiste, il server deve restituire 200 con body vuoto, 404 o 500?"
    
    \textbf{Risposta:}
    \begin{itemize}
        \item \textbf{Mai 500:} Il 500 è per errori del server (bug, db down). L'assenza di un dato è una situazione gestita.
        \item \textbf{Mai 200 con body vuoto:} È ambiguo. Le REST API usano i codici di stato come protocollo di comunicazione.
        \item \textbf{Corretto: 404 Not Found.}
    \end{itemize}
    
    \textbf{Eccezione:} Per una ricerca su una lista (es. \texttt{/users?name=X}), se non trovo nulla restituisco \textbf{200 OK} con una lista vuota \texttt{[]}, non 404. Il 404 si usa quando la risorsa specifica (identificata dall'URL) non esiste.
\end{interview}

\section{Teoria REST e Best Practices}

Scrivere un'API REST non significa solo restituire JSON invece di HTML. REST (Representational State Transfer) è uno stile architetturale basato su principi precisi.
Ignorare questi principi porta a creare API "RPC over HTTP" (una collezione di URL disordinati) invece di vere risorse RESTful.

\subsection{Il Modello di Maturità di Richardson}
È una scala da 0 a 3 usata per classificare quanto un'API è aderente ai principi REST.

\begin{itemize}
    \item \textbf{Livello 0 (The Swamp of POX):} Si usa HTTP solo come tunnel. Esiste un solo URL (es. \texttt{/apiService}) e si usa sempre POST per tutto (stile SOAP/RPC).
    \item \textbf{Livello 1 (Resources):} Si introducono URL distinti per risorse diverse (es. \texttt{/users}, \texttt{/products}).
    \item \textbf{Livello 2 (HTTP Verbs):} Si usano i verbi corretti per le azioni (GET per leggere, POST per creare, DELETE per rimuovere). Questo è il livello della maggior parte delle API commerciali.
    \item \textbf{Livello 3 (HATEOAS):} \textit{Hypermedia As The Engine Of Application State}. La risposta API contiene non solo i dati, ma anche i link per le possibili azioni successive (es. "next\_page", "delete\_user"). È il "Santo Graal" del REST, ma complesso da implementare.
\end{itemize}

\subsection{PUT vs PATCH: La differenza semantica}
Questa è forse la domanda numero 1 sui verbi HTTP.

\begin{interview}{Differenza tra PUT e PATCH}
    \textbf{Domanda:} "Voglio modificare l'email di un utente. Uso PUT o PATCH?"
    
    \textbf{Risposta:} Dipende da come implementi l'aggiornamento.
    \begin{itemize}
        \item \textbf{PUT (Sostituzione Completa):} Il client invia l'intera risorsa modificata. Se l'oggetto ha 10 campi e ne invii solo 1 (l'email), gli altri 9 dovrebbero essere resettati a \texttt{null} (o cancellati). È idempotente.
        \item \textbf{PATCH (Aggiornamento Parziale):} Il client invia solo i campi che cambiano. Se invii solo l'email, il server aggiorna l'email e mantiene inalterati gli altri 9 campi. Non è necessariamente idempotente.
    \end{itemize}
    \textbf{Best Practice:} Per modifiche puntuali (es. cambio password o email), si preferisce \textbf{PATCH}.
\end{interview}

\subsection{Codici di Stato HTTP (Status Codes)}
Non restituire sempre \texttt{200 OK}! Il codice di stato è parte integrante della risposta.

\begin{itemize}
    \item \textbf{2xx Success}
    \begin{itemize}
        \item \textbf{200 OK:} Operazione riuscita (generico).
        \item \textbf{201 Created:} Risorsa creata con successo (Risposta a una POST).
        \item \textbf{204 No Content:} Operazione riuscita, ma non c'è nulla da restituire (tipico della DELETE).
    \end{itemize}
    
    \item \textbf{4xx Client Error}
    \begin{itemize}
        \item \textbf{400 Bad Request:} Errore generico di sintassi.
        \item \textbf{401 Unauthorized:} Non sei loggato (manca il token).
        \item \textbf{403 Forbidden:} Sei loggato ma non hai i permessi (manca il ruolo).
        \item \textbf{404 Not Found:} Risorsa inesistente.
        \item \textbf{422 Unprocessable Entity:} I dati sono sintatticamente corretti (è un JSON valido), ma semanticamente errati (es. validazione fallita). Molto usato in Spring.
    \end{itemize}
    
    \item \textbf{5xx Server Error}
    \begin{itemize}
        \item \textbf{500 Internal Server Error:} Bug nel codice, NullPointer non gestita, DB irraggiungibile.
    \end{itemize}
\end{itemize}

\subsection{Idempotenza}
Un concetto avanzato che distingue i Senior Developer.

\begin{deepdive}{Cos'è l'Idempotenza?}
    Un'operazione è \textbf{idempotente} se eseguirla più volte produce lo stesso effetto di eseguirla una volta sola.
    $$ f(f(x)) = f(x) $$
    
    \textbf{Esempi:}
    \begin{itemize}
        \item \textbf{DELETE (Idempotente):} Se cancello l'utente ID 5, sparisce. Se riprovo a cancellarlo, non esiste già più (mi darà 404), ma lo stato del server è identico (l'utente 5 non c'è). Non faccio danni.
        \item \textbf{GET (Idempotente):} Leggere 100 volte non cambia i dati.
        \item \textbf{PUT (Idempotente):} "Imposta il nome a 'Mario'". Se lo dico 10 volte, il nome resta 'Mario'.
        \item \textbf{POST (NON Idempotente):} "Crea un ordine". Se la rete cade e il client ritenta l'invio (Retry), potrei creare \textbf{due} ordini identici e addebitare due volte il cliente.
    \end{itemize}
    
    \textbf{Implicazione:} Se usi POST, devi gestire manualmente la duplicazione (es. tramite un "Idempotency Key" nell'header).
\end{deepdive}

\section{Documentazione e Client}

Un'API non documentata è un'API che non esiste. Inoltre, un backend developer non si limita a \textit{creare} API, spesso deve \textit{consumare} API esterne (es. Gateway di pagamento, servizi meteo, microservizi interni).

\subsection{Documentazione: Swagger / OpenAPI}
Fino a qualche anno fa si usava la libreria \textit{Springfox} (ormai abbandonata). Oggi lo standard è \textbf{Springdoc OpenAPI}.
Questa libreria analizza i tuoi Controller al bootstrap e genera automaticamente una pagina web interattiva dove testare le API.

Basta aggiungere la dipendenza \texttt{springdoc-openapi-starter-webmvc-ui}.
L'interfaccia sarà disponibile su: \texttt{http://localhost:8080/swagger-ui/index.html}.

\begin{lstlisting}[language=Java, caption=Arricchire la documentazione]
@RestController
@RequestMapping("/api/users")
// Descrizione generale del Controller
@Tag(name = "User API", description = "Gestione anagrafica utenti")
public class UserController {

    @Operation(summary = "Cerca utente per ID", 
               description = "Restituisce 404 se l'utente non esiste")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Trovato"),
        @ApiResponse(responseCode = "404", description = "Non trovato")
    })
    @GetMapping("/{id}")
    public UserDto getUser(@PathVariable Long id) { ... }
}
\end{lstlisting}

\subsection{Consumare API Esterne: L'evoluzione dei Client}
Spring ha cambiato strategia diverse volte negli anni. È importante conoscere la storia per scegliere lo strumento giusto.

\begin{interview}{RestTemplate vs WebClient vs RestClient}
    \textbf{Domanda:} "Devo chiamare un servizio esterno da un'app Spring Boot 3. Cosa uso?"
    
    \textbf{Risposta:}
    \begin{enumerate}
        \item \textbf{RestTemplate:} È il client storico (bloccante). È in \textit{Maintenance Mode}. Non verranno aggiunte nuove feature. Si usa solo su progetti legacy.
        \item \textbf{WebClient:} È il client moderno e Reattivo (non-bloccante). È potente, ma richiede la dipendenza \texttt{spring-boot-starter-webflux}. Usarlo in un'app MVC classica è spesso "overkill" (porta dentro Netty e tutto lo stack reattivo inutilmente).
        \item \textbf{RestClient (La Scelta Giusta):} Introdotto in \textbf{Spring Boot 3.2}. Offre la stessa sintassi fluente e moderna di WebClient, ma funziona sullo stack Servlet classico (bloccante). È il successore spirituale di RestTemplate.
    \end{enumerate}
\end{interview}

\subsection{Esempio: Usare il nuovo RestClient}
Ecco come fare una chiamata HTTP in modo moderno, elegante e tipizzato, senza importare WebFlux.

\begin{lstlisting}[language=Java, caption=Chiamata GET con RestClient]
@Service
public class WeatherService {

    private final RestClient restClient;

    public WeatherService(RestClient.Builder builder) {
        // Configurazione base (URL, Timeout, Auth)
        this.restClient = builder
                .baseUrl("https://api.weather.com")
                .defaultHeader("Authorization", "Bearer my-token")
                .build();
    }

    public WeatherDto getWeather(String city) {
        return restClient.get()
                .uri("/forecast/{city}", city)
                .retrieve()
                // Gestione errori specifica per status code
                .onStatus(HttpStatusCode::is4xxClientError, (req, resp) -> {
                    throw new CityNotFoundException();
                })
                .body(WeatherDto.class); // Deserializzazione automatica JSON -> Oggetto
    }
}
\end{lstlisting}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Deep Dive: Spring MVC vs WebFlux}
La scelta tra Spring MVC (Imperativo) e Spring WebFlux (Reattivo) non è solo una questione di preferenze, ma di fisica del software. Riguarda come la CPU e la Memoria vengono utilizzate per gestire l'I/O (Input/Output).

\section{Visualizzare l'Architettura}

Per capire perché WebFlux scala meglio con connessioni lente o massicce, guardiamo come vengono gestiti i thread.

\subsection{Spring MVC: Blocking I/O}
In MVC, ogni richiesta occupa un thread del sistema operativo (Thread-per-Request). Se il database ci mette 2 secondi a rispondere, quel thread rimane "congelato" per 2 secondi. Non consuma CPU, ma occupa RAM e risorse di gestione.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    thread/.style={rectangle, draw=deepblue, fill=deepblue!10, rounded corners, minimum height=0.8cm, minimum width=2.5cm},
    db/.style={cylinder, draw=javared, fill=javared!10, shape border rotate=90, aspect=0.25, minimum height=1.5cm, minimum width=1.5cm}
]

% Threads
\node[thread] (t1) {Thread 1 (User A)};
\node[thread, below=0.5cm of t1] (t2) {Thread 2 (User B)};
\node[thread, below=0.5cm of t2] (t3) {Thread 3 (User C)};

% DB
\node[db, right=4cm of t2] (database) {Database};

% Arrows
\draw[->, thick, deepblue] (t1) -- node[above, font=\tiny] {Bloccato in attesa} (database);
\draw[->, thick, deepblue] (t2) -- (database);
\draw[->, thick, deepblue] (t3) -- (database);

\node[draw=red, fit=(t1) (t3), dashed, label=below:\textcolor{red}{Thread Pool Limitato (es. 200)}] {};

\end{tikzpicture}
\caption{Spring MVC: Se il DB rallenta, i Thread finiscono e il server non accetta più utenti.}
\end{figure}

\subsection{WebFlux: Non-Blocking Event Loop}
WebFlux usa un numero ridottissimo di thread (solitamente pari al numero di Core della CPU). Quando arriva una richiesta che deve andare al DB, il thread "prenota" la richiesta e passa subito a gestire un altro utente. Quando il DB risponde, scatta un evento che il thread raccoglie.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=2cm,
    worker/.style={circle, draw=intervieworange, fill=intervieworange!10, very thick, minimum size=1.5cm},
    req/.style={rectangle, draw=gray, dashed, minimum width=1cm},
    db/.style={cylinder, draw=javared, fill=javared!10, shape border rotate=90, aspect=0.25, minimum height=1.5cm, minimum width=1.5cm}
]

% Event Loop
\node[worker] (loop) {Event Loop};

% Requests
\node[req, left=2.5cm of loop] (reqs) {Migliaia di Req};
\node[db, right=2.5cm of loop] (database) {Database};

% Arrows
\draw[->, thick, intervieworange, bend left] (reqs) to node[above, font=\tiny] {1. Accetta e delega} (loop);
\draw[->, thick, intervieworange, bend left] (loop) to node[above, font=\tiny] {2. Richiesta asincrona} (database);
\draw[->, thick, javared, bend left] (database) to node[below, font=\tiny] {3. Callback (Dati pronti)} (loop);
\draw[->, thick, javared, bend left] (loop) to node[below, font=\tiny] {4. Risposta Utente} (reqs);

\end{tikzpicture}
\caption{WebFlux: Un solo thread gestisce il traffico come un vigile urbano.}
\end{figure}

\section{Confronto pratico del Codice}

La differenza non è solo architetturale, ma sintattica. WebFlux richiede un cambio di paradigma: dalla programmazione sequenziale a quella \textbf{funzionale/dichiarativa}.

Immaginiamo di dover fare tre operazioni:
\begin{enumerate}
    \item Cercare un utente per ID.
    \item Cercare gli ordini di quell'utente.
    \item Combinare tutto in un DTO.
\end{enumerate}

\subsection{Approccio MVC (Imperativo)}
Il codice si legge dall'alto in basso. È facile da capire e debuggare.

\begin{lstlisting}[language=Java, caption={Service MVC Classico}]
public UserDashboardDTO getDashboard(String userId) {
    // 1. Chiamata bloccante al DB
    User user = userRepository.findById(userId)
        .orElseThrow(() -> new UserNotFoundException());
    
    // 2. Il thread aspetta qui che finisca la prima query
    List<Order> orders = orderRepository.findAllByUserId(userId);
    
    // 3. Costruzione e ritorno
    return new UserDashboardDTO(user, orders);
}
\end{lstlisting}

\subsection{Approccio WebFlux (Reattivo)}
Qui non stiamo eseguendo il codice, stiamo \textit{costruendo una pipeline}. Il codice verrà eseguito solo quando qualcuno si "iscrive" (subscribe) al flusso.

\begin{lstlisting}[language=Java, caption={Service WebFlux con Reactor}]
public Mono<UserDashboardDTO> getDashboard(String userId) {
    // 1. Inizia il flusso
    Mono<User> userMono = userRepository.findById(userId)
        .switchIfEmpty(Mono.error(new UserNotFoundException()));

    // 2. Ottieni ordini (Flux = 0..N elementi)
    Flux<Order> ordersFlux = orderRepository.findAllByUserId(userId);

    // 3. Combina i risultati in parallelo o sequenza
    // zipWith aspetta che entrambi i flussi siano completi
    return userMono.zipWith(ordersFlux.collectList(), (user, orders) -> {
        return new UserDashboardDTO(user, orders);
    });
}
\end{lstlisting}

\begin{deepdive}{Mono vs Flux}
Questi sono i due mattoni fondamentali di Project Reactor (la libreria dietro WebFlux):
\begin{itemize}
    \item \textbf{Mono<T>}: Rappresenta un produttore che emetterà \textbf{0 o 1} elemento. (Es. `findById`).
    \item \textbf{Flux<T>}: Rappresenta un produttore che emetterà \textbf{da 0 a N} elementi. (Es. `findAll`, o uno stream di dati infinito).
\end{itemize}
Non restituisci mai il dato puro, restituisci sempre il "futuro" contenitore del dato.
\end{deepdive}

\section{Il concetto di Backpressure}
Questo è il vero vantaggio tecnico di WebFlux che spesso viene ignorato nei tutorial base.

In un sistema MVC classico, se il client invia richieste troppo velocemente, il server può andare in \textit{Out Of Memory} cercando di bufferizzarle tutte.
In WebFlux, il "Subscriber" (chi consuma i dati) può dire al "Publisher" (chi produce i dati): \textit{"Ehi, rallenta! Mandami solo 10 elementi per volta, non riesco a gestirne di più"}.

\begin{interview}{Cos'è la Backpressure?}
È un meccanismo di feedback che permette al consumatore di controllare la velocità di emissione del produttore per evitare di essere sopraffatto. È nativo nelle Reactive Streams.
\end{interview}

\section{Database: JDBC vs R2DBC}
Un errore gravissimo è usare WebFlux con i driver classici (JDBC, JPA/Hibernate).

\begin{itemize}
    \item \textbf{JDBC (Java Database Connectivity)}: È bloccante per specifica. Se usi JDBC dentro WebFlux, blocchi l'Event Loop e l'app smette di rispondere a chiunque.
    \item \textbf{R2DBC (Reactive Relational Database Connectivity)}: È la nuova specifica per driver SQL non bloccanti.
\end{itemize}

\textbf{Limitazioni attuali di R2DBC:}
\begin{itemize}
    \item Niente \textit{Lazy Loading} (tutto deve essere esplicito).
    \item Niente \textit{Caching di primo livello} automatico come in Hibernate.
    \item Gestione delle relazioni (@OneToMany) molto più manuale e complessa rispetto a JPA.
\end{itemize}

\section{Quando NON usare WebFlux}
Nonostante l'hype, WebFlux non è la "pallottola d'argento". Evitalo se:

\begin{enumerate}
    \item \textbf{Il team non è esperto:} Il debug di flussi reattivi è estremamente complesso. Lo stack trace non ti dice "Errore alla riga 10", ma ti mostra una catena di operatori interni di Reactor.
    \item \textbf{Applicazioni CPU Bound:} Se devi fare calcoli pesanti (es. criptare password, processare immagini), bloccherai l'Event Loop. In MVC blocchi un thread su 200, in WebFlux blocchi l'unico thread che gestisce tutti gli utenti!
    \item \textbf{Hai bisogno di JPA/Hibernate:} Se il tuo modello dati è relazionalmente complesso e dipendi dalle magie di Hibernate, R2DBC ti farà soffrire.
\end{enumerate}

\section{Il Game Changer: Java 21 e i Virtual Threads}
Fino al 2023, la scelta era binaria e dolorosa:
\begin{itemize}
    \item Vuoi codice semplice? Usa MVC, ma accetta limiti di scalabilità (Thread OS pesanti).
    \item Vuoi scalabilità estrema? Usa WebFlux, ma accetta un codice complesso e difficile da debuggare.
\end{itemize}

Con l'arrivo di \textbf{Java 21} e dei \textbf{Virtual Threads (Project Loom)}, le regole del gioco sono cambiate. Possiamo dire che, per la maggior parte delle applicazioni Enterprise, \textbf{Spring MVC su Virtual Threads è il vero vincitore}.

\subsection{Cosa sono i Virtual Threads?}
I Thread classici (Platform Threads) sono mappati 1:1 sui thread del Sistema Operativo. Sono costosi: richiedono circa 1MB di RAM ciascuno e il Context Switch è lento.

I \textbf{Virtual Threads} sono entità leggerissime gestite interamente dalla JVM, non dal Sistema Operativo.
\begin{itemize}
    \item \textbf{Costo:} Pochi Kilobyte (vs Megabyte).
    \item \textbf{Quantità:} Puoi crearne milioni (vs migliaia).
    \item \textbf{Funzionamento:} Quando il tuo codice fa una chiamata bloccante al DB (es. \texttt{repo.findById}), la JVM "smonta" il Virtual Thread dalla CPU, lasciando il thread del sistema operativo libero di gestire altre richieste. Quando il DB risponde, il Virtual Thread viene "rimontato" e continua.
\end{itemize}

\subsection{Perché MVC + Virtual Threads vince?}
Questa combinazione ti offre il "Santo Graal" dello sviluppo backend:
\begin{enumerate}
    \item \textbf{Stile Imperativo (Blocking)}: Scrivi codice semplice, sequenziale, facile da leggere (come in MVC classico).
    \item \textbf{Scalabilità Reattiva}: Poiché il blocco è "virtuale" ed economico, puoi gestire centinaia di migliaia di richieste concorrenti senza finire la memoria, esattamente come WebFlux.
\end{enumerate}

\begin{deepdive}{Come attivarli in Spring Boot 3.2+}
Non devi riscrivere il codice. Non devi imparare \texttt{Mono} o \texttt{Flux}. Ti basta una riga nel file \texttt{application.properties}:

\begin{lstlisting}[language=Java]
spring.threads.virtual.enabled=true
\end{lstlisting}

Con questa singola configurazione, Tomcat (embedded) smette di usare il pool di thread standard e inizia a lanciare un nuovo Virtual Thread per \textbf{ogni} singola richiesta HTTP in arrivo.
\end{deepdive}

\section{Verdetto Finale: La nuova guida alla scelta}

Alla luce di Java 21, la matrice decisionale cambia drasticamente.

\begin{center}
\renewcommand{\arraystretch}{1.5}
% CORREZIONE: La prima colonna ha larghezza fissa, l'ultima è X per adattarsi al testo lungo
\begin{tabularx}{\textwidth}{|p{4.5cm}|c|X|}
\hline
\rowcolor{deepblue} \textcolor{white}{\textbf{Scenario}} & \textcolor{white}{\textbf{Soluzione}} & \textcolor{white}{\textbf{Motivazione}} \\ \hline

\textbf{App Enterprise Standard} \newline (CRUD, API Rest, SQL) & 
\textbf{MVC + Virtual Threads} & 
Codice semplice, debug facile, scalabilità altissima senza la complessità reattiva. \\ \hline

\textbf{Streaming Dati / Chat} \newline (WebSocket massivi) & 
\textbf{WebFlux} & 
Il modello a "flusso" e la backpressure rimangono superiori per gestire stream continui. \\ \hline

\textbf{Java Legacy (< 21)} \newline (Versioni vecchie) & 
\textbf{MVC o WebFlux} & 
Senza Virtual Threads, se hai bisogno di alta scalabilità sei costretto a usare WebFlux. \\ \hline

\end{tabularx}
\end{center}

\begin{interview}{Il Reactive (WebFlux) è morto?}
\textbf{Non è morto, ma è diventato di nicchia.}
Prima dei Virtual Threads, si usava il Reactive per due motivi: scalabilità I/O e gestione degli stream.
Oggi, la scalabilità I/O si ottiene "gratis" con i Virtual Threads.
Di conseguenza, WebFlux rimane la scelta migliore \textbf{solo} se hai bisogno di manipolare flussi di dati complessi (Functional Reactive Programming) o se devi gestire backpressure esplicita. Per fare una chiamata al DB e restituire un JSON, MVC con Virtual Threads è oggi la soluzione architetturalmente superiore per rapporto costi/benefici.
\end{interview}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Esempio Pratico: Architettura SpringBoot Avanzata e Annotazioni}

In questo capitolo dissezioniamo un'applicazione Spring Boot reale. Non ci limiteremo a dire "questa annotazione fa X", ma vedremo cosa succede se la omettiamo o la usiamo male.

Il progetto è un \textbf{Payment Gateway Processor}.

\section{1. L'Entry Point e il Component Scan}

Molti sviluppatori mettono la classe main a caso. Questo è il primo errore architetturale.
L'annotazione \texttt{@SpringBootApplication} definisce il "Root Package".

\begin{lstlisting}[language=Java, caption=com.enterprise.pay.PaymentApplication.java]
package com.enterprise.pay; // <--- ROOT PACKAGE

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;

// 1. @SpringBootApplication:
//    Include @ComponentScan. Spring scansionerà SOLO questo package
//    (com.enterprise.pay) e i suoi sotto-package.
//    Se metti un Service in "com.enterprise.utils", Spring NON lo troverà mai
//    e lancerà un errore "NoSuchBeanDefinitionException".

// 2. @ConfigurationPropertiesScan:
//    Invece di usare @EnableConfigurationProperties per ogni singola classe,
//    diciamo a Spring: "Cerca tutte le classi di configurazione in questo package".
//    Rende l'architettura più pulita e scalabile.
@SpringBootApplication
@ConfigurationPropertiesScan 
public class PaymentApplication {

    public static void main(String[] args) {
        SpringApplication.run(PaymentApplication.class, args);
    }
}
\end{lstlisting}

\section{2. Gestione Configurazioni Type-Safe (@ConfigurationProperties)}

Usare \texttt{@Value("\$\{app.timeout\}")} sparso nel codice è un anti-pattern (Typos, refactoring difficile).
L'approccio Enterprise è mappare il file \texttt{application.yml} su classi Java (POJO).

\textbf{File: application.properties}
\begin{verbatim}
payment.gateway.url=https://api.stripe.com
payment.gateway.timeout-ms=5000
payment.gateway.retry-count=3
\end{verbatim}

\textbf{File Java:}

\begin{lstlisting}[language=Java, caption=config/PaymentProperties.java]
package com.enterprise.pay.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.bind.ConstructorBinding;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Positive;

// Mappa tutte le properties che iniziano con "payment.gateway"
// Richiede la validazione dei dati all'avvio (@Validated è implicito se ci sono constraint)
@ConfigurationProperties(prefix = "payment.gateway")
public class PaymentProperties {

    @NotBlank // Se nel properties l'URL manca, l'app CRASHA all'avvio (Fail Fast)
    private final String url;
    
    @Positive
    private final int timeoutMs;
    
    private final int retryCount;

    // @ConstructorBinding: Dice a Spring di usare il costruttore per riempire i campi.
    // Questo ci permette di rendere i campi FINAL (Immutabili).
    @ConstructorBinding
    public PaymentProperties(String url, int timeoutMs, int retryCount) {
        this.url = url;
        this.timeoutMs = timeoutMs;
        this.retryCount = retryCount;
    }

    // Solo Getters (l'oggetto è immutabile)
    public String getUrl() { return url; }
    public int getTimeoutMs() { return timeoutMs; }
    public int getRetryCount() { return retryCount; }
}
\end{lstlisting}

\begin{deepdive}{Perché questa classe è un Bean?}
    Anche se non ha \texttt{@Component}, questa classe diventa un Bean gestito da Spring grazie all'annotazione \texttt{@ConfigurationPropertiesScan} messa nel Main. Ora possiamo iniettare \texttt{PaymentProperties} ovunque serva.
\end{deepdive}

\section{3. Configurazione Esplicita (@Configuration e @Bean)}

A volte dobbiamo configurare classi che \textbf{non abbiamo scritto noi} (es. librerie esterne). Non possiamo aprire il codice di una libreria e scriverci sopra \texttt{@Component}.
Qui entra in gioco \texttt{@Configuration}.

Immaginiamo di dover configurare un \texttt{HttpClient} esterno.

\begin{lstlisting}[language=Java, caption=config/HttpClientConfig.java]
package com.enterprise.pay.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import java.net.http.HttpClient;
import java.time.Duration;

@Configuration // Questa classe è una fabbrica di Bean
public class HttpClientConfig {

    // @Bean: Istruisce Spring su come creare un oggetto che non è nostro.
    // Il nome del metodo ("secureHttpClient") diventa il nome del Bean nel contesto.
    @Bean
    public HttpClient secureHttpClient(PaymentProperties props) {
        // Qui usiamo la configurazione type-safe iniettata da Spring
        return HttpClient.newBuilder()
                .connectTimeout(Duration.ofMillis(props.getTimeoutMs()))
                .version(HttpClient.Version.HTTP_2)
                .build();
    }
}
\end{lstlisting}

\section{4. Logica Condizionale (@ConditionalOnProperty)}

Vogliamo che il sistema supporti due strategie: PayPal e Carta di Credito.
Vogliamo attivare l'una o l'altra cambiando solo una riga nel file properties, senza toccare il codice e senza usare i Profili (che sono troppo generici).

\textbf{Interfaccia:}
\begin{lstlisting}[language=Java]
public interface PaymentStrategy {
    void pay(double amount);
}
\end{lstlisting}

\textbf{Implementazione A (Attivata da flag):}

\begin{lstlisting}[language=Java, caption=strategy/PaypalStrategy.java]
package com.enterprise.pay.strategy;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

@Service
// Questo Bean viene creato SOLO SE in application.properties c'è:
// app.feature.payment-mode=paypal
@ConditionalOnProperty(
    name = "app.feature.payment-mode", 
    havingValue = "paypal"
)
public class PaypalStrategy implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("Pagamento via PayPal: " + amount);
    }
}
\end{lstlisting}

\textbf{Implementazione B (Fallback):}

\begin{lstlisting}[language=Java, caption=strategy/CreditCardStrategy.java]
package com.enterprise.pay.strategy;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

@Service
// matchIfMissing = true -> Se non specifico nulla, uso la Carta di Credito
@ConditionalOnProperty(
    name = "app.feature.payment-mode", 
    havingValue = "credit_card", 
    matchIfMissing = true
)
public class CreditCardStrategy implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println("Pagamento via Carta di Credito: " + amount);
    }
}
\end{lstlisting}

\section{5. Cablaggio Finale (Injection)}

Ora mettiamo tutto insieme nel Service. Notare come Spring risolve le dipendenze in modo intelligente.

\begin{lstlisting}[language=Java, caption=service/PaymentService.java]
package com.enterprise.pay.service;

import com.enterprise.pay.config.PaymentProperties;
import com.enterprise.pay.strategy.PaymentStrategy;
import org.springframework.stereotype.Service;
import java.net.http.HttpClient;

@Service
public class PaymentService {

    private final PaymentStrategy strategy;
    private final PaymentProperties properties;
    private final HttpClient httpClient;

    // COSTRUCTOR INJECTION
    // Spring fa questo ragionamento:
    // 1. strategy: Cerca il bean attivo. Grazie a @ConditionalOnProperty ce ne sarà SOLO UNO.
    //    Se ce ne fossero due, l'app non partirebbe (NoUniqueBeanDefinitionException).
    // 2. properties: Inietta il POJO configurato e validato.
    // 3. httpClient: Inietta il bean creato manualmente in HttpClientConfig.
    public PaymentService(PaymentStrategy strategy, 
                          PaymentProperties properties, 
                          HttpClient httpClient) {
        this.strategy = strategy;
        this.properties = properties;
        this.httpClient = httpClient;
    }

    public void process(double amount) {
        System.out.println("Using Gateway: " + properties.getUrl());
        // Polimorfismo: non so se è Paypal o Carta, e non mi interessa.
        strategy.pay(amount);
    }
}
\end{lstlisting}

\section{Riepilogo del Flusso}

Se lanci l'applicazione con questo \texttt{application.properties}:
\begin{verbatim}
payment.gateway.url=https://api.paypal.com
payment.gateway.timeout-ms=2000
app.feature.payment-mode=paypal
\end{verbatim}

Accade questo:
\begin{enumerate}
    \item \textbf{Start:} \texttt{@SpringBootApplication} scansiona il package.
    \item \textbf{Config Scan:} \texttt{@ConfigurationPropertiesScan} trova \texttt{PaymentProperties}. Legge i valori, valida che l'URL non sia vuoto e crea il Bean.
    \item \textbf{Bean Factory:} Spring legge \texttt{HttpClientConfig}. Chiama il metodo \texttt{secureHttpClient()}, passandogli le properties appena create, e registra il risultato (\texttt{HttpClient}) come Bean.
    \item \textbf{Condition Check:} 
    \begin{itemize}
        \item Controlla \texttt{PaypalStrategy}: la property è "paypal"? SÌ. Bean creato.
        \item Controlla \texttt{CreditCardStrategy}: la property è "credit\_card"? NO. Bean scartato (non occupa memoria).
    \end{itemize}
    \item \textbf{Injection:} Spring crea \texttt{PaymentService} iniettando \texttt{PaypalStrategy}.
\end{enumerate}

Ecco come le annotazioni lavorano insieme per creare un'architettura modulare e robusta.


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Spring Cache, H2 \& Redis: Ottimizzazione Performance}

In un'applicazione enterprise, il collo di bottiglia è quasi sempre il Database o la Rete.
Recuperare un dato dalla RAM richiede nanosecondi. Recuperarlo dal DB (su disco o via rete) richiede millisecondi. C'è un fattore di differenza di $100.000x$.

Il \textbf{Caching} è l'arte di memorizzare risultati costosi in una memoria temporanea veloce per riutilizzarli.

\section{Spring Cache Abstraction}
Spring non implementa una cache. Fornisce un'\textbf{astrazione}.
Funziona esattamente come JDBC (che astrae i driver DB) o Slf4j (che astrae i log).

Tu usi le annotazioni standard (\texttt{@Cacheable}), e "sotto il cofano" puoi cambiare il motore di cache (HashMap, Redis, Caffeine, EhCache) cambiando solo una riga nel file di configurazione.

\subsection{Le Annotazioni Magiche}
Per attivare il sistema, devi aggiungere \texttt{@EnableCaching} su una classe di configurazione o sulla Main class.

Ecco le tre annotazioni che devi conoscere:

\subsubsection{1. @Cacheable (Lettura - Look-aside Pattern)}
È la più usata. Intercetta la chiamata al metodo.
\begin{itemize}
    \item \textbf{Prima di eseguire il metodo:} Spring controlla se nella cache esiste già un valore per quella chiave.
    \item \textbf{Se esiste (Cache Hit):} Restituisce il valore immediato. Il metodo NON viene eseguito (risparmiando la query al DB).
    \item \textbf{Se non esiste (Cache Miss):} Esegue il metodo reale, salva il risultato in cache e lo restituisce.
\end{itemize}

\begin{lstlisting}[language=Java]
@Service
public class ProductService {

    // Cache Name: "prodotti"
    // Key: generata automaticamente basandosi sui parametri (es. id)
    @Cacheable(value = "prodotti", key = "#id")
    public ProductDTO getProductById(Long id) {
        // Simuliamo operazione lenta (DB call)
        simulateSlowService(); 
        return repository.findById(id).map(mapper::toDto).orElse(null);
    }
}
\end{lstlisting}

\subsubsection{2. @CacheEvict (Pulizia)}
Le cache devono essere invalidare quando i dati cambiano, altrimenti l'utente vedrà dati vecchi (\textit{Stale Data}).
\texttt{@CacheEvict} rimuove elementi dalla cache.

\begin{lstlisting}[language=Java]
    // Quando aggiorno un prodotto, DEVO cancellarlo dalla cache
    // altrimenti le prossime getProductById ritorneranno il vecchio oggetto!
    @CacheEvict(value = "prodotti", key = "#dto.id")
    public ProductDTO updateProduct(ProductDTO dto) {
        return repository.save(mapper.toEntity(dto));
    }

    // Svuota INTERA cache (es. dopo un import massivo notturno)
    @CacheEvict(value = "prodotti", allEntries = true)
    public void clearCache() { ... }
\end{lstlisting}

\subsubsection{3. @CachePut (Aggiornamento)}
Meno usata. Esegue \textit{sempre} il metodo e aggiorna la cache con il nuovo risultato. Utile se vuoi evitare il "buco" temporaneo causato da una Evict.

\section{H2 Database: In-Memory Relational DB}
Spesso confuso con una cache, \textbf{H2} è un vero RDBMS SQL, ma risiede interamente nella RAM (o su file locale).

\subsection{Quando usarlo?}
\begin{itemize}
    \item \textbf{Test:} Per i test di integrazione (`@DataJpaTest`) è perfetto perché parte in millisecondi e si pulisce ad ogni riavvio.
    \item \textbf{Sviluppo Locale:} Evita di dover installare Postgres/MySQL sul laptop per fare due prove.
\end{itemize}

\subsection{Configurazione e Console}
Spring Boot autoconfigura H2 se trova la dipendenza.

\begin{lstlisting}[language=Java, title={application.properties}]
# Abilita la console web su /h2-console
spring.h2.console.enabled=true
# URL per connettersi (mem = in memoria, perde dati al riavvio)
spring.datasource.url=jdbc:h2:mem:testdb
\end{lstlisting}

\begin{deepdive}{H2 vs Cache}
Perché usare \texttt{@Cacheable} se uso già H2 (che è in RAM)?
Anche se H2 è veloce, è comunque un database SQL. Ogni query richiede parsing dell'SQL, ottimizzazione del piano di esecuzione e trasformazione dei ResultSet.
Una Cache (come Redis o HashMap) è un accesso Key-Value diretto ($O(1)$). È ordini di grandezza più veloce di una query SQL su H2.
\end{deepdive}

\section{Redis: The Production Cache}
In produzione (Kubernetes, Microservizi), non puoi usare la cache in memoria semplice (HashMap).
Se hai 10 istanze del tuo backend, e l'istanza A mette in cache un dato, l'istanza B non lo sa.
Serve una \textbf{Cache Distribuita}.

\textbf{Redis} (Remote Dictionary Server) è lo standard industriale. È un "Data Structure Store" in-memory.

\subsection{Perché Redis?}
\begin{enumerate}
    \item \textbf{Centralizzato:} Tutte le istanze dei microservizi leggono/scrivono dallo stesso Redis.
    \item \textbf{TTL (Time To Live):} Puoi dire "tieni questo dato solo per 10 minuti". Fondamentale per non riempire la RAM.
    \item \textbf{Persistenza:} A differenza di Memcached, Redis può salvare su disco, quindi se il server si riavvia, la cache calda non è persa (opzionale).
\end{enumerate}

\subsection{Integrazione Spring Boot + Redis}
Basta aggiungere \texttt{spring-boot-starter-data-redis}. Spring rileva Redis e configura automaticamente il \texttt{CacheManager} per usare Redis invece della HashMap.

\begin{lstlisting}[language=Java, title={application.properties}]
spring.cache.type=redis
spring.data.redis.host=localhost
spring.data.redis.port=6379
# Default TTL (es. 60000ms = 1 minuto)
spring.cache.redis.time-to-live=60000
\end{lstlisting}

\subsection{Serializzazione: Il problema dei binari}
Di default, Spring usa la serializzazione Java nativa (ObjectInputStream), che produce blob binari illeggibili in Redis e fragili.
Un Senior Developer configura sempre un \textbf{Serializer JSON}.

\begin{lstlisting}[language=Java, title={Configurazione Redis Template}]
@Bean
public RedisCacheConfiguration cacheConfiguration() {
    return RedisCacheConfiguration.defaultCacheConfig()
        .entryTtl(Duration.ofMinutes(10)) // TTL Globale
        .disableCachingNullValues()
        // Usa JSON leggibile invece di binario Java
        .serializeValuesWith(SerializationPair.fromSerializer(
            new GenericJackson2JsonRedisSerializer()
        ));
}
\end{lstlisting}

\section{Interview Questions \& Best Practices}

\begin{interview}{Cache Consistency Problem}
\textbf{Domanda:} Qual è il rischio maggiore nell'usare la Cache?

\textbf{Risposta:} L'inconsistenza dei dati (\textbf{Stale Data}).
Se modifichi un dato sul DB (es. cambi il prezzo di un prodotto) ma dimentichi di chiamare \texttt{@CacheEvict}, la cache continuerà a servire il prezzo vecchio finché non scade il TTL.
\textbf{Regola d'oro:} Ci sono solo due cose difficili in informatica: invalidare la cache e dare i nomi alle cose.
\end{interview}

\begin{interview}{The Thundering Herd Problem}
\textbf{Domanda:} Cosa succede se il TTL di un dato molto richiesto scade improvvisamente?

\textbf{Risposta:}
Migliaia di richieste arrivano contemporaneamente. Trovano la cache vuota (Miss).
Tutte e mille partono verso il Database simultaneamente per ricalcolare lo stesso dato. Il DB crolla per il picco di carico.
\textbf{Soluzioni:}
\begin{itemize}
    \item \textbf{Soft TTL:} Rinfrescare la cache in background prima che scada davvero.
    \item \textbf{Locking:} Solo il primo thread va al DB, gli altri aspettano.
\end{itemize}
\end{interview}

\section{Riepilogo Strategie}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Tecnologia}} & \textcolor{white}{\textbf{Ruolo}} \\
    \hline
    \textbf{Spring Cache} & L'interfaccia. Usi \texttt{@Cacheable} per non sporcare il codice con logica di infrastruttura. \\
    \hline
    \textbf{ConcurrentMap} & Cache di default (dev). Veloce ma locale (non condivisa tra istanze). \\
    \hline
    \textbf{H2} & Database SQL in-memory. Utile per test, non è propriamente una cache layer. \\
    \hline
    \textbf{Redis} & Cache distribuita di produzione. Supporta TTL, eviction policies e condivisione dati tra microservizi. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Spring Security}

\section{Concetti Fondamentali}

Spring Security è il framework standard \textit{de-facto} per la sicurezza delle applicazioni Java. È potente, altamente personalizzabile, ma noto per avere una curva di apprendimento ripida.
Non si limita al semplice login: gestisce la protezione contro attacchi comuni (CSRF, Session Fixation), la crittografia delle password e la gestione granulare degli accessi.

\subsection{Autenticazione vs Autorizzazione}
Questi due termini vengono spesso confusi, ma rappresentano due fasi distinte e sequenziali.

\begin{itemize}
    \item \textbf{Authentication (Autenticazione) - "Chi sei?"}\\
    È il processo di verifica dell'identità di un utente.
    \textit{Esempio:} Inserire username e password, fornire l'impronta digitale o inviare un token JWT. Se il sistema riconosce le credenziali, l'utente è \textit{autenticato}.
    
    \item \textbf{Authorization (Autorizzazione) - "Cosa puoi fare?"}\\
    È il processo di verifica dei permessi di un utente già autenticato.
    \textit{Esempio:} Un utente loggato può leggere i dati, ma solo un "Admin" può cancellarli. Se l'utente ha il ruolo giusto, è \textit{autorizzato}.
\end{itemize}

\subsection{Il Glossario Essenziale}
Per capire il codice di Spring Security, bisogna conoscere i nomi degli oggetti chiave che circolano nel framework.

\begin{enumerate}
    \item \textbf{Principal:} Rappresenta l'utente corrente (o il servizio/dispositivo). Solitamente è lo \textit{username} o l'oggetto \texttt{User} completo.
    \item \textbf{Credentials:} La prova dell'identità. Solitamente la \textit{password} (prima di essere verificata) o il token. Vengono spesso cancellate dalla memoria subito dopo l'autenticazione per sicurezza.
    \item \textbf{Authorities (GrantedAuthority):} I permessi assegnati all'utente. Possono essere ruoli ("ROLE\_ADMIN") o permessi fini ("READ\_PRIVILEGE").
\end{enumerate}

\begin{deepdive}{Il prefisso "ROLE\_"}
    In Spring Security, c'è una differenza tecnica sottile tra \textbf{Role} e \textbf{Authority}.
    Per convenzione, i ruoli hanno il prefisso \texttt{ROLE\_} (es. \texttt{ROLE\_USER}).
    Quando nel codice usi \texttt{.hasRole("USER")}, Spring cerca automaticamente \texttt{ROLE\_USER} nel database. Se usi \texttt{.hasAuthority("USER")}, cercherà esattamente la stringa "USER".
    È una trappola comune in cui cadono molti junior.
\end{deepdive}

\subsection{Stateful vs Stateless}
La scelta architetturale più importante quando si configura la sicurezza riguarda la gestione della sessione.

\begin{interview}{Autenticazione Stateful (Session) vs Stateless (Token)}
    \textbf{Domanda:} "Stiamo costruendo un backend per un'App Mobile e una Single Page Application (React). Che strategia di sicurezza usiamo?"
    
    \textbf{Risposta:} Dobbiamo usare un approccio \textbf{Stateless} (tipicamente JWT).
    
    \begin{itemize}
        \item \textbf{Stateful (Classico/Monolite):} Il server crea un oggetto \texttt{HttpSession} in memoria e invia al client un cookie \texttt{JSESSIONID}.
        \begin{itemize}
            \item \textit{Pro:} Facile da implementare, invalidazione sessione immediata.
            \item \textit{Contro:} Non scala bene orizzontalmente (serve sticky session o session replication tra server), non ideale per App Mobile.
        \end{itemize}
        
        \item \textbf{Stateless (REST/Microservizi):} Il server non salva nulla in memoria dopo la risposta. Invia un \textbf{Token} (es. JWT) firmato al client. Il client deve inviare il token ad ogni richiesta successiva.
        \begin{itemize}
            \item \textit{Pro:} Scalabilità infinita (qualsiasi server può validare il token), standard per Mobile/Frontend moderni.
            \item \textit{Contro:} Difficile revocare un token prima della scadenza (necessità di Blacklist o tempi brevi).
        \end{itemize}
    \end{itemize}
\end{interview}


\section{Architettura Interna (Dietro le quinte)}

Per capire come risolvere i problemi di sicurezza (es. CORS errors, 403 Forbidden inaspettati), bisogna comprendere il flusso della richiesta HTTP.
Spring Security non è magico: è basato interamente sullo standard dei \textbf{Servlet Filters}.

\subsection{La Security Filter Chain}
Prima che una richiesta HTTP raggiunga il tuo \texttt{DispatcherServlet} (e quindi i tuoi \texttt{@RestController}), deve attraversare una serie di filtri di sicurezza. Se uno di questi filtri rifiuta la richiesta (lancia un'eccezione o restituisce un errore 401/403), il tuo Controller non verrà mai eseguito.

Ecco una visualizzazione del flusso:

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm,
    auto,
    block/.style={rectangle, draw=deepblue, fill=white, text width=2.5cm, align=center, rounded corners, minimum height=1cm, line width=1pt},
    filter/.style={rectangle, draw=javared, fill=javared!10, text width=2.2cm, align=center, minimum height=1cm, line width=1pt},
    cloud/.style={draw, ellipse, fill=codebg, node distance=2cm, minimum height=1cm}
]

    % Nodes
    \node[cloud] (client) {\textbf{Client}};
    \node[filter, right=1.5cm of client] (f1) {JWT Filter\\(Custom)};
    \node[filter, right=0.5cm of f1] (f2) {Username/Pass\\Filter};
    \node[filter, right=0.5cm of f2] (f3) {AuthZ Filter\\(FilterSecurity)};
    \node[block, right=1.5cm of f3] (servlet) {\textbf{Dispatcher}\\Servlet};
    \node[block, below=1cm of servlet] (controller) {\textbf{Rest}\\Controller};

    % Arrows
    \draw[->, thick, deepblue] (client) -- node[above] {HTTP Req} (f1);
    \draw[->, thick, deepblue] (f1) -- (f2);
    \draw[->, thick, deepblue] (f2) -- (f3);
    \draw[->, thick, javagreen] (f3) -- node[above] {OK} (servlet);
    \draw[->, thick, javagreen] (servlet) -- (controller);
    
    % Error Path
    \draw[->, dashed, thick, red] (f2.south) -- ++(0,-0.5) -| node[pos=0.2, below] {401 Error} (client.south);

\end{tikzpicture}
\end{center}

I componenti chiave sono:
\begin{enumerate}
    \item \textbf{DelegatingFilterProxy:} È il ponte tra il container Servlet (Tomcat) e il contesto di Spring. Intercetta le richieste e le passa ai bean di Spring.
    \item \textbf{FilterChainProxy:} Gestisce la lista dei filtri di sicurezza.
    \item \textbf{SecurityFilterChain:} La catena effettiva dei filtri che corrispondono alla richiesta. L'ordine è vitale (es. controlli il token JWT \textit{prima} di controllare se l'utente è un Admin).
\end{enumerate}

\subsection{SecurityContextHolder e ThreadLocal}
Una volta che un utente è autenticato con successo (es. password corretta o token valido), dove vengono salvati i suoi dati?
Spring Security usa il \texttt{SecurityContextHolder}.

\begin{deepdive}{Deep Dive: ThreadLocal}
    Il \texttt{SecurityContextHolder}, di default, usa una strategia \textbf{ThreadLocal}.
    
    \textbf{Cosa significa?}
    In un'applicazione Web Java, ogni richiesta HTTP viene gestita da un singolo thread dedicato (dal pool di thread di Tomcat).
    Il \texttt{ThreadLocal} è come una "variabile globale", ma visibile \textbf{solo} all'interno di quel specifico thread.
    
    \textbf{Vantaggio:} Non devi passare l'oggetto \texttt{User} come parametro in ogni metodo del Service o del Repository. Puoi recuperarlo staticamente ovunque, perché Spring sa che quel thread appartiene a quell'utente.
    
    \textbf{Attenzione con @Async:} Se lanci un metodo \texttt{@Async} (nuovo thread), il contesto di sicurezza viene perso (l'utente risulta null), a meno che non configuri la strategia \texttt{MODE\_INHERITABLETHREADLOCAL}.
\end{deepdive}

\subsection{Come recuperare l'utente loggato}
Grazie al meccanismo sopra descritto, ecco come accedere ai dati dell'utente corrente in qualsiasi punto del codice (Service, Utility, ecc.):

\begin{lstlisting}[language=Java, caption=Recuperare il Principal corrente]
public String getCurrentUsername() {
    // 1. Accedi al contesto statico
    SecurityContext context = SecurityContextHolder.getContext();
    
    // 2. Recupera l'Authentication (se esiste)
    Authentication authentication = context.getAuthentication();
    
    // 3. Verifica se è autenticato e non è un utente anonimo
    if (authentication != null && authentication.isAuthenticated() 
        && !(authentication instanceof AnonymousAuthenticationToken)) {
        
        // Il Principal è solitamente lo username o un oggetto UserDetails
        return authentication.getName(); 
    }
    
    return null;
}
\end{lstlisting}

\begin{interview}{Filtri Custom: Dove posizionarli?}
    \textbf{Domanda:} "Ho creato un filtro per validare un Token JWT proprietario. Dove lo inserisco nella catena?"
    
    \textbf{Risposta:} Va inserito \textbf{prima} del filtro di autenticazione username/password standard.
    
    In Spring Boot 3 si usa il metodo \texttt{addFilterBefore}:
    \begin{small}
    \begin{verbatim}
    http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
    \end{verbatim}
    \end{small}
    Se lo mettessi dopo, Spring potrebbe aver già bloccato l'utente perché "non autenticato", rendendo inutile il tuo controllo del token.
\end{interview}

\section{Configurazione Moderna (Spring Boot 3)}

La versione 5.7 di Spring Security (inclusa in Spring Boot 3) ha segnato un punto di svolta epocale, introducendo cambiamenti che rompono la retrocompatibilità.
Se provi a copiare un tutorial del 2021, il codice non compilerà.

\subsection{Addio WebSecurityConfigurerAdapter}
Fino a poco tempo fa, la prassi era estendere la classe \texttt{WebSecurityConfigurerAdapter} e fare override del metodo \texttt{configure(HttpSecurity http)}.
Questa classe è stata \textbf{rimossa}.

L'approccio moderno è \textbf{basato sui componenti (Component-based)}: invece di estendere una classe e sovrascrivere metodi, si definisce un \textbf{@Bean} di tipo \texttt{SecurityFilterChain}.

\begin{interview}{Perché hanno rimosso l'Adapter?}
    \textbf{Domanda:} "Perché Spring ha complicato le cose rimuovendo una classe che funzionava bene?"
    
    \textbf{Risposta:} In realtà, l'hanno semplificata.
    L'ereditarietà (\texttt{extends}) creava un forte accoppiamento con il framework e nascondeva cosa succedeva "dietro le quinte" (es. quale \texttt{AuthenticationManager} veniva esposto).
    L'approccio a \textbf{Bean} è più trasparente, favorisce la Dependency Injection e permette di avere multiple catene di sicurezza (es. una per le API /api/** e una per la parte Web /admin/**) semplicemente definendo più Bean.
\end{interview}

\subsection{La sintassi Lambda DSL}
Oltre al cambio di struttura, è cambiata la sintassi interna. Il vecchio stile "concatenato" con i metodi \texttt{.and()} è deprecato e sostituito dalle espressioni Lambda.
Questo rende la configurazione più leggibile perché l'indentazione riflette la gerarchia delle impostazioni.

\begin{itemize}
    \item \textbf{Vecchio Stile:} \texttt{http.csrf().disable().authorizeRequests()...}
    \item \textbf{Nuovo Stile:} \texttt{http.csrf(csrf -> csrf.disable())...}
\end{itemize}

\subsection{Codice: Configurazione API REST Standard}
Ecco il template "Gold Standard" per un backend REST in Spring Boot 3.

\begin{lstlisting}[language=Java, caption=SecurityFilterChain per API REST]
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 1. Disabilita CSRF (non serve per API Stateless gestite da token)
            .csrf(csrf -> csrf.disable())
            
            // 2. Configura la sessione come STATELESS
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            
            // 3. Gestione Autorizzazioni (URL Matching)
            .authorizeHttpRequests(auth -> auth
                // Endpoint pubblici (Login, Registrazione)
                .requestMatchers("/api/auth/**").permitAll()
                // Endpoint Swagger/OpenAPI (opzionale)
                .requestMatchers("/v3/api-docs/**", "/swagger-ui/**").permitAll()
                // Endpoint Admin
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                // Tutto il resto richiede autenticazione
                .anyRequest().authenticated()
            );
            
            // Nota: Qui andrebbe aggiunto il filtro JWT (lo vedremo dopo)
            // .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
\end{lstlisting}

\begin{deepdive}{authorizeRequests vs authorizeHttpRequests}
    Un altro "gotcha" della migrazione:
    \begin{itemize}
        \item \texttt{authorizeRequests()}: È il vecchio metodo. Funziona ancora ma è deprecato.
        \item \texttt{authorizeHttpRequests()}: È il nuovo metodo introdotto in Spring Security 5.5+.
    \end{itemize}
    
    \textbf{Differenza tecnica:} Il nuovo metodo usa l'\texttt{AuthorizationManager} API (più efficiente e flessibile) invece del vecchio sistema basato su metadati e votatori. Quando scrivi nuovo codice, usa sempre \texttt{authorizeHttpRequests}.
\end{deepdive}

\subsection{Gestione CORS (Cross-Origin Resource Sharing)}
Se il tuo Frontend (es. Angular su localhost:4200) chiama il Backend (localhost:8080), il browser bloccherà la richiesta se non configuri il CORS.
In Spring Security, il CORS deve essere abilitato esplicitamente nella catena.

\begin{lstlisting}[language=Java, caption=Abilitare CORS]
http.cors(cors -> cors.configurationSource(request -> {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(List.of("http://localhost:4200"));
    config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE"));
    config.setAllowedHeaders(List.of("*"));
    return config;
}));
\end{lstlisting}

\section{Gestione Utenti e Password}

Configurare i filtri serve a poco se il sistema non sa dove andare a pescare gli utenti per verificare le credenziali.
Spring Security disaccoppia la logica di autenticazione dalla fonte dei dati tramite due interfacce chiave: \texttt{UserDetailsService} e \texttt{PasswordEncoder}.

\subsection{UserDetailsService: Il ponte col Database}
Questa interfaccia ha un unico metodo: \texttt{loadUserByUsername(String username)}.
Il suo compito è accettare uno username (o email), cercare nel database (o LDAP, o memoria) e restituire un oggetto \texttt{UserDetails}.

\begin{lstlisting}[language=Java, caption=Implementazione Custom UserDetailsService]
@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        // 1. Cerca l'utente nel DB (Entity JPA)
        com.example.entity.User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new UsernameNotFoundException("Utente non trovato"));

        // 2. Converti l'Entity nel formato UserDetails di Spring
        return org.springframework.security.core.userdetails.User.builder()
            .username(user.getEmail())
            .password(user.getPassword()) // Password GIA' hashata nel DB
            .roles(user.getRole().name()) // Es. "ADMIN" -> diventa ROLE_ADMIN
            .build();
    }
}
\end{lstlisting}

\subsection{Memorizzazione Password: Hashing vs Encryption}
Questo è un argomento teorico imprescindibile. Mai salvare password in chiaro, e mai usare algoritmi reversibili.

\begin{interview}{Differenza tra Hashing e Cifratura (Encryption)}
    \textbf{Domanda:} "Per proteggere la password nel DB, la cifri o ne fai l'hash?"
    
    \textbf{Risposta:} Ne faccio l'\textbf{Hash}.
    
    \begin{itemize}
        \item \textbf{Cifratura (Encryption):} È bidirezionale (Reversibile). Se ho la chiave segreta, posso decifrare il dato e ottenere la password originale. Questo è pericoloso: se un hacker ruba la chiave e il DB, ha tutte le password.
        \item \textbf{Hashing (es. BCrypt, SHA-256):} È monodirezionale (Irreversibile). È matematicamente impossibile risalire alla password originale partendo dall'hash. Per verificare il login, si fa l'hash dell'input utente e lo si confronta con quello nel DB.
    \end{itemize}
\end{interview}

\subsection{PasswordEncoder e BCrypt}
Spring Security raccomanda l'uso di \texttt{BCryptPasswordEncoder}.

\begin{deepdive}{Perché BCrypt e cos'è il "Salting"?}
    Se usi MD5 o SHA-256 semplice, due utenti con la password "ciro123" avranno lo stesso hash nel DB. Questo li rende vulnerabili alle \textit{Rainbow Tables} (tabelle precalcolate di hash).
    
    \textbf{BCrypt} risolve il problema usando il \textbf{Salting} automatico:
    \begin{enumerate}
        \item Genera una stringa casuale (il "salt").
        \item Unisce il salt alla password e fa l'hash.
        \item Il risultato finale contiene sia l'hash che il salt in chiaro.
    \end{enumerate}
    
    \textbf{Risultato:} Ogni volta che fai l'hash di "ciro123", ottieni una stringa diversa!
    \texttt{\$2a\$10\$...stringa\_diversa\_ogni\_volta...}
    Spring Security sa come estrarre il salt dalla stringa salvata per verificare la password durante il login.
\end{deepdive}

\subsection{Configurazione Finale}
Per attivare tutto questo, dobbiamo definire i Bean nella classe di configurazione.

\begin{lstlisting}[language=Java, caption=Bean AuthProvider e PasswordEncoder]
@Configuration
public class SecurityConfig {

    // 1. Definiamo l'algoritmo di hashing
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // 2. Configuriamo l'AuthenticationProvider (Collega Service e Encoder)
    @Bean
    public AuthenticationProvider authenticationProvider(UserDetailsService userDetailsService) {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
    
    // 3. Esponiamo l'AuthenticationManager (utile per il login JWT)
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) 
            throws Exception {
        return config.getAuthenticationManager();
    }
}
\end{lstlisting}

\section{Sicurezza per API REST (JWT)}

Nelle architetture moderne a microservizi o Single Page Application (SPA), l'uso delle sessioni server-side (Cookie JSESSIONID) è sconsigliato. Si preferisce un approccio basato su \textbf{Token}.
Lo standard di mercato è il \textbf{JSON Web Token (JWT)}.

\subsection{Anatomia di un JWT}
Un token JWT è una stringa composta da tre parti separate da un punto (\texttt{.}), codificate in Base64Url:
\texttt{aaaaaa.bbbbbb.cccccc}

\begin{enumerate}
    \item \textbf{Header:} Contiene il tipo di token (JWT) e l'algoritmo di firma usato (es. HS256).
    \item \textbf{Payload (Claims):} Contiene i dati utili (es. user ID, email, data di scadenza, ruoli).
    \item \textbf{Signature:} È la firma digitale creata combinando Header, Payload e una \textbf{Chiave Segreta} posseduta solo dal server. Garantisce che il token non sia stato manomesso.
\end{enumerate}

\begin{interview}{Posso mettere la password nel JWT?}
    \textbf{Domanda:} "Il payload del JWT è cifrato? Posso metterci dati sensibili come la password?"
    
    \textbf{Risposta:} \textbf{ASSOLUTAMENTE NO}.
    Il payload è solo \textbf{codificato} in Base64, non cifrato. Chiunque intercetti il token può decodificarlo e leggere il contenuto (es. usando il sito \textit{jwt.io}).
    La sicurezza del JWT sta nella \textbf{Firma}: se un hacker modifica il payload (es. cambia ruolo da "USER" a "ADMIN"), la firma non corrisponderà più e il server rifiuterà il token.
\end{interview}

\subsection{Il Flusso di Autenticazione (Stateless)}
\begin{enumerate}
    \item Il client invia una POST \texttt{/login} con username e password.
    \item Il server verifica le credenziali. Se corrette, \textbf{genera} un JWT firmato con la sua chiave privata.
    \item Il server restituisce il JWT al client.
    \item Per ogni richiesta successiva, il client invia il JWT nell'header HTTP:
    \texttt{Authorization: Bearer <token>}
    \item Un filtro custom nel server intercetta la richiesta, valida la firma del token e autentica l'utente nel contesto.
\end{enumerate}

\subsection{Il Filtro Custom: JwtAuthenticationFilter}
Questo è il componente critico che va scritto manualmente. Estende \texttt{OncePerRequestFilter} per garantire un'esecuzione unica per richiesta.

\begin{lstlisting}[language=Java, caption=JwtAuthenticationFilter]
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService; // Classe utility per parsing token
    private final UserDetailsService userDetailsService;

    // Costruttore omesso per brevità (Lombok @RequiredArgsConstructor)

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String userEmail;

        // 1. Controlla se l'header esiste e inizia con "Bearer "
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        // 2. Estrai il token
        jwt = authHeader.substring(7);
        userEmail = jwtService.extractUsername(jwt); // Metodo utility

        // 3. Se abbiamo l'email e l'utente NON è ancora autenticato nel contesto
        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            
            // Carica i dettagli utente dal DB
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);

            // 4. Valida il token (firma e scadenza)
            if (jwtService.isTokenValid(jwt, userDetails)) {
                
                // 5. Crea l'oggetto Authentication
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null, // Non servono credenziali
                        userDetails.getAuthorities()
                );
                
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                // 6. INSERISCI L'UTENTE NEL CONTESTO DI SICUREZZA
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        
        // 7. Passa la palla al prossimo filtro
        filterChain.doFilter(request, response);
    }
}
\end{lstlisting}

\begin{deepdive}{Perché controllare se il Context è null?}
    La riga \texttt{SecurityContextHolder.getContext().getAuthentication() == null} è fondamentale per le performance.
    Se l'utente è già stato autenticato in questa richiesta (caso raro, ma possibile in catene complesse o forward), non vogliamo rieseguire query al database o calcoli crittografici pesanti.
\end{deepdive}

\subsection{Access Token vs Refresh Token}
Nei sistemi enterprise, i token non durano per sempre.

\begin{itemize}
    \item \textbf{Access Token:} Dura poco (es. 15 minuti). Se viene rubato, il danno è limitato nel tempo.
    \item \textbf{Refresh Token:} Dura molto (es. 7 giorni). Serve per ottenere un nuovo Access Token senza chiedere di nuovo la password all'utente. Viene conservato in modo più sicuro (es. Cookie HttpOnly) e può essere revocato dal database (Blacklisting).
\end{itemize}

\section{Gestione delle Autorizzazioni (RBAC)}

Una volta che l'utente è autenticato (sappiamo chi è) e abbiamo caricato i suoi ruoli (UserDetailsService), dobbiamo decidere cosa può fare.
Spring Security offre due livelli di protezione:
\begin{enumerate}
    \item \textbf{Request Level (URL):} Definita nella \texttt{SecurityFilterChain} (es. \texttt{.requestMatchers("/admin/**")}). È la prima barriera.
    \item \textbf{Method Level (AOP):} Definita tramite annotazioni direttamente sui metodi dei Service o dei Controller. È più granulare e preferibile in architetture complesse.
\end{enumerate}

\subsection{Abilitare la Method Security}
In Spring Boot 3 (Security 6), la vecchia annotazione \texttt{@EnableGlobalMethodSecurity} è deprecata.
La nuova annotazione da usare sulla classe di configurazione è \texttt{@EnableMethodSecurity}.

\begin{lstlisting}[language=Java, caption=Abilitare le annotazioni di sicurezza]
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true) // Abilita @PreAuthorize e @PostAuthorize
public class SecurityConfig {
    // ... configurazione dei bean
}
\end{lstlisting}

\subsection{Le Annotazioni Principali}

\subsubsection{@PreAuthorize}
È l'annotazione più potente e usata. Supporta il linguaggio \textbf{SpEL} (Spring Expression Language), permettendo di scrivere logica condizionale complessa. Viene valutata \textit{prima} dell'esecuzione del metodo.

\begin{lstlisting}[language=Java, caption=Esempi di @PreAuthorize]
@Service
public class DocumentService {

    // Caso 1: Controllo di Ruolo semplice
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteDocument(Long id) {
        // ...
    }

    // Caso 2: Logica complessa (AND/OR)
    @PreAuthorize("hasRole('MANAGER') or hasRole('ADMIN')")
    public void approveDocument(Long id) {
        // ...
    }
    
    // Caso 3: Controllo di Ownership (Il dato appartiene all'utente?)
    // #username è il nome del parametro del metodo
    // authentication.name è l'utente loggato nel SecurityContext
    @PreAuthorize("#username == authentication.name")
    public void changePassword(String username, String newPassword) {
        // ...
    }
}
\end{lstlisting}

\begin{deepdive}{@Secured vs @PreAuthorize}
    Spesso si trova codice legacy con \texttt{@Secured("ROLE\_ADMIN")}.
    
    \textbf{Differenza:} \texttt{@Secured} è un'annotazione vecchia (stile Java 5), non supporta SpEL (niente \texttt{OR}, \texttt{AND}, niente accesso ai parametri).
    \textbf{Consiglio:} Usa sempre \texttt{@PreAuthorize}. È lo standard moderno.
\end{deepdive}

\subsection{Post Authorization}
A volte non basta controllare prima. Immagina un metodo che cerca un documento nel DB: non sai di chi è il documento finché non lo carichi.
\texttt{@PostAuthorize} permette di eseguire il metodo, e poi decidere se l'utente può vedere il risultato o se lanciare un'eccezione (AccessDeniedException).

\begin{lstlisting}[language=Java, caption=Esempio @PostAuthorize]
// returnObject è l'oggetto restituito dal metodo
@PostAuthorize("returnObject.owner == authentication.name")
public Document getDocument(Long id) {
    return documentRepository.findById(id);
}
\end{lstlisting}

\subsection{La trappola del prefisso "ROLE\_"}
Torniamo su questo punto perché è la causa numero 1 di bug "Access Denied" inspiegabili.

\begin{interview}{hasRole() vs hasAuthority()}
    \textbf{Domanda:} "Nel DB ho salvato il ruolo \texttt{ADMIN}. Nel codice uso \texttt{.hasRole('ADMIN')}, ma non funziona. Perché?"
    
    \textbf{Risposta:} Spring Security, quando usi \texttt{hasRole('XYZ')}, aggiunge automaticamente il prefisso \texttt{ROLE\_} e cerca \texttt{ROLE\_XYZ}.
    
    Hai due soluzioni:
    \begin{enumerate}
        \item \textbf{Opzione A (Consigliata):} Salva nel DB direttamente \texttt{ROLE\_ADMIN}.
        \item \textbf{Opzione B:} Usa \texttt{hasAuthority('ADMIN')} invece di \texttt{hasRole}. \texttt{hasAuthority} non aggiunge nessun prefisso, cerca la stringa esatta.
    \end{enumerate}
\end{interview}

\section{Protezione dagli Attacchi Comuni}

Spring Security non serve solo a gestire i login, ma protegge l'applicazione da vulnerabilità note del protocollo HTTP. Analizziamo le due più frequenti: CSRF (che spesso disabilitiamo) e CORS (che dobbiamo configurare con cura).

\subsection{CSRF (Cross-Site Request Forgery)}
Il CSRF è un attacco che forza un utente finale (già autenticato) a eseguire azioni indesiderate su un'applicazione web in cui è attualmente loggato.

\textit{Esempio:} Sei loggato sul sito della tua banca. Apri una mail malevola che contiene un link nascosto che fa una richiesta \texttt{POST /bonifico?to=hacker}. Se il sito usa i \textbf{Cookie} per l'autenticazione, il browser allegherà automaticamente il cookie di sessione e la banca eseguirà il bonifico.

\begin{interview}{Perché disabilitiamo CSRF nelle API REST?}
    \textbf{Domanda:} "Vedo sempre \texttt{.csrf(csrf -> csrf.disable())}. Non è pericoloso?"
    
    \textbf{Risposta:} Dipende dal meccanismo di autenticazione.
    \begin{itemize}
        \item \textbf{Se usi Sessioni/Cookie:} Il CSRF protection deve essere \textbf{ABILITATO}. Spring Security si aspetta un token CSRF extra in ogni form HTML per validare la richiesta.
        \item \textbf{Se usi JWT (Stateless):} Il CSRF protection può essere \textbf{DISABILITATO}.
    \end{itemize}
    \textbf{Motivo:} I browser allegano automaticamente i Cookie, ma \textbf{non} allegano automaticamente gli Header custom (es. \texttt{Authorization: Bearer ...}). Poiché il JWT viaggia nell'header, un sito attaccante non può forzare il browser a inviare il token.
\end{interview}

\subsection{CORS (Cross-Origin Resource Sharing)}
Il CORS non è un attacco, ma un meccanismo di sicurezza dei browser.
Per default, la \textit{Same-Origin Policy} impedisce a uno script caricato da \texttt{http://domain-a.com} di fare chiamate API verso \texttt{http://domain-b.com}.

Nello sviluppo moderno (Frontend Angular/React su localhost:4200, Backend Spring su localhost:8080), le origini sono diverse (cambia la porta). Il browser blocca tutto se il server non acconsente esplicitamente.

\begin{deepdive}{La richiesta Preflight (OPTIONS)}
    Prima di fare una richiesta "complessa" (es. una POST con JSON e header Authorization), il browser invia automaticamente una richiesta preliminare di tipo \textbf{OPTIONS}.
    
    Questa richiesta chiede: "Ehi server, accetti chiamate da localhost:4200 con questi header?".
    Se Spring Security blocca la richiesta OPTIONS (perché non autenticata), il Frontend riceverà un errore CORS.
    \textbf{Soluzione:} Configurare il CORS a livello di Spring Security, non solo nel Controller.
\end{deepdive}

\subsubsection{Configurazione CORS Globale}
Non usare l'annotazione \texttt{@CrossOrigin} sui singoli controller (diventa ingestibile). Definisci una configurazione centralizzata.

\begin{lstlisting}[language=Java, caption=Configurazione CORS Best Practice]
@Bean
CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    
    // 1. Chi può chiamarmi? (In prod mettere domini specifici, non *)
    configuration.setAllowedOrigins(Arrays.asList("http://localhost:4200", "https://mia-app.com"));
    
    // 2. Quali metodi accetto?
    configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
    
    // 3. Quali header accetto? (Authorization è fondamentale per JWT)
    configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
    
    // 4. Registra la configurazione per tutti gli endpoint
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    return source;
}
\end{lstlisting}


% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Spring Batch}

\section{Introduzione}

Spring Batch è un framework leggero e completo, progettato per consentire lo sviluppo di applicazioni \textit{batch} robuste. Un'elaborazione batch è, per definizione, l'esecuzione di una serie di job (lavori) senza l'interazione manuale dell'utente, spesso gestendo grandi moli di dati in maniera sequenziale o parallela.

Nel mondo Enterprise Java, è lo standard \textit{de-facto}. Si basa sui principi di Spring Framework (Dependency Injection, POJO) per permettere agli sviluppatori di concentrarsi sulla logica di business (es. calcolo stipendi) delegando al framework la gestione della complessità infrastrutturale (transazioni, gestione risorse, logging).

\subsection{Caratteristiche Fondamentali}
Non si tratta solo di eseguire un ciclo \texttt{for} su una lista di dati. Spring Batch offre funzionalità avanzate pronte all'uso:

\begin{itemize}
    \item \textbf{Gestione delle Transazioni:} Automatica e granulare (per "chunk").
    \item \textbf{Restartability:} Capacità di riavviare un job fallito esattamente dal punto in cui si è interrotto.
    \item \textbf{Skip \& Retry:} Logica configurabile per saltare record corrotti o riprovare operazioni fallite (es. timeout di rete).
    \item \textbf{Statistiche e Monitoraggio:} Tracciamento automatico di tempi di esecuzione, record letti, scritti e ignorati tramite metadati persistenti su DB.
    \item \textbf{Scalabilità:} Supporto per esecuzione multithread e partizionamento dei dati.
\end{itemize}

\begin{interview}{Spring Batch vs @Scheduled (Spring Task)}
    Questa è una classica domanda per capire se il candidato ha esperienza reale.
    
    \textbf{Domanda:} "Perché dovrei usare Spring Batch se posso semplicemente annotare un metodo con \texttt{@Scheduled} e fare un ciclo su tutti i record?"
    
    \textbf{Risposta:}
    \begin{enumerate}
        \item \textbf{Gestione della Memoria (OOM):} Un metodo \texttt{@Scheduled} che carica 1 milione di record in una \texttt{List} causerà un \textit{Out Of Memory}. Spring Batch legge a "pezzi" (chunk), mantenendo la memoria costante.
        \item \textbf{Transazionalità:} In un metodo semplice, se il record 99.999 fallisce, di solito si fa rollback di tutto (persi 99.998 record elaborati) o commit parziale ingestibile. Spring Batch committa ogni $N$ record.
        \item \textbf{Ripresa (Restartability):} Se lo script si blocca a metà notte, con \texttt{@Scheduled} non sai dove sei arrivato. Spring Batch salva lo stato nel DB: al riavvio riprende esattamente da dove si era fermato.
    \end{enumerate}
\end{interview}

\subsection{Architettura a Livelli}
L'architettura di Spring Batch è strutturata in tre livelli distinti per separare le responsabilità:

\begin{enumerate}
    \item \textbf{Application Layer:} Contiene i job personalizzati e il codice scritto dallo sviluppatore (Business Logic).
    \item \textbf{Batch Core:} Le classi API principali per lanciare e controllare i job (\texttt{JobLauncher}, \texttt{Job}, \texttt{Step}).
    \item \textbf{Batch Infrastructure:} I servizi comuni di basso livello (lettori e scrittori di file/DB, gestione dei retry, template).
\end{enumerate}

\begin{deepdive}{Batch Processing vs Real-Time}
    È importante distinguere i due paradigmi:
    \begin{itemize}
        \item \textbf{Real-Time (Online):} Elabora una richiesta alla volta (es. API REST). La risposta deve essere immediata (millisecondi). Se c'è un errore, l'utente viene notificato subito.
        \item \textbf{Batch (Offline):} Elabora milioni di record in background. La durata può essere di ore. Se c'è un errore, il sistema deve gestirlo (skip/retry) o notificare un amministratore, ma il processo non ha un utente "in attesa" davanti allo schermo.
    \end{itemize}
\end{deepdive}

\subsection{Casi d'uso tipici}
Spring Batch è ideale in scenari come:
\begin{itemize}
    \item \textbf{ETL (Extract, Transform, Load):} Spostare dati da un vecchio DB a uno nuovo, o caricare dati da file CSV/XML ricevuti da fornitori esterni.
    \item \textbf{Reportistica Finanziaria:} Calcolo di interessi, fatturazione mensile o riconciliazione bancaria a fine giornata.
    \item \textbf{Massive Emailing:} Invio di newsletter o notifiche a milioni di utenti (senza bloccare il server di posta).
\end{itemize}

\section{Architettura e Componenti Fondamentali}

Per padroneggiare Spring Batch, bisogna comprendere come i suoi componenti interagiscono. Non basta scrivere codice Java; bisogna capire il flusso di controllo.

\subsection{Panoramica dei Componenti}
Il flusso di esecuzione segue una gerarchia precisa. Ecco lo schema architetturale ad alto livello:

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm,
    every node/.style={font=\small},
    block/.style={rectangle, draw=deepblue, fill=white, text width=2.5cm, align=center, rounded corners, minimum height=1cm, line width=1pt},
    container/.style={rectangle, draw=javablue, fill=javablue!5, inner sep=0.5cm, dashed, rounded corners},
    db/.style={cylinder, shape border rotate=90, draw=javared, fill=white, aspect=0.25, text width=2cm, align=center, minimum height=1.5cm}
]

    % Nodi
    \node[block] (launcher) {\textbf{JobLauncher}\\(Avvia il Job)};
    
    \node[block, right=1.5cm of launcher] (job) {\textbf{Job}\\(Contenitore)};
    
    \node[block, right=1.5cm of job] (step) {\textbf{Step}\\(Fase di Lavoro)};
    
    \node[db, below=2cm of job] (repo) {\textbf{JobRepository}\\(Database)};

    % Contenitore Logico
    \node[container, fit=(job) (step)] (job_container) {};
    \node[above, color=javablue] at (job_container.north) {\textit{Job Execution Context}};

    % Frecce
    \draw[->, thick, deepblue] (launcher) -- (job);
    \draw[->, thick, deepblue] (job) -- (step);
    
    \draw[->, dashed, color=gray] (launcher) -- (repo) node[midway, left] {\tiny Persiste stato};
    \draw[->, dashed, color=gray] (step) |- (repo);
    \draw[->, dashed, color=gray] (job) -- (repo);

\end{tikzpicture}
\end{center}

\begin{enumerate}
    \item \textbf{JobLauncher:} È l'interfaccia semplice che permette di avviare un Job. Prende in input il \texttt{Job} e i \texttt{JobParameters}.
    \item \textbf{Job:} Rappresenta l'intero processo batch. È un contenitore di uno o più Step.
    \item \textbf{Step:} È l'unità di lavoro. Un Job è composto da una sequenza di Step. Uno Step può essere di due tipi:
    \begin{itemize}
        \item \textbf{Chunk-Oriented:} Legge, elabora e scrive dati (il classico ETL).
        \item \textbf{Tasklet:} Esegue un singolo compito semplice (es. cancellare un file, eseguire una query di pulizia, inviare una mail di fine lavoro).
    \end{itemize}
    \item \textbf{JobRepository:} Il meccanismo di persistenza. Si occupa di salvare lo stato attuale del Job e degli Step nel database.
\end{enumerate}

\subsection{JobInstance vs JobExecution}
Questa è una distinzione terminologica che crea confusione ma è essenziale per comprendere il meccanismo di \textit{Restart}.

\begin{interview}{Differenza tra JobInstance e JobExecution}
    \textbf{Domanda:} "Se lancio un Job oggi che fallisce, e lo rilancio domani, creo una nuova istanza?"
    
    \textbf{Risposta:} Dipende dai \textbf{JobParameters}.
    
    \begin{itemize}
        \item \textbf{JobInstance:} È il concetto logico di "Esecuzione del Job per quei specifici parametri". Esempio: \texttt{EndDayJob} per la data \texttt{2023-10-25}.
        \item \textbf{JobExecution:} È il tentativo tecnico di eseguire quell'istanza.
    \end{itemize}
    
    \textbf{Esempio Pratico:}
    \begin{enumerate}
        \item Lancio il Job con parametro \texttt{date=2023-10-25}. Viene creata la \textbf{JobInstance A} e la \textbf{JobExecution 1}. \textbf{Fallisce}.
        \item Correggo il bug e rilancio con \texttt{date=2023-10-25}. Spring Batch riconosce che l'Istanza A esiste già. Crea la \textbf{JobExecution 2} collegata alla \textbf{JobInstance A}. Riprende da dove si era fermato.
        \item Lancio il Job con \texttt{date=2023-10-26}. Nuovi parametri $\to$ Nuova \textbf{JobInstance B} $\to$ Nuova \textbf{JobExecution 3}.
    \end{enumerate}
\end{interview}

\subsection{Il Metamodello (Tabelle di Spring Batch)}
Spring Batch non funziona "in memoria" (di default). Ha bisogno di un set di tabelle dedicate sul database per tracciare lo stato. Senza queste tabelle, le funzionalità di riavvio e monitoraggio non funzionano.

\begin{deepdive}{Le Tabelle BATCH\_*}
    Durante un colloquio per posizioni Senior, sapere dove guardare quando un batch si blocca è vitale.
    
    \begin{itemize}
        \item \texttt{BATCH\_JOB\_INSTANCE}: Contiene la chiave univoca del job (Nome Job + Hash dei Parametri).
        \item \texttt{BATCH\_JOB\_EXECUTION}: Contiene lo stato (COMPLETED, FAILED, STARTED), data inizio/fine.
        \item \texttt{BATCH\_JOB\_EXECUTION\_CONTEXT}: Memorizza dati serializzati da passare tra gli step o da recuperare al riavvio (es. "riga corrente: 450").
        \item \texttt{BATCH\_STEP\_EXECUTION}: Dettagli su ogni step (record letti, scritti, commit effettuati, rollback).
    \end{itemize}
    
    \textbf{Nota:} In Spring Boot, queste tabelle possono essere create automaticamente all'avvio impostando \texttt{spring.batch.jdbc.initialize-schema=always}, ma in produzione si usa solitamente uno script DDL manuale fornito da Spring.
\end{deepdive}

\subsection{Tasklet vs Chunk: Quando usare cosa?}

\begin{itemize}
    \item Usa un \textbf{Tasklet} quando l'operazione è "atomica" e non iterativa.
    \begin{lstlisting}[language=Java, title=Esempio Tasklet Semplice]
@Bean
public Step cleanUpStep(JobRepository jobRepository, PlatformTransactionManager txManager) {
    return new StepBuilder("cleanUpStep", jobRepository)
        .tasklet((contribution, chunkContext) -> {
            System.out.println("Pulizia file temporanei...");
            return RepeatStatus.FINISHED;
        }, txManager)
        .build();
}
    \end{lstlisting}
    
    \item Usa un \textbf{Chunk} quando devi processare una lista di item. Spring Batch gestirà per te l'apertura e chiusura delle transazioni in modo efficiente.
\end{itemize}

\section{Chunk-Oriented Processing}

Il "Chunk-Oriented Processing" è il pattern architetturale distintivo di Spring Batch. A differenza della semplice iterazione, questo approccio ottimizza le performance raggruppando le operazioni di scrittura.

L'idea base è: leggere un dato alla volta, elaborarlo, e accumulare il risultato in memoria. Quando il numero di elementi accumulati raggiunge una soglia predefinita (il \textbf{Commit Interval}), l'intero blocco viene scritto in un colpo solo e la transazione viene committata.

\subsection{Il Ciclo di Vita del Chunk}
Ecco come avviene il flusso di dati all'interno di uno Step configurato a chunk:

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm,
    auto,
    block/.style={rectangle, draw=deepblue, fill=white, text width=2.5cm, align=center, rounded corners, minimum height=1cm, line width=1pt},
    decision/.style={diamond, draw=javared, fill=white, text width=1.5cm, align=center, aspect=2},
    arrow/.style={->, thick, >=stealth}
]

    % Nodes
    \node[block] (start) {Inizio Step};
    \node[block, below=1cm of start] (read) {\textbf{ItemReader}\\ \texttt{read()}};
    \node[block, right=1.5cm of read] (process) {\textbf{ItemProcessor}\\ \texttt{process()}};
    \node[decision, below=1.5cm of process] (check) {Chunk Pieno?};
    \node[block, left=1.5cm of check] (buffer) {Accumulo in Lista};
    \node[block, below=1.5cm of check] (write) {\textbf{ItemWriter}\\ \texttt{write(List)}};
    \node[block, left=1.5cm of write] (commit) {COMMIT Transazione};

    % Paths
    \draw[arrow] (start) -- (read);
    \draw[arrow] (read) -- node[above] {1 Item} (process);
    \draw[arrow] (process) -- (check);
    
    % Loop No
    \draw[arrow] (check) -- node[above] {No} (buffer);
    \draw[arrow] (buffer) -- (read);
    
    % Loop Yes
    \draw[arrow] (check) -- node[right] {Sì ($N$ items)} (write);
    \draw[arrow] (write) -- (commit);
    \draw[arrow] (commit) -- ++(-3,0) |- (start); % Ritorna su per il prossimo chunk

\end{tikzpicture}
\end{center}

\subsection{Le Interfacce Chiave}

È fondamentale conoscere la firma dei metodi delle tre interfacce principali.

\begin{itemize}
    \item \textbf{ItemReader<T>:} Restituisce un oggetto alla volta. Restituisce \texttt{null} per indicare che i dati sono finiti.
    \item \textbf{ItemProcessor<I, O>:} Riceve un oggetto di input \texttt{I}, lo trasforma e restituisce \texttt{O}.
    \begin{itemize}
        \item \textcolor{javared}{\textbf{Nota Importante:}} Se restituisce \texttt{null}, l'elemento viene \textbf{filtrato} (scartato) e non arriverà al Writer.
    \end{itemize}
    \item \textbf{ItemWriter<T>:} Riceve una \texttt{Chunk<? extends T>} (o una \texttt{List} nelle versioni precedenti), non un singolo oggetto.
\end{itemize}

\begin{lstlisting}[language=Java, caption=Le interfacce funzionali]
// 1. READER
public interface ItemReader<T> {
    T read() throws Exception; // Ritorna null alla fine
}

// 2. PROCESSOR
public interface ItemProcessor<I, O> {
    O process(I item) throws Exception; // Ritorna null per scartare
}

// 3. WRITER
public interface ItemWriter<T> {
    // Nota: riceve una LISTA, non un singolo oggetto
    void write(Chunk<? extends T> chunk) throws Exception;
}
\end{lstlisting}

\subsection{Gestione delle Transazioni}

La potenza di Spring Batch risiede nel confine transazionale.

\begin{deepdive}{Commit Interval e Rollback}
    In uno scenario con \texttt{chunk-size = 10}:
    
    \begin{enumerate}
        \item Spring apre una transazione DB.
        \item Legge 10 record, li processa 10 volte.
        \item Passa una lista di 10 elementi al Writer.
        \item Se tutto va bene $\to$ \textbf{COMMIT} (i dati sono persistiti).
        \item Se avviene un'eccezione al record 9 (durante la lettura o processazione) o durante la scrittura:
        \begin{itemize}
            \item L'intera transazione viene annullata (\textbf{ROLLBACK}).
            \item Nessuno dei 10 record viene salvato (nemmeno i primi 8 validi).
        \end{itemize}
    \end{enumerate}
    
    Questo garantisce l'integrità dei dati: o tutto il blocco è valido, o nulla viene scritto.
\end{deepdive}

\begin{interview}{Come scelgo la dimensione del Chunk?}
    \textbf{Domanda:} "Perché non impostare il chunk size a 1 o a 1.000.000?"
    
    \textbf{Risposta:} È un trade-off tra overhead transazionale e memoria.
    \begin{itemize}
        \item \textbf{Chunk = 1:} Troppo lento. Per 10.000 record fai 10.000 commit al database. L'overhead della gestione della transazione uccide le performance.
        \item \textbf{Chunk = 1.000.000:} Rischio \texttt{OutOfMemoryError} (tieni troppi oggetti in RAM prima di scrivere) e rischio di \textit{Transaction Log} del DB pieno. Inoltre, se fallisce l'ultimo record, devi riprocessarne un milione (spreco di tempo).
        \item \textbf{Valori tipici:} Tra 50 e 1000, a seconda della grandezza degli oggetti e della latenza del DB.
    \end{itemize}
\end{interview}

\section{Implementazione dei Componenti}

Spring Batch fornisce molte implementazioni pronte all'uso ("Out of the box") per leggere e scrivere dalle fonti dati più disparate (File piatti, XML, JSON, Database JDBC/JPA, MongoDB, Kafka, ecc.).
Analizziamo le più frequenti in ambito Enterprise.

\subsection{ItemReader: Lettura da File (CSV)}
Il \texttt{FlatFileItemReader} è il componente standard per leggere file di testo. È altamente configurabile per gestire delimitatori, intestazioni e righe di commento.

\begin{lstlisting}[language=Java, caption=Configurazione FlatFileItemReader]
@Bean
public FlatFileItemReader<Person> reader() {
    return new FlatFileItemReaderBuilder<Person>()
        .name("personItemReader")
        .resource(new ClassPathResource("dati_input.csv"))
        .delimited() // Indica che è un file delimitato (default virgola)
        .names("firstName", "lastName") // Mappa le colonne ai campi del POJO
        .targetType(Person.class) // La classe di destinazione
        .linesToSkip(1) // Salta l'header
        .build();
}
\end{lstlisting}

\subsection{ItemReader: Lettura da Database (JDBC)}
Quando si legge da database, ci sono due approcci filosofici diversi. Capire la differenza è vitale per le performance e la concorrenza.

\subsubsection{1. Cursor Based (JdbcCursorItemReader)}
Funziona come una \texttt{ResultSet} standard di JDBC. Apre una connessione, esegue la query e mantiene il cursore aperto mentre scorre i risultati uno a uno.
\begin{itemize}
    \item \textbf{Pro:} Molto performante per stream di dati sequenziali.
    \item \textbf{Contro:} Mantiene la connessione al DB occupata per tutta la durata dello step. \textbf{Non è Thread-Safe} (non usabile in step multithread).
\end{itemize}

\subsubsection{2. Paging Based (JdbcPagingItemReader)}
Invece di una query unica, esegue molteplici query per recuperare "pagine" di dati (es. \texttt{LIMIT 1000 OFFSET 0}, poi \texttt{OFFSET 1000}...).
\begin{itemize}
    \item \textbf{Pro:} Non tiene la connessione bloccata a lungo. \textbf{È Thread-Safe} (ogni thread può leggere una pagina diversa).
    \item \textbf{Contro:} Richiede una chiave di ordinamento (Sort Key) stabile per garantire che le pagine non si sovrappongano.
\end{itemize}

\begin{deepdive}{Deep Dive: Cursor vs Paging in Multithreading}
    Se in un colloquio ti chiedono: \textit{"Come velocizzi un job che legge da DB?"}, la risposta "Attivo il multithreading" è parziale.
    
    Devi specificare: "Attivo il multithreading e cambio il reader da \texttt{Cursor} a \texttt{Paging}".
    Se usi un \texttt{JdbcCursorItemReader} in un ambiente multithread, avrai eccezioni di concorrenza perché più thread proveranno a spostare lo stesso cursore JDBC contemporaneamente. Il \texttt{JdbcPagingItemReader} è progettato proprio per risolvere questo problema.
\end{deepdive}

\begin{lstlisting}[language=Java, caption=Configurazione JdbcPagingItemReader]
@Bean
public JdbcPagingItemReader<Person> pagingReader(DataSource dataSource) {
    Map<String, Order> sortKeys = new HashMap<>();
    sortKeys.put("id", Order.ASCENDING); // Fondamentale per la paginazione

    return new JdbcPagingItemReaderBuilder<Person>()
        .name("dbReader")
        .dataSource(dataSource)
        .selectClause("SELECT id, first_name, last_name")
        .fromClause("FROM person")
        .sortKeys(sortKeys)
        .pageSize(1000) // Dimensione della pagina (non del chunk!)
        .rowMapper(new BeanPropertyRowMapper<>(Person.class))
        .build();
}
\end{lstlisting}

\subsection{ItemProcessor: Logica di Business}
Il Processor è il luogo dove risiede la logica. È opzionale (puoi passare direttamente da Reader a Writer), ma consigliato per trasformazioni o validazioni.

\begin{lstlisting}[language=Java, caption=Processor con filtraggio]
public class PersonProcessor implements ItemProcessor<Person, Person> {

    @Override
    public Person process(Person item) throws Exception {
        // Logica di trasformazione
        String upperName = item.getFirstName().toUpperCase();
        item.setFirstName(upperName);

        // Logica di FILTRAGGIO
        // Se il cognome è "Test", scarta il record
        if ("Test".equalsIgnoreCase(item.getLastName())) {
            return null; // Restituire null significa "SKIP"
        }

        return item;
    }
}
\end{lstlisting}

\subsection{ItemWriter: Scrittura su DB}
Il \texttt{JdbcBatchItemWriter} è molto efficiente perché usa il \texttt{batchUpdate} di JDBC (invia un blocco di comandi SQL in una sola chiamata di rete).

\begin{lstlisting}[language=Java, caption=Writer JDBC]
@Bean
public JdbcBatchItemWriter<Person> writer(DataSource dataSource) {
    return new JdbcBatchItemWriterBuilder<Person>()
        .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>())
        .sql("INSERT INTO people (first_name, last_name) VALUES (:firstName, :lastName)")
        .dataSource(dataSource)
        .build();
}
\end{lstlisting}

\section{Gestione degli Errori e Resilienza}

In un ambiente di produzione reale, i job batch non lavorano mai in condizioni ideali. File corrotti, record duplicati, timeout di rete o database momentaneamente irraggiungibili sono eventi comuni.
Spring Batch offre meccanismi robusti per gestire questi scenari senza far fallire l'intero job.

\subsection{Skip Logic (Tolleranza ai guasti)}
La logica di \textbf{Skip} permette di ignorare specifici record che causano eccezioni, continuando l'elaborazione dei successivi. È utile per errori \textit{deterministici} legati al dato (es. un CSV con una riga malformata o una stringa al posto di un numero).

Configuriamo lo Step per tollerare l'eccezione ma fissiamo un limite:
\begin{itemize}
    \item \textbf{skip(Class):} Specifica quale eccezione ignorare.
    \item \textbf{skipLimit(int):} Specifica quanti errori tollerare prima di far fallire il Job.
\end{itemize}

\begin{deepdive}{Deep Dive: Come funziona lo Skip (Scan Mode)}
    Questo è un dettaglio architetturale avanzato. Quando avviene un'eccezione in un Chunk durante la scrittura:
    
    \begin{enumerate}
        \item Spring Batch esegue il \textbf{Rollback} dell'intera transazione (tutto il chunk viene annullato).
        \item Entra in una modalità chiamata "Scan Mode" (o item-by-item processing).
        \item Ripassa gli item del chunk \textbf{uno alla volta}, committando transazioni singole per ogni item.
        \item Quando incontra l'item che genera l'errore, lo "skippa" (segnalandolo nei log/tabelle) e prosegue col successivo.
    \end{enumerate}
    
    \textbf{Conclusione:} Lo skip ha un costo prestazionale elevato (moltiplicazione delle transazioni). Va usato per eccezioni rare, non come logica di flusso normale.
\end{deepdive}

\subsection{Retry Logic (Riprovare l'operazione)}
La logica di \textbf{Retry} serve per errori \textit{transienti} (temporanei), come un timeout di connessione o un deadlock sul DB. Non ha senso scartare il dato se il problema è la rete; bisogna riprovare.

\begin{interview}{Skip vs Retry: Quando usare quale?}
    \textbf{Domanda:} "Ho un'eccezione \texttt{DataIntegrityViolationException} e una \texttt{SocketTimeoutException}. Come le gestisco?"
    
    \textbf{Risposta:}
    \begin{itemize}
        \item \textbf{DataIntegrityViolationException} (es. Vincolo Unique violato): È un errore permanente. Riprovare 100 volte darà sempre errore. $\to$ Uso lo \textbf{SKIP}.
        \item \textbf{SocketTimeoutException}: È un errore temporaneo. Tra 1 secondo la rete potrebbe tornare. $\to$ Uso il \textbf{RETRY}.
    \end{itemize}
\end{interview}

\subsection{Esempio di Configurazione Fault-Tolerant}
Ecco come configurare uno Step resiliente che tollera file CSV sporchi e brevi down di rete.

\begin{lstlisting}[language=Java, caption=Configurazione Skip e Retry]
@Bean
public Step resilientStep(JobRepository jobRepository, 
                          PlatformTransactionManager txManager,
                          ItemReader<User> reader,
                          ItemWriter<User> writer) {
                          
    return new StepBuilder("resilientStep", jobRepository)
        .<User, User>chunk(10, txManager)
        .reader(reader)
        .writer(writer)
        .faultTolerant() // Abilita le funzionalità di resilienza
        
        // --- SKIP CONFIG ---
        .skip(FlatFileParseException.class) // Errore di parsing file
        .skip(ValidationException.class)    // Errore logico
        .noSkip(NullPointerException.class) // Bug del codice: non skippare, deve fallire!
        .skipLimit(10) // Max 10 record ignorati
        
        // --- RETRY CONFIG ---
        .retry(ConnectTimeoutException.class) // Errore di rete
        .retry(DeadlockLoserDataAccessException.class) // Deadlock DB
        .retryLimit(3) // Riprova max 3 volte per ogni item
        
        .build();
}
\end{lstlisting}

\subsection{Listeners (Intercettare gli Eventi)}
I \textbf{Listeners} permettono di eseguire logica custom (logging, notifiche email, pulizia risorse) in momenti specifici del ciclo di vita.
Interfacce comuni: \texttt{JobExecutionListener}, \texttt{StepExecutionListener}, \texttt{ItemReadListener}, \texttt{ItemWriteListener}.

\begin{lstlisting}[language=Java, caption=Esempio JobExecutionListener]
@Component
public class JobNotificationListener implements JobExecutionListener {

    private static final Logger log = LoggerFactory.getLogger(JobNotificationListener.class);

    @Override
    public void afterJob(JobExecution jobExecution) {
        if (jobExecution.getStatus() == BatchStatus.COMPLETED) {
            log.info("!!! JOB COMPLETATO CON SUCCESSO !!!");
            // Qui potrei inviare una mail all'amministratore
        } else if (jobExecution.getStatus() == BatchStatus.FAILED) {
            log.error("!!! JOB FALLITO con eccezioni: " + jobExecution.getAllFailureExceptions());
        }
    }
}
\end{lstlisting}

\section{Scalabilità e Performance}

Di default, Spring Batch esegue il Job in un \textbf{singolo thread}. Questo garantisce la massima sicurezza e semplicità (niente race conditions), ma su moli di dati enormi (milioni di record) potrebbe non essere sufficiente per rispettare le finestre temporali di esecuzione (SLA).

Esistono due strategie principali per scalare: il \textit{Multi-threaded Step} (Vertical Scaling) e il \textit{Partitioning} (Horizontal Scaling).

\subsection{Multi-threaded Step}
È il metodo più veloce da implementare. Si configura lo Step per utilizzare un \texttt{TaskExecutor} (pool di thread). In questo modo, più chunk vengono letti, processati e scritti in parallelo.

\begin{lstlisting}[language=Java, caption=Abilitare il Multithreading]
@Bean
public Step multiThreadStep(JobRepository jobRepository, 
                            PlatformTransactionManager txManager,
                            ThreadPoolTaskExecutor taskExecutor) {
    return new StepBuilder("multiThreadStep", jobRepository)
        .<User, User>chunk(100, txManager)
        .reader(pagingReader) // ATTENZIONE: Deve essere Thread-Safe!
        .writer(writer)
        .taskExecutor(taskExecutor) // Abilita il parallelismo
        .throttleLimit(4) // Max 4 thread attivi contemporaneamente
        .build();
}
\end{lstlisting}

\begin{deepdive}{Attenzione alla Thread Safety del Reader}
    Questa è la trappola numero uno.
    Se usi un \textbf{Multi-threaded Step}, il tuo \texttt{ItemReader} deve essere Thread-Safe.
    \begin{itemize}
        \item \textcolor{javared}{\textbf{JdbcCursorItemReader}:} \textbf{NON} è thread-safe. Se lo usi qui, i thread si ruberanno i dati a vicenda o lanceranno eccezioni.
        \item \textcolor{javagreen}{\textbf{JdbcPagingItemReader}:} \textbf{È} thread-safe. Ogni thread legge una pagina diversa.
        \item \textcolor{javared}{\textbf{FlatFileItemReader}:} \textbf{NON} è thread-safe di default. Va wrappato in un \texttt{SynchronizedItemStreamReader}, ma questo crea un collo di bottiglia (i thread si mettono in coda per leggere).
    \end{itemize}
\end{deepdive}

\subsection{Partitioning (Partizionamento)}
Il partitioning è una tecnica più avanzata e robusta. Invece di far competere i thread per leggere dallo stesso Reader, si divide il lavoro a monte.
Uno step "Master" (Manager) analizza i dati, crea delle partizioni (es. per range di ID o per file in una cartella) e assegna ogni partizione a uno step "Slave" (Worker) separato.

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm,
    block/.style={rectangle, draw=deepblue, fill=white, text width=2cm, align=center, rounded corners, minimum height=1cm, line width=1pt},
    worker/.style={rectangle, draw=javagreen, fill=white, text width=2cm, align=center, rounded corners, minimum height=1cm, line width=1pt},
    arrow/.style={->, thick, >=stealth}
]

    % Nodes
    \node[block] (master) {\textbf{Master Step}\\ (Partitioner)};
    
    \node[worker, below left=2cm and 0.5cm of master] (w1) {\textbf{Slave 1}\\ (ID 1-1000)};
    \node[worker, below=2cm of master] (w2) {\textbf{Slave 2}\\ (ID 1001-2000)};
    \node[worker, below right=2cm and 0.5cm of master] (w3) {\textbf{Slave 3}\\ (ID 2001-3000)};

    % Arrows
    \draw[arrow] (master) -- node[left, font=\tiny] {Exec 1} (w1);
    \draw[arrow] (master) -- node[left, font=\tiny] {Exec 2} (w2);
    \draw[arrow] (master) -- node[right, font=\tiny] {Exec 3} (w3);

\end{tikzpicture}
\end{center}

\begin{itemize}
    \item \textbf{Partitioner:} L'interfaccia che decide come dividere i dati (es. crea una mappa \texttt{minValue=1, maxValue=1000}).
    \item \textbf{PartitionHandler:} Gestisce l'esecuzione dei worker (può essere locale coi thread o remoto su altri server).
\end{itemize}

\begin{interview}{Quando usare Multi-thread e quando Partitioning?}
    \textbf{Domanda:} "Come decidi quale strategia di scaling applicare?"
    
    \textbf{Risposta:}
    \begin{itemize}
        \item Uso \textbf{Multi-threaded Step} quando ho un collo di bottiglia sulla I/O (es. scrittura lenta su DB) e ho un Reader thread-safe (Paging Reader). È facile da configurare.
        \item Uso \textbf{Partitioning} quando ho bisogno di controllo totale sulle partizioni (es. "Voglio che il Thread A processi solo il File A e il Thread B il File B") o quando voglio scalare su più macchine fisiche (\textit{Remote Partitioning}).
    \end{itemize}
\end{interview}

\subsection{Parallel Steps}
Se un Job ha due flussi indipendenti (es. scaricare dati da due fornitori diversi), non serve aspettare che finisca il primo per iniziare il secondo.

\begin{lstlisting}[language=Java, caption=Flussi Paralleli (Split)]
@Bean
public Job parallelJob(JobRepository repo, Flow flow1, Flow flow2) {
    return new JobBuilder("parallelJob", repo)
        .start(flow1)
        .split(new SimpleAsyncTaskExecutor()) // Esegue in parallelo
        .add(flow2)
        .end()
        .build();
}
\end{lstlisting}

\section{Spring Batch 5 e Spring Boot 3}

Con il rilascio di Spring Boot 3 (e di conseguenza Spring Batch 5), il framework ha subito una modernizzazione significativa. Questo aggiornamento ha introdotto dei \textit{Breaking Changes} che rendono il codice scritto per Spring Boot 2 non compilabile senza modifiche.

\subsection{Principali Novità}
\begin{enumerate}
    \item \textbf{Java 17 Obbligatorio:} Spring Batch 5 richiede almeno Java 17 come base.
    \item \textbf{Rimozione delle Factory:} \texttt{JobBuilderFactory} e \texttt{StepBuilderFactory} sono state rimosse (non solo deprecate). Non possono più essere iniettate.
    \item \textbf{Gestione Transazioni Esplicita:} Ora è obbligatorio specificare il \texttt{PlatformTransactionManager} in ogni Step (prima veniva spesso dedotto automaticamente dalle factory).
    \item \textbf{Supporto GraalVM:} Pieno supporto per compilare i batch come immagini native (avvio istantaneo e minore uso di memoria), ideale per job "usa e getta" in ambiente Cloud/Kubernetes.
\end{enumerate}

\subsection{Migrazione: Dalle Factory ai Builder}
Questa è la modifica che impatta il 90\% del codice esistente.

\begin{interview}{Come si configura un Job in Spring Batch 5?}
    \textbf{Domanda:} "Nel tuo codice vedo che usi \texttt{StepBuilderFactory}. Ma in Spring Boot 3 non esiste più. Come lo riscrivi?"
    
    \textbf{Risposta:} Bisogna istanziare manualmente \texttt{JobBuilder} e \texttt{StepBuilder}, passando esplicitamente il \texttt{JobRepository}.
    Inoltre, nel metodo \texttt{.chunk()}, è ora obbligatorio passare il \texttt{TransactionManager}.
\end{interview}

Confrontiamo i due approcci:

\begin{lstlisting}[language=Java, caption=Vecchio Stile vs Nuovo Stile (Batch 5)]
// --- STILE VECCHIO (Spring Boot 2) - NON FUNZIONA PIU' ---
@Autowired
private StepBuilderFactory stepBuilderFactory; // RIMOSSO

@Bean
public Step oldStep() {
    return stepBuilderFactory.get("step1")
            .<User, User>chunk(10) // TxManager era implicito
            .reader(reader)
            .writer(writer)
            .build();
}

// --- STILE NUOVO (Spring Boot 3 / Batch 5) ---
@Bean
public Step newStep(JobRepository jobRepository, 
                    PlatformTransactionManager txManager, // Va iniettato esplicitamente
                    ItemReader<User> reader,
                    ItemWriter<User> writer) {
                    
    return new StepBuilder("step1", jobRepository) // Passaggio esplicito repo
            .<User, User>chunk(10, txManager)      // Passaggio esplicito txManager
            .reader(reader)
            .writer(writer)
            .build();
}
\end{lstlisting}

\subsection{Modifiche al Database}
Anche lo schema delle tabelle di metadati (\texttt{BATCH\_*}) è cambiato leggermente (es. gestione delle sequenze su alcuni DB).
Se si migra un'applicazione esistente, non basta aggiornare il JAR; bisogna lanciare gli script SQL di migrazione forniti dalla documentazione ufficiale di Spring.

\begin{deepdive}{Perché questo cambiamento?}
    La rimozione delle Factory favorisce un codice meno "magico".
    Prima, le factory nascondevano la complessità del \texttt{JobRepository} e del \texttt{TransactionManager}.
    Ora, richiedendoli esplicitamente nel builder, si evitano ambiguità in applicazioni complesse con più database o più transaction manager (scenario frequente nelle grandi aziende).
\end{deepdive}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Esempio Pratico: ETL con Spring Batch}

In questo capitolo costruiremo un Job completo per importare dati da un CSV al Database.
Questo è l'esempio "Hello World" del mondo Batch, ma contiene tutti gli elementi architetturali necessari per costruire sistemi complessi.

\section{1. Il Dominio e il File di Input}

Abbiamo un file \texttt{users.csv} nella cartella \texttt{src/main/resources}:
\begin{verbatim}
Mario,Rossi,mario@test.com
Luigi,Verdi,luigi@test.com
Wario,Neri,invalid-email
\end{verbatim}

Ci servono due classi: una per mappare la riga del CSV (DTO) e una per mappare la tabella del DB (Entity).

\begin{lstlisting}[language=Java, caption=UserDTO e UserEntity]
// DTO: Mappa la riga del CSV
public record UserInput(String firstName, String lastName, String email) {}

// Entity: Mappa la tabella DB
@Entity
@Table(name = "batch_users")
public class User {
    @Id @GeneratedValue
    private Long id;
    private String fullName; // Notare: campo diverso dal CSV
    private String email;
    private LocalDateTime importedAt;
    
    // costruttori, getter, setter...
}
\end{lstlisting}

\section{2. Configurazione del Job (Spring Batch 5)}

In Spring Boot 3, la configurazione è esplicita. Dobbiamo definire i bean per \texttt{Job}, \texttt{Step} e i componenti di lettura/scrittura.

\begin{lstlisting}[language=Java, caption=BatchConfig.java - Struttura]
@Configuration
public class BatchConfig {

    // 1. READER: Legge dal CSV
    @Bean
    public FlatFileItemReader<UserInput> reader() {
        return new FlatFileItemReaderBuilder<UserInput>()
            .name("userItemReader")
            .resource(new ClassPathResource("users.csv"))
            .delimited() // File delimitato (default virgola)
            .names("firstName", "lastName", "email") // Colonne
            .targetType(UserInput.class) // Mapping automatico sul Record
            .build();
    }

    // 2. PROCESSOR: Logica di Business
    @Bean
    public ItemProcessor<UserInput, User> processor() {
        return item -> {
            // Filtro: Se l'email non contiene '@', scarta il record
            if (!item.email().contains("@")) {
                return null; // Null significa SKIP in Spring Batch
            }

            // Trasformazione
            User user = new User();
            user.setFullName(item.firstName().toUpperCase() + " " + item.lastName().toUpperCase());
            user.setEmail(item.email());
            user.setImportedAt(LocalDateTime.now());
            
            return user;
        };
    }

    // 3. WRITER: Scrive su DB (Usando un Repository JPA)
    @Bean
    public RepositoryItemWriter<User> writer(UserRepository repository) {
        return new RepositoryItemWriterBuilder<User>()
            .repository(repository)
            .methodName("save")
            .build();
    }
}
\end{lstlisting}

\section{3. Assemblaggio: Job e Step}

Ora che abbiamo i "pezzi", dobbiamo assemblarli.
Qui notiamo la differenza principale con le vecchie versioni: dobbiamo iniettare esplicitamente il \texttt{JobRepository} e il \texttt{TransactionManager}.

\begin{lstlisting}[language=Java, caption=Definizione Job e Step]
@Configuration
public class JobConfig {

    @Bean
    public Job importUserJob(JobRepository jobRepository, Step step1) {
        return new JobBuilder("importUserJob", jobRepository)
            .incrementer(new RunIdIncrementer()) // Permette di ri-lanciare il job più volte
            .start(step1) // Il job ha un solo step
            .build();
    }

    @Bean
    public Step step1(JobRepository jobRepository, 
                      PlatformTransactionManager transactionManager,
                      FlatFileItemReader<UserInput> reader,
                      ItemProcessor<UserInput, User> processor,
                      RepositoryItemWriter<User> writer) {
                      
        return new StepBuilder("step1", jobRepository)
            .<UserInput, User>chunk(10, transactionManager) // Transaction boundary
            .reader(reader)
            .processor(processor)
            .writer(writer)
            // Fault Tolerance (Opzionale)
            .faultTolerant()
            .skip(FlatFileParseException.class) // Se il CSV è rotto, salta la riga
            .skipLimit(5)
            .build();
    }
}
\end{lstlisting}

\begin{deepdive}{Chunk Size e Transazioni}
    Nell'esempio sopra abbiamo \texttt{.chunk(10, transactionManager)}.
    Significa che Spring Batch:
    \begin{enumerate}
        \item Apre una transazione.
        \item Legge 10 righe dal CSV.
        \item Processa 10 righe (trasformazione in Entity).
        \item Passa una \texttt{List<User>} di 10 elementi al Writer.
        \item Il Writer salva tutto.
        \item \textbf{COMMIT} della transazione.
    \end{enumerate}
    Se il record n. 9 genera un errore, \textbf{tutti e 10 vengono rollbackati} (a meno di configurazioni di Skip specifiche).
\end{deepdive}

\section{4. Esecuzione del Job}

Di default, Spring Boot lancia \textbf{tutti} i Job configurati all'avvio dell'applicazione.
Questo è comodo per i test, ma in produzione spesso vogliamo lanciare i job via HTTP o via schedulazione temporale (Cron).

\subsection{Disabilitare l'avvio automatico}
Nel file \texttt{application.properties}:
\begin{verbatim}
spring.batch.job.enabled=false
\end{verbatim}

\subsection{Lancio Manuale (Controller)}
Possiamo creare un endpoint REST per scatenare il batch su richiesta.

\begin{lstlisting}[language=Java, caption=JobLauncherController.java]
@RestController
@RequestMapping("/batch")
public class JobLauncherController {

    private final JobLauncher jobLauncher;
    private final Job job;

    public JobLauncherController(JobLauncher jobLauncher, Job job) {
        this.jobLauncher = jobLauncher;
        this.job = job;
    }

    @PostMapping("/start")
    public String startJob() throws Exception {
        // I JobParameters rendono l'istanza del Job unica.
        // Aggiungiamo il timestamp per poterlo rilanciare quando vogliamo.
        JobParameters params = new JobParametersBuilder()
                .addLong("time", System.currentTimeMillis())
                .toJobParameters();

        // L'esecuzione è ASINCRONA di default se configurato un TaskExecutor,
        // ma sincrona (blocca la riposta HTTP) con la configurazione standard.
        jobLauncher.run(job, params);

        return "Job avviato!";
    }
}
\end{lstlisting}

\begin{interview}{JobParameters e Unicità}
    \textbf{Domanda:} "Perché hai aggiunto il parametro \texttt{time}?"
    
    \textbf{Risposta:} Per Spring Batch, una \textbf{JobInstance} è definita dalla coppia (Nome Job + Parametri).
    Se lancio \texttt{importUserJob} oggi con parametro \texttt{date=2023-10-01} e finisce con successo (\texttt{COMPLETED}), non posso più rilanciarlo con gli stessi parametri. Spring mi direbbe: \textit{"Questo lavoro è già stato fatto!"}.
    Per rieseguirlo (es. per debug), devo cambiare almeno un parametro.
\end{interview}

\section{5. Monitoraggio: Le Tabelle di Metadati}

Dopo aver lanciato il Job, possiamo ispezionare il database per vedere cosa è successo. Spring Batch popola automaticamente le sue tabelle di sistema.

\begin{itemize}
    \item \textbf{BATCH\_JOB\_INSTANCE:} Registra che esiste il job "importUserJob".
    \item \textbf{BATCH\_JOB\_EXECUTION:} Registra lo status (\texttt{COMPLETED}), \texttt{START\_TIME}, \texttt{END\_TIME}.
    \item \textbf{BATCH\_STEP\_EXECUTION:} Dettagli granulari:
    \begin{itemize}
        \item \texttt{READ\_COUNT}: Quanti record letti (es. 3).
        \item \texttt{WRITE\_COUNT}: Quanti scritti (es. 2, perché 1 filtrato).
        \item \texttt{FILTER\_COUNT}: 1 (quello con email invalida).
        \item \texttt{COMMIT\_COUNT}: 1 (se chunk size > 3).
    \end{itemize}
\end{itemize}

Questi dati sono oro colato per il monitoraggio e il debugging in produzione.

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Testing in Spring Boot}

Nel mondo Enterprise, "funziona sulla mia macchina" non basta.
Il testing in Spring non riguarda solo l'uso di JUnit, ma la capacità di caricare il \textbf{Context} in modo intelligente.

Spring Boot fornisce uno starter dedicato: \texttt{spring-boot-starter-test}, che include già le librerie standard de-facto: \textbf{JUnit 5} (il motore), \textbf{Mockito} (per i mock), \textbf{AssertJ} (per asserzioni leggibili) e \textbf{Hamcrest}.

\section{La Piramide dei Test}
Prima di scrivere codice, devi scegliere la strategia. Non tutti i test devono caricare Spring!

\begin{enumerate}
    \item \textbf{Unit Test (Solitari):} Testano la logica di una singola classe. \textbf{Non avviano Spring}. Velocissimi (ms).
    \item \textbf{Slice Test (Integrazione Parziale):} Caricano solo una "fetta" del contesto Spring (es. solo il Web Layer o solo il DB Layer).
    \item \textbf{Integration Test (Full):} Caricano l'intero \texttt{ApplicationContext}. Lenti (secondi/minuti).
\end{enumerate}

\section{1. Unit Testing (Senza Spring)}
Se devi testare un algoritmo dentro un Service, non serve Spring. Usa Mockito puro. È la forma di test più veloce e preferibile.

\begin{lstlisting}[language=Java, title={Unit Test Puro con Mockito}]
// @ExtendWith abilita le annotazioni di Mockito (@Mock, @InjectMocks)
@ExtendWith(MockitoExtension.class) 
class UserServiceTest {

    @Mock
    private UserRepository userRepository; // Mock del dipendenza

    @InjectMocks
    private UserService userService; // Classe da testare

    @Test
    void shouldCreateUser() {
        // 1. Arrange (Preparo i dati e il comportamento del mock)
        User input = new User("Mario");
        when(userRepository.save(any())).thenReturn(new User(1L, "Mario"));

        // 2. Act (Eseguo)
        User result = userService.createUser(input);

        // 3. Assert (Verifico con AssertJ)
        assertThat(result.getId()).isNotNull();
        verify(userRepository).save(any()); // Verifico che il mock sia stato chiamato
    }
}
\end{lstlisting}

\section{2. Slice Testing (Il bisturi di Spring)}
A volte devi testare se il tuo Controller risponde correttamente in JSON, o se la tua Query JPA funziona. Caricare tutta l'app è eccessivo. Spring offre le "Annotation Slices".

\subsection{@WebMvcTest (Controller Layer)}
Carica \textbf{SOLO} i Controller, i filtri di sicurezza e la gestione JSON. Non carica Service, Repository o connessioni al DB.

\begin{lstlisting}[language=Java]
@WebMvcTest(UserController.class) // Carica solo questo controller
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc; // Simula le chiamate HTTP senza server reale

    @MockBean // Fondamentale: Sostituisce il Service vero con un Mock nel contesto Spring
    private UserService userService;

    @Test
    void shouldReturnUser() throws Exception {
        when(userService.findById(1L)).thenReturn(new UserDTO("Mario"));

        mockMvc.perform(get("/api/users/1")
                .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.username").value("Mario"));
    }
}
\end{lstlisting}

\subsection{@DataJpaTest (Persistence Layer)}
Carica solo JPA, Hibernate e il DataSource. Di default configura un database in-memory (\textbf{H2}) per velocità.

\begin{lstlisting}[language=Java]
@DataJpaTest
class UserRepositoryTest {

    @Autowired
    private UserRepository repository;

    @Test
    void shouldFindActiveUsers() {
        repository.save(new User("Mario", true));
        repository.save(new User("Luigi", false));

        List<User> active = repository.findByActiveTrue();

        assertThat(active).hasSize(1);
        assertThat(active.get(0).getUsername()).isEqualTo("Mario");
    }
}
\end{lstlisting}

\section{3. Full Integration Test (@SpringBootTest)}
Qui si alza tutto: Database, Service, Controller, Security. Simula l'avvio reale dell'applicazione.

\begin{lstlisting}[language=Java]
// webEnvironment = RANDOM_PORT avvia un vero Tomcat su una porta casuale
// per evitare conflitti (es. porta 8080 occupata).
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class FullApplicationTest {

    @Autowired
    private TestRestTemplate restTemplate; // Client HTTP per fare chiamate reali

    @Test
    void flowCompleto() {
        ResponseEntity<String> response = restTemplate.getForEntity("/api/health", String.class);
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
    }
}
\end{lstlisting}

\section{Mocking: @Mock vs @MockBean}
Questa è la domanda da colloquio per eccellenza sui test Spring.

\begin{interview}{Differenza tra @Mock e @MockBean}
\textbf{Domanda:} Quando uso l'uno e quando l'altro?

\textbf{Risposta:}
\begin{itemize}
    \item \textbf{\texttt{@Mock} (org.mockito.Mock):} Fa parte di Mockito. Crea un oggetto finto. È scollegato da Spring. Si usa negli \textbf{Unit Test} puri.
    \item \textbf{\texttt{@MockBean} (org.springframework...):} Fa parte di Spring Boot.
    \begin{enumerate}
        \item Cerca quel Bean nell'\texttt{ApplicationContext}.
        \item Lo \textbf{rimuove} (o non lo carica).
        \item Lo \textbf{sostituisce} con un Mock.
    \end{enumerate}
    Si usa negli \textbf{Integration/Slice Test} (es. in \texttt{@WebMvcTest} devi "mockare" il Service perché non viene caricato).
\end{itemize}
\textbf{Attenzione:} Ogni volta che usi \texttt{@MockBean}, Spring "sporca" il contesto (Dirty Context). Se hai 100 test e ognuno usa un \texttt{@MockBean} diverso, Spring dovrà ricaricare l'applicazione 100 volte. Lento!
\end{interview}

\section{Modern Best Practice: Testcontainers}
Usare H2 (DB in memory) per i test e PostgreSQL in produzione è rischioso. H2 potrebbe accettare sintassi SQL che Postgres rifiuta (e viceversa).

\textbf{Testcontainers} è una libreria che avvia un vero Database Dockerizzato per la durata del test.

\begin{lstlisting}[language=Java, title={Integrazione con Testcontainers}]
@SpringBootTest
@Testcontainers // Richiede Docker installato sulla macchina
class PostgresIntegrationTest {

    // Avvia un container Postgres 15 reale
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

    // Sovrascrive le proprietà di connessione di Spring al volo
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private UserRepository repository;

    @Test
    void testSuVeroDB() {
        // Questo test gira su un vero Postgres pulito!
        repository.save(new User("Test"));
        assertThat(repository.count()).isEqualTo(1);
    }
}
\end{lstlisting}

\section{Riepilogo Strategia di Testing}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|c|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Tipo Test}} & \textcolor{white}{\textbf{Velocità}} & \textcolor{white}{\textbf{Cosa usare}} \\
    \hline
    \textbf{Logica di Business} & Altissima & Unit Test puro + Mockito (\texttt{@ExtendWith}) \\
    \hline
    \textbf{Controller / API} & Alta & \texttt{@WebMvcTest} + \texttt{@MockBean} (Service) \\
    \hline
    \textbf{Repository / Query} & Media & \texttt{@DataJpaTest} + Testcontainers \\
    \hline
    \textbf{End-to-End} & Bassa & \texttt{@SpringBootTest} + \texttt{TestRestTemplate} \\
    \hline
\end{tabularx}
\end{center}
% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Spring Profiles: Gestione degli Ambienti}

"Funziona sulla mia macchina". Quante volte abbiamo sentito questa frase?
Il codice è lo stesso, ma l'ambiente cambia:
\begin{itemize}
    \item \textbf{Dev:} Database H2 in memoria, log a livello DEBUG, mock dei servizi di pagamento.
    \item \textbf{Prod:} Database Oracle clusterizzato, log a livello ERROR, servizi di pagamento reali.
\end{itemize}

I \textbf{Spring Profiles} sono il meccanismo nativo per segregare parti della configurazione (e dei Bean) e attivarle solo in specifici ambienti.

\section{Come definire un Profilo}
Spring Boot usa una convenzione di nomenclatura basata sui suffissi dei file di configurazione.

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    file/.style={rectangle, draw=deepblue, fill=white, text width=3.5cm, align=left, font=\ttfamily\small, rounded corners},
    arrow/.style={->, >=stealth, thick, deepblue}
]

    \node[file] (default) {\textbf{application.yml}\\(Configurazione Base)\\server.port=8080};
    
    \node[file, below left=1cm of default] (dev) {\textbf{application-dev.yml}\\(Override Dev)\\logging.level=DEBUG};
    
    \node[file, below right=1cm of default] (prod) {\textbf{application-prod.yml}\\(Override Prod)\\logging.level=ERROR};

    \node[below=3cm of default, font=\bfseries] (runtime) {Runtime Merge};

    \draw[arrow] (default) -- (runtime);
    \draw[arrow, dashed] (dev) -- node[left, font=\scriptsize] {Se attivo 'dev'} (runtime);
    \draw[arrow, dashed] (prod) -- node[right, font=\scriptsize] {Se attivo 'prod'} (runtime);

\end{tikzpicture}
\end{center}

\subsection{La Regola dell'Override}
Spring carica \textbf{sempre} \texttt{application.properties} (o \texttt{.yml}).
Se un profilo è attivo (es. \texttt{dev}), carica \textbf{anche} \texttt{application-dev.properties}.
Le proprietà nel file specifico \textbf{sovrascrivono} quelle del file base.

\section{Attivazione dei Profili}
Come dico a Spring: "Oggi sei in Produzione"? Esistono 3 modi principali, in ordine di priorità.

\subsection{1. File di Configurazione (Hardcoded - Sconsigliato)}
Nel file \texttt{application.properties}:
\texttt{spring.profiles.active=dev}
Va bene solo per lo sviluppo locale. Se lo committi su Git, forzi tutti a usare quel profilo.

\subsection{2. JVM Argument (Build/CI)}
Passato al lancio del JAR. Vince su quello scritto nel file.
\begin{lstlisting}[language=bash]
java -jar -Dspring.profiles.active=prod my-app.jar
\end{lstlisting}

\subsection{3. Environment Variable (Cloud Native)}
La scelta obbligatoria per Docker e Kubernetes.
Definisci la variabile d'ambiente \texttt{SPRING\_PROFILES\_ACTIVE} nel container.
\begin{lstlisting}[language=bash]
export SPRING_PROFILES_ACTIVE=prod
\end{lstlisting}

\begin{interview}{Il Profilo "Default"}
\textbf{Domanda:} Cosa succede se non attivo nessun profilo?
\textbf{Risposta:} Spring attiva automaticamente un profilo chiamato \textbf{"default"}.
Se hai un file \texttt{application-default.properties}, verrà caricato.
È una best practice usare questo meccanismo per la configurazione di sviluppo locale "out-of-the-box", così il nuovo sviluppatore scarica il repo, preme "Run" e tutto funziona senza configurare nulla.
\end{interview}

\section{Bean Condizionali (@Profile)}
Non solo le proprietà, ma interi pezzi di codice (Bean) possono essere caricati o meno a seconda del profilo.

\textbf{Scenario:} In Dev voglio un Database in memoria (H2) che si popola con dati finti. In Prod voglio collegarmi a un vero PostgreSQL.

\begin{lstlisting}[language=Java, title={Configurazione Datasource Condizionale}]
@Configuration
public class DatabaseConfig {

    @Bean
    @Profile("dev") // Caricato SOLO se active=dev
    public DataSource h2DataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript("schema.sql")
            .addScript("mock-data.sql")
            .build();
    }

    @Bean
    @Profile("prod") // Caricato SOLO se active=prod
    public DataSource postgresDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(System.getenv("DB_URL")); // Mai hardcodare URL prod!
        return new HikariDataSource(config);
    }
}
\end{lstlisting}

\subsection{Logica Negativa (NOT)}
Puoi anche dire "Carica questo bean se NON siamo in produzione".
\begin{lstlisting}[language=Java]
@Service
@Profile("!prod") // Carica in dev, test, default... basta che non sia prod
public class MockEmailService implements EmailService { ... }
\end{lstlisting}

\section{Advanced: Profile Groups (Spring Boot 2.4+)}
Nei sistemi complessi, un solo profilo non basta.
Potresti avere:
\begin{itemize}
    \item \texttt{db-postgres} vs \texttt{db-mysql}
    \item \texttt{msg-kafka} vs \texttt{msg-rabbit}
    \item \texttt{metrics-prometheus} vs \texttt{metrics-datadog}
\end{itemize}

Attivare l'app con \texttt{-Dspring.profiles.active=prod,db-postgres,msg-kafka,metrics-datadog} è scomodo e prono a errori.

Spring Boot 2.4 ha introdotto i \textbf{Gruppi di Profili}.
Nel file base \texttt{application.yml}:

\begin{lstlisting}[language=bash]
spring:
  profiles:
    group:
      # Se attivo 'prod', attiva automaticamente anche questi sottoprofili
      prod: 
        - "db-postgres"
        - "msg-kafka"
        - "metrics-datadog"
      # Se attivo 'dev', attiva questi
      dev:
        - "db-h2"
        - "msg-mock"
\end{lstlisting}
Ora basta lanciare con \texttt{active=prod} e Spring si porta dietro tutto il pacchetto.

\section{Multi-Document YAML}
Un trucco "da Senior" per vedere tutte le configurazioni in un colpo d'occhio.
Invece di avere 5 file separati, puoi usare i separatori YAML \texttt{---} per definire profili diversi nello stesso file.

\begin{lstlisting}[language=bash, title={application.yml (Tutto in uno)}]
server:
  port: 8080 # Configurazione Default
spring:
  application:
    name: my-app
---
spring:
  config:
    activate:
      on-profile: dev # Sezione valida solo per DEV
server:
  port: 9090
logging:
  level:
    root: DEBUG
---
spring:
  config:
    activate:
      on-profile: prod # Sezione valida solo per PROD
server:
  port: 80
logging:
  level:
    root: WARN
\end{lstlisting}

\begin{deepdive}{Sicurezza e Profili}
\textbf{Mai committare le password di produzione nel file application-prod.yml!}
Anche se il file è "per la produzione", finisce nel Git.
\textbf{Best Practice:}
Nel file \texttt{application-prod.yml} metti dei segnaposto o riferimenti a variabili d'ambiente:
\texttt{spring.datasource.password=\$\{DB\_PASSWORD\}}
E inietta la password reale solo al momento del deploy (tramite Kubernetes Secrets o Vault).
\end{deepdive}


\part{Dev Ops}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------

\chapter{Git e Version Control per Team}

Saper usare \texttt{git add} e \texttt{git commit} è il minimo sindacale. In un colloquio per posizioni Backend, si aspettano che tu sappia come mantenere una history pulita, come risolvere conflitti complessi e quale strategia di branching adottare per la CI/CD.

\section{Merge vs Rebase: L'eterno dilemma}

Questa è la domanda numero uno su Git. Entrambi i comandi servono a integrare le modifiche di un branch in un altro, ma la filosofia cambia radicalmente.

\begin{interview}{Qual è la differenza tra Merge e Rebase e quando usarli?}
\begin{enumerate}
    \item \textbf{Git Merge (\texttt{git merge feature}):}
    \begin{itemize}
        \item Crea un nuovo "Merge Commit" che unisce le due storie.
        \item \textbf{Pro:} È "non distruttivo". Preserva la storia esatta (chi ha fatto cosa e quando), anche se disordinata.
        \item \textbf{Contro:} Se il team è grande, la history diventa un groviglio illeggibile ("spaghetti history") pieno di merge commit inutili.
    \end{itemize}
    
    \item \textbf{Git Rebase (\texttt{git rebase main}):}
    \begin{itemize}
        \item Prende i tuoi commit dal branch feature e li "riapplica" uno alla volta in cima al branch main, come se li avessi scritti adesso.
        \item \textbf{Pro:} Crea una history lineare e pulitissima. Facilita il debug (git bisect).
        \item \textbf{Contro:} Riscrive la storia (cambia gli hash dei commit).
    \end{itemize}
\end{enumerate}

\textbf{La Regola Aurea (The Golden Rule):}
Mai usare \texttt{rebase} su branch pubblici condivisi (es. \texttt{develop} o \texttt{main}). Se riscrivi la storia di un branch che altri hanno scaricato, creerai conflitti disastrosi per tutto il team. Usa rebase solo sul tuo branch locale \textit{prima} di fare push.
\end{interview}

\section{Gestione della Storia: Reset vs Revert}

Capire come annullare le modifiche distingue chi capisce Git da chi va nel panico.

\begin{itemize}
    \item \textbf{git reset (Hard/Soft):} Sposta il puntatore \texttt{HEAD} indietro nel tempo. È come se i commit successivi non fossero mai esistiti.
    \item \textbf{git revert:} Crea un \textbf{nuovo commit} che fa l'esatto opposto del commit che vuoi annullare.
\end{itemize}

\begin{deepdive}{Scenario: Hai pushato un bug in produzione. Cosa usi?}
Devi usare \textbf{\texttt{git revert}}.
Perché? Perché la history di produzione è sacra e condivisa. Se usassi \texttt{git reset} e forzassi il push (\texttt{push --force}), spaccheresti la history a tutti gli altri sviluppatori che hanno già scaricato quell'aggiornamento.
\texttt{Revert} è sicuro perché "aggiunge storia" invece di cancellarla.
\end{deepdive}

\section{Comandi Tattici: Stash, Cherry-Pick e Squash}

Strumenti essenziali per la vita quotidiana.

\subsection{Git Stash}
Sei a metà di una feature complessa ("lavoro sporco") e il capo ti chiede di fixare un bug urgente su un altro branch. Non puoi cambiare branch se hai modifiche non committate.
\begin{itemize}
    \item \texttt{git stash}: Salva le modifiche "in tasca" e pulisce la working directory.
    \item Cambi branch, fixi il bug, torni indietro.
    \item \texttt{git stash pop}: Recuperi le modifiche dalla tasca e continui a lavorare.
\end{itemize}

\subsection{Git Cherry-Pick}
Ti serve \textit{solo} un commit specifico da un altro branch, non tutto il branch.
Es: C'è un fix nel branch \texttt{release-2.0} che serve anche in \texttt{main}.
\texttt{git cherry-pick <commit-hash>} copia quel singolo commit nel tuo branch attuale.

\subsection{Squashing (Interactive Rebase)}
Prima di aprire una Pull Request, è buona norma unire i tuoi 10 commit di "wip", "fix typo", "fix again" in un unico commit pulito e significativo.
\texttt{git rebase -i HEAD\~5}.

\section{Workflow Aziendali: Git Flow vs Trunk-Based}

Non decidi tu come usare Git, lo decide l'architetto o il team leader. Devi conoscere i due modelli principali.

\begin{table}[h]
\centering
\begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
\hline
\textbf{Git Flow (Classico)} & \textbf{Trunk-Based Development (Moderno)} \\
\hline
Struttura rigida con branch lunghevi: \texttt{main}, \texttt{develop}, \texttt{feature/*}, \texttt{release/*}, \texttt{hotfix/*}. & Un unico branch principale (\texttt{main} o \texttt{trunk}). \\
\hline
Le feature vivono per giorni o settimane su branch separati prima del merge. & I developer pushano direttamente su main (o su short-lived branches) più volte al giorno. \\
\hline
Ottimo per software "a pacchetto" con versioni precise (v1.0, v1.1). & Essenziale per la \textbf{CI/CD} e i rilasci continui (Web App, SaaS). \\
\hline
\textbf{Rischio:} "Merge Hell" alla fine dello sprint. & \textbf{Requisito:} Test automatici forti e \textbf{Feature Flags} (per nascondere codice non finito in prod). \\
\hline
\end{tabular}
\end{table}

\begin{interview}{Perché le aziende tech preferiscono Trunk-Based?}
Git Flow ritarda l'integrazione. Se due sviluppatori lavorano su feature separate per 2 settimane, quando proveranno a unire il codice (Merge) avranno conflitti enormi.
Con Trunk-Based, l'integrazione è continua ("Continuous Integration"). I conflitti si risolvono subito quando sono piccoli.
\end{interview}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Docker per Java Developers}

Per vent'anni abbiamo spedito JAR o WAR. Oggi spediamo \textbf{Container}.
Docker risolve l'eterno problema: \textit{"Sulla mia macchina funzionava"}. Invece di chiedere al sistemista di installare Java 17, Tomcat e configurare le variabili d'ambiente, impacchettiamo tutto (OS ridotto + JVM + App) in una scatola standardizzata.

In questo capitolo vedremo come dockerizzare un'app Spring Boot seguendo le best practices di sicurezza e performance.

\section{Concetti Fondamentali: L'Analogia Java}
Se conosci Java, conosci già Docker. I concetti sono paralleli.

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Concetto Docker}} & \textcolor{white}{\textbf{Concetto Java}} & \textcolor{white}{\textbf{Spiegazione}} \\
    \hline
    \textbf{Dockerfile} & \texttt{MyClass.java} & Il codice sorgente/ricetta che descrive come costruire l'immagine. \\
    \hline
    \textbf{Image} & \texttt{MyClass.class} & Il template compilato, immutabile e statico. \\
    \hline
    \textbf{Container} & \texttt{new MyClass()} & L'istanza in esecuzione dell'immagine (Oggetto). Puoi averne N identiche. \\
    \hline
    \textbf{Registry} & Maven Repo & Dove carichi e scarichi le immagini (es. Docker Hub). \\
    \hline
\end{tabularx}
\end{center}

\section{Il Primo Dockerfile (Naive Approach)}
Il \texttt{Dockerfile} è un file di testo (senza estensione) nella root del progetto.
Ecco l'approccio base (funzionante, ma non ottimizzato).

\begin{lstlisting}[language=bash, title={Dockerfile Base}]
# 1. Partiamo da una base con Linux + Java 17
FROM eclipse-temurin:17-jdk-alpine

# 2. Creiamo una directory di lavoro
WORKDIR /app

# 3. Copiamo il JAR compilato (dal target di Maven) dentro l'immagine
# Nota: Devi aver fatto 'mvn package' prima sulla tua macchina!
COPY target/my-app-1.0.0.jar app.jar

# 4. Esponiamo la porta (solo documentazione)
EXPOSE 8080

# 5. Comando di avvio
ENTRYPOINT ["java", "-jar", "app.jar"]
\end{lstlisting}

\begin{interview}{JDK vs JRE in Docker}
\textbf{Domanda:} Perché in produzione dovresti usare una JRE invece del JDK?
\textbf{Risposta:} Il JDK contiene compilatore (\texttt{javac}) e tool di debug. In produzione non servono. Usare una JRE (o un'immagine \textit{distroless}) riduce la dimensione dell'immagine (risparmio banda/disco) e riduce la superficie di attacco per gli hacker (meno tool disponibili nel container).
\end{interview}

\section{Multi-Stage Build: L'Approccio Senior}
Il Dockerfile sopra ha un difetto: ti obbliga ad avere Maven installato sulla tua macchina per generare il JAR.
L'approccio \textbf{Multi-Stage} usa Docker anche per compilare.

\begin{center}
\begin{tikzpicture}[
    node distance=3cm, auto, thick,
    stage/.style={rectangle, draw=deepblue, fill=white, text width=3.5cm, align=center, minimum height=2cm, rounded corners},
    final/.style={rectangle, draw=javagreen, fill=javagreen!10, text width=3.5cm, align=center, minimum height=2cm, rounded corners},
    arrow/.style={->, >=stealth, thick, deepblue}
]

    \node[stage] (build) {\textbf{Stage 1: BUILD}\\Immagine Maven\\(Pesante: 800MB)\\Compila il codice};
    
    \node[final, right=3cm of build] (run) {\textbf{Stage 2: RUN}\\Immagine JRE Alpine\\(Leggera: 100MB)\\Esegue il JAR};

    \draw[arrow] (build) -- node[above, font=\scriptsize] {COPY --from=build} node[below, font=\scriptsize] {Solo il JAR} (run);

\end{tikzpicture}
\end{center}

\begin{lstlisting}[language=bash, title={Dockerfile Ottimizzato (Multi-Stage)}]
# --- STAGE 1: Build ---
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app

# Copia solo il pom per scaricare le dipendenze (Layer Caching!)
COPY pom.xml .
RUN mvn dependency:go-offline

# Copia il codice e compila
COPY src ./src
RUN mvn clean package -DskipTests

# --- STAGE 2: Runtime ---
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# Copia SOLO il JAR dallo Stage 1
COPY --from=build /app/target/*.jar app.jar

ENTRYPOINT ["java", "-jar", "app.jar"]
\end{lstlisting}

\begin{deepdive}{Il Layer Caching}
Docker costruisce l'immagine a strati. Se non cambi una riga, Docker riusa lo strato cachato.
Perché copiamo prima \texttt{pom.xml} e poi \texttt{src}?
Perché il codice sorgente cambia spesso, le dipendenze Maven raramente.
Se cambi una riga di codice Java, Docker invalida la cache dal \texttt{COPY src} in poi, ma riusa il layer dove ha scaricato "Mezzo Internet" (le dipendenze Maven). Build ultra-veloci!
\end{deepdive}

\section{Docker Compose: Orchestrazione Locale}
Un'app Java raramente gira da sola. Ha bisogno di un Database (Postgres) o di Redis.
Installare Postgres sul tuo PC è noioso. Usiamo \textbf{Docker Compose}.

File: \texttt{docker-compose.yml}

\begin{lstlisting}[language=bash]
version: '3.8'
services:
  # La nostra App Spring Boot
  backend:
    build: . # Usa il Dockerfile nella cartella corrente
    ports:
      - "8080:8080"
    environment:
      - SPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/mydb
      - SPRING_DATASOURCE_USERNAME=user
      - SPRING_DATASOURCE_PASSWORD=pass
    depends_on:
      - db

  # Il Database
  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=mydb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    ports:
      - "5432:5432"
\end{lstlisting}

\begin{interview}{Networking in Docker Compose}
\textbf{Domanda:} Come fa l'app Java a connettersi al DB? Cosa metto al posto di "localhost"?
\textbf{Risposta:} In Docker Compose, ogni servizio è raggiungibile tramite il suo \textbf{nome del servizio} come hostname.
Nel \texttt{SPRING\_DATASOURCE\_URL}, usiamo \texttt{jdbc:postgresql://\textbf{db}:5432/...} perché il servizio nel file yaml si chiama \texttt{db}. "Localhost" dentro un container si riferisce al container stesso, non al tuo PC!
\end{interview}

\section{JVM e Container: La Memoria}
Fino a Java 8 (update 191), la JVM non sapeva di essere in un container. Vedeva la RAM totale del Server (es. 64GB) e cercava di prenderne gran parte, venendo uccisa dal Docker OOM Killer (Out Of Memory) se il container aveva un limite di 1GB.

Da Java 10+ (e backportato su 8), la JVM è \textbf{Container Aware}.

\textbf{Best Practice:}
Non impostare \texttt{-Xmx} fisso (es. \texttt{-Xmx512m}) nel Dockerfile. Usa le percentuali.

\begin{lstlisting}[language=bash]
# Nel Dockerfile o Runtime
ENTRYPOINT ["java", "-XX:MaxRAMPercentage=75.0", "-jar", "app.jar"]
\end{lstlisting}
Questo dice alla JVM: "Usa al massimo il 75\% della RAM assegnata al Container". Se alzi il limite del container in Kubernetes, la JVM si adatta automaticamente.

\section{Comandi Essenziali (Cheat Sheet)}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Comando}} & \textcolor{white}{\textbf{Azione}} \\
    \hline
    \texttt{docker build -t my-app .} & Costruisce l'immagine dal Dockerfile corrente. \\
    \hline
    \texttt{docker run -p 8080:8080 my-app} & Avvia il container mappando la porta (Host:Container). \\
    \hline
    \texttt{docker ps} & Lista i container attivi. \\
    \hline
    \texttt{docker logs -f <container\_id>} & Guarda i log (il System.out.println) in tempo reale. \\
    \hline
    \texttt{docker-compose up -d} & Avvia tutto lo stack (DB + App) in background. \\
    \hline
    \texttt{docker-compose down} & Ferma e rimuove tutto (Network e Container). \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Kubernetes per Java Developers}

Docker ha risolto il problema del packaging ("Funziona sulla mia macchina"). Ma in produzione non hai un container, ne hai cento. Chi li riavvia se crashano? Chi scala se il traffico aumenta? Chi gestisce le password?

\textbf{Kubernetes (K8s)} è l'orchestratore. Immaginalo come il sistema operativo del Data Center.
Per un Java Developer, K8s non è solo "infrastruttura": cambia il modo in cui gestiamo la configurazione, i log e lo stato dell'applicazione.

\section{Architettura: L'Analogia Java}
Per capire K8s, usiamo i concetti che già conosciamo.

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Oggetto K8s}} & \textcolor{white}{\textbf{Concetto Java}} & \textcolor{white}{\textbf{Spiegazione}} \\
    \hline
    \textbf{Pod} & \texttt{Thread} & L'unità minima di esecuzione. Effimero, mortale. \\
    \hline
    \textbf{Deployment} & \texttt{ExecutorService} & Gestisce il ciclo di vita dei Pod (quanti ne voglio, come aggiornarli). \\
    \hline
    \textbf{Service} & \texttt{Interface/Proxy} & Un indirizzo stabile (DNS) per parlare con un gruppo di Pod dinamici. \\
    \hline
    \textbf{ConfigMap} & \texttt{Properties File} & Configurazione iniettata dall'esterno. \\
    \hline
    \textbf{Ingress} & \texttt{DispatcherServlet} & Il punto di ingresso HTTP che smista il traffico. \\
    \hline
\end{tabularx}
\end{center}

\section{Il Pod: L'Atomo di K8s}
Docker esegue container. Kubernetes esegue \textbf{Pod}.
Un Pod è un "guscio" che contiene uno o più container (solitamente uno, la tua app Spring Boot).

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    pod/.style={rectangle, draw=deepblue, thick, fill=white, minimum width=4cm, minimum height=2.5cm, rounded corners},
    container/.style={rectangle, draw=javagreen, fill=javagreen!10, minimum width=2.5cm, minimum height=1cm, rounded corners},
    label/.style={font=\bfseries\small, text=deepblue}
]
    \node[pod] (p) {};
    \node[label, above] at (p.north) {POD (IP: 10.244.0.5)};
    
    \node[container] (app) at (p.center) {Spring Boot App};
    \node[container, below=0.2cm of app, fill=gray!20, draw=gray] (sidecar) {Log Agent (Sidecar)};
    
    \node[below=0.5cm of p, font=\scriptsize, align=center] {Condividono: Localhost, Volumi, IP};

\end{tikzpicture}
\end{center}

\begin{interview}{Pod vs Container}
\textbf{Domanda:} Perché K8s usa i Pod e non direttamente i Container?
\textbf{Risposta:} Per permettere il pattern \textbf{Sidecar}.
A volte l'applicazione principale ha bisogno di un "aiutante" (es. un proxy per i log, o un gestore di certificati). In un Pod, questi due container vivono insieme, condividono lo stesso indirizzo IP e possono parlarsi su \texttt{localhost}.
\end{interview}

\section{Il Deployment: Scalabilità e Resilienza}
Tu non crei mai un Pod manualmente. Crei un \textbf{Deployment}.
Il Deployment è una dichiarazione di stato desiderato: \textit{"Voglio 3 repliche della mia app"}.

\begin{lstlisting}[language=bash, title={deployment.yaml}]
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-java-app
spec:
  replicas: 3 # Desired State
  selector:
    matchLabels:
      app: backend
  template: # Il modello del Pod
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: java-app
        image: my-registry/app:v1
        ports:
        - containerPort: 8080
\end{lstlisting}

\subsection{Self-Healing (Auto-Guarigione)}
Se la tua app Java crasha (OutOfMemoryError) e il processo termina, K8s se ne accorge. Il Deployment vede che ci sono solo 2 repliche invece di 3 e ne avvia istantaneamente una nuova.

\section{Service: Networking Stabile}
I Pod sono mortali. Ogni volta che un Pod muore e rinasce, \textbf{il suo indirizzo IP cambia}.
Come fa il Frontend a chiamare il Backend se l'IP cambia sempre?

Il \textbf{Service} è un'astrazione che fornisce un IP e un DNS stabili.

\begin{center}
\begin{tikzpicture}[
    node distance=2cm, auto, thick,
    pod/.style={circle, draw=deepblue, fill=white, minimum size=1cm, align=center, font=\scriptsize},
    svc/.style={rectangle, draw=intervieworange, fill=intervieworange!10, minimum width=6cm, minimum height=1cm, rounded corners, align=center},
    client/.style={rectangle, draw=black, fill=gray!10, minimum width=2cm, minimum height=1cm, align=center}
]

    % Service Layer
    \node[svc] (service) {\textbf{Service (ClusterIP)}\\DNS: my-app.svc.local};

    % Pods
    \node[pod, below left=1cm of service] (p1) {Pod 1\\(10.1.0.1)};
    \node[pod, below=1cm of service] (p2) {Pod 2\\(10.1.0.2)};
    \node[pod, below right=1cm of service] (p3) {Pod 3\\(10.1.0.3)};

    % Client
    \node[client, above=1.5cm of service] (fe) {Frontend};

    % Arrows
    \draw[->] (fe) -- node[right, font=\scriptsize] {chiama DNS} (service);
    \draw[->, dashed] (service) -- (p1);
    \draw[->, dashed] (service) -- (p2);
    \draw[->, dashed] (service) -- (p3);

\end{tikzpicture}
\end{center}

\textbf{Nota:} Il Service fa anche da \textbf{Load Balancer} interno, distribuendo le richieste tra i Pod disponibili.

\section{Configurazione: ConfigMap e Secrets}
Mai mettere il file \texttt{application.properties} dentro l'immagine Docker!
K8s ci permette di iniettare la configurazione dall'esterno.

\begin{enumerate}
    \item \textbf{ConfigMap:} Per dati non sensibili (URL DB, Log Level).
    \item \textbf{Secret:} Per password e certificati (codificati in Base64).
\end{enumerate}

\begin{lstlisting}[language=bash, title={Iniettare Env Vars in Spring}]
env:
  - name: SPRING_DATASOURCE_URL
    valueFrom:
      configMapKeyRef:
        name: db-config
        key: db.url
  - name: SPRING_DATASOURCE_PASSWORD
    valueFrom:
      secretKeyRef:
        name: db-secret
        key: db.password
\end{lstlisting}
Spring Boot converte automaticamente le variabili d'ambiente maiuscole (\texttt{SPRING\_DATASOURCE\_URL}) nelle proprietà Java (\texttt{spring.datasource.url}).

\section{JVM in Kubernetes: Memory Limits \& OOM}
Questa è la causa \#1 dei crash in produzione.

In K8s definisci due parametri per la memoria:
\begin{itemize}
    \item \textbf{Request:} La memoria garantita all'avvio.
    \item \textbf{Limit:} Il tetto massimo. Se lo superi, K8s uccide il container (\textbf{OOMKilled}).
\end{itemize}

\begin{deepdive}{Il problema della Heap non visibile}
Se imposti il limite del container a 1GB, ma non configuri la JVM, Java potrebbe cercare di allocare più memoria (vedendo la RAM totale del nodo).
\textbf{Soluzione:}
Devi dire alla JVM di guardare i limiti del container.
\begin{lstlisting}[language=bash]
# Nel Dockerfile o nel Deployment
java -XX:MaxRAMPercentage=75.0 -jar app.jar
\end{lstlisting}
Questo lascia il 25\% di spazio per il Metaspace e l'overhead del container, evitando il temuto OOMKilled.
\end{deepdive}

\section{Liveness e Readiness Probes (Spring Actuator)}
K8s deve sapere se la tua app è viva. Non basta che il processo PID esista (potrebbe essere in deadlock).

Spring Boot Actuator fornisce gli endpoint perfetti per questo.

\begin{lstlisting}[language=bash, title={Deployment configuration}]
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 15 # Dai tempo a Spring di partire!
  
readinessProbe:
  httpGet:
    path: /actuator/health/readiness
    port: 8080
\end{lstlisting}

\begin{interview}{Liveness vs Readiness}
\textbf{Domanda:} Qual è la differenza?
\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Liveness (Riavvia):} "Sono vivo?". Se fallisce, K8s riavvia il Pod. (Es. Deadlock, stato corrotto irrecuperabile).
    \item \textbf{Readiness (Non mandare traffico):} "Sono pronto a lavorare?". Se fallisce, K8s smette di mandare traffico a questo Pod, ma \textbf{non} lo riavvia. (Es. il DB è temporaneamente lento, o l'app si sta ancora avviando).
\end{itemize}
\end{interview}

\section{Graceful Shutdown}
Quando K8s spegne un Pod (scaling down o rolling update), invia un segnale \texttt{SIGTERM}.
Se l'app si spegne di colpo, le transazioni in corso falliscono.

In \texttt{application.properties}:
\begin{lstlisting}[language=bash]
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=20s
\end{lstlisting}
Spring Boot smetterà di accettare nuove richieste, finirà quelle in corso e poi si spegnerà.

\section{Riepilogo Best Practices}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Area}} & \textcolor{white}{\textbf{Best Practice}} \\
    \hline
    \textbf{Memoria} & Usa sempre \texttt{-XX:MaxRAMPercentage}. Imposta Request e Limit nel YAML. \\
    \hline
    \textbf{Observability} & Abilita \textbf{Spring Actuator} e configura Liveness/Readiness Probes. \\
    \hline
    \textbf{Config} & Usa ConfigMap e Secrets. Non buildare configurazione nell'immagine. \\
    \hline
    \textbf{Logs} & Scrivi solo su \texttt{System.out} (Console). K8s raccoglierà i log (non usare file su disco). \\
    \hline
    \textbf{Startup} & Spring può essere lento. Configura \texttt{initialDelaySeconds} abbondante nei Probe per evitare "Kill loop" all'avvio. \\
    \hline
\end{tabularx}
\end{center}



\part{Microservizi e Cloud}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Monolite vs Microservizi: Scelte Architetturali}

"Dobbiamo riscrivere tutto in Microservizi".
Questa frase ha ucciso più progetti aziendali di qualsiasi bug.

Passare da un'architettura Monolitica a una a Microservizi non è un aggiornamento tecnico (come passare da Java 11 a 17). È un cambio di paradigma che sposta la complessità dal \textbf{Codice} all'\textbf{Infrastruttura}.

In questo capitolo analizzeremo le differenze, i costi nascosti e quando ha senso fare il grande salto.

\section{Il Monolite Modulare (The Majestic Monolith)}
Un'applicazione monolitica è un'unica unità di deployment (un singolo WAR/JAR).
Tutta la logica (Utenti, Ordini, Pagamenti) vive nello stesso processo di memoria.

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    layer/.style={rectangle, draw=deepblue, fill=white, text width=6cm, align=center, minimum height=1cm},
    db/.style={cylinder, draw=black, aspect=0.25, fill=gray!20, minimum height=1.5cm, minimum width=2cm, shape border rotate=90, align=center}
]

    \node[layer, fill=intervieworange!10] (ui) {\textbf{Presentation Layer}\\(Controllers / API)};
    \node[layer, below=0.5cm of ui] (business) {\textbf{Business Layer}\\(UserService, OrderService)};
    \node[layer, below=0.5cm of business] (data) {\textbf{Data Access Layer}\\(Repositories / Hibernate)};
    
    \node[db, below=1cm of data] (database) {\textbf{Single Shared DB}\\(Foreign Keys, JOINs)};

    \draw[->] (ui) -- (business);
    \draw[->] (business) -- (data);
    \draw[->] (data) -- (database);

\end{tikzpicture}
\end{center}

\subsection{I Vantaggi del Monolite}
Non sottovalutarlo. Stack Overflow e Shopify sono partiti (e in gran parte rimasti) monoliti.
\begin{itemize}
    \item \textbf{Semplicità:} Un solo repo git, una sola pipeline CI/CD.
    \item \textbf{Transazioni ACID:} Puoi salvare l'Ordine e scalare i Soldi in un'unica transazione atomica \texttt{@Transactional}. O tutto o niente.
    \item \textbf{Performance:} Le chiamate tra servizi sono chiamate a metodo in memoria (nanosecondi), non chiamate di rete (millisecondi).
    \item \textbf{Refactoring:} Spostare una classe da un package all'altro è banale.
\end{itemize}

\subsection{I Problemi (The Big Ball of Mud)}
Quando il team cresce da 5 a 50 sviluppatori:
\begin{itemize}
    \item \textbf{Coupling:} Tutto è collegato. Cambiare una riga nel modulo Fatturazione può rompere il modulo Utenti.
    \item \textbf{Scaling:} Se il modulo "Reportistica" consuma tutta la RAM, devi replicare l'intero server (anche la parte login che è leggera), sprecando risorse.
    \item \textbf{Technology Lock-in:} Sei bloccato su Java 8? Aggiornare l'intero monolite è un rischio enorme.
\end{itemize}

\section{Microservizi: Sistemi Distribuiti}
Nei microservizi, l'applicazione è divisa in piccoli servizi indipendenti, ognuno con il proprio processo, il proprio database e il proprio ciclo di vita.

\begin{center}
\begin{tikzpicture}[
    node distance=1cm, auto, thick,
    svc/.style={rectangle, draw=deepblue, fill=white, minimum width=2.5cm, minimum height=1.5cm, rounded corners, align=center},
    db/.style={cylinder, draw=black, aspect=0.25, fill=gray!20, minimum height=1cm, minimum width=1cm, shape border rotate=90, align=center, font=\scriptsize}
]

    % Service A
    \node[svc] (svcA) {Order\\Service};
    \node[db, below=0.5cm of svcA] (dbA) {Order DB};
    \draw[->] (svcA) -- (dbA);

    % Service B
    \node[svc, right=2cm of svcA] (svcB) {User\\Service};
    \node[db, below=0.5cm of svcB] (dbB) {User DB};
    \draw[->] (svcB) -- (dbB);

    % Network
    \draw[<->, dashed, red] (svcA) -- node[above, font=\scriptsize] {REST / gRPC} node[below, font=\scriptsize] {(Network Call)} (svcB);

\end{tikzpicture}
\end{center}

\subsection{Database per Service}
Questa è la regola d'oro (e la più difficile).
\textbf{Ogni microservizio deve possedere il proprio database privato.}
Nessuno può leggere le tabelle degli ordini tranne l'\texttt{OrderService}.

\begin{interview}{Perché non condividere il DB?}
\textbf{Domanda:} Perché non posso collegare tutti i microservizi a un unico Database Oracle gigante?
\textbf{Risposta:} Creeresti un \textbf{Monolite Distribuito}.
Se due servizi condividono le tabelle, sono accoppiati. Se l'\texttt{OrderService} cambia lo schema della tabella, il \texttt{ReportService} si rompe.
L'obiettivo dei microservizi è l'\textbf{Independent Deployability}: poter rilasciare una nuova versione di un servizio senza chiedere il permesso agli altri team.
\end{interview}

\section{Il Prezzo da Pagare (Trade-offs)}
Non è tutto oro quel che luccica.

\begin{enumerate}
    \item \textbf{Transazioni Distribuite:} Non esiste più \texttt{@Transactional} tra servizi.
    Se l'ordine viene creato ma il pagamento fallisce (su un altro servizio), devi gestire il rollback manualmente (Pattern SAGA / Compensazione).
    \item \textbf{Latenza di Rete:} Una chiamata locale richiede nanosecondi. Una chiamata HTTP richiede millisecondi ed è fallibile (timeout, rete giù).
    \item \textbf{Eventual Consistency:} I dati non sono aggiornati istantaneamente ovunque. L'utente potrebbe vedere dati vecchi per qualche secondo.
    \item \textbf{Operational Complexity:} Hai bisogno di Kubernetes, Docker, Distributed Tracing (Zipkin/Micrometer), API Gateway, Service Mesh.
\end{enumerate}

\section{Quando migrare? (The Complexity Graph)}
Martin Fowler, uno dei padri dell'architettura software, ha disegnato un grafico famoso.

\begin{deepdive}{Produttività vs Complessità}
\begin{itemize}
    \item Per sistemi semplici/medi, il \textbf{Monolite} è infinitamente più produttivo.
    \item Solo quando la complessità del sistema diventa ingestibile per un singolo team, i \textbf{Microservizi} (nonostante il loro overhead iniziale) permettono di continuare a scalare la produttività.
\end{itemize}
\textbf{Senior Tip:} Se sei una startup o un team piccolo, parti col Monolite Modulare. Non partire coi Microservizi.
\end{deepdive}

\section{Strategie di Migrazione: Strangler Fig Pattern}
Come si mangia un elefante (Monolite)? Un morso alla volta.
Mai riscrivere tutto da zero (The Big Bang Rewrite è un suicidio).

Il pattern \textbf{Strangler Fig} (Fico Strangolatore) suggerisce di:
\begin{enumerate}
    \item Mettere un API Gateway davanti al monolite.
    \item Identificare una funzionalità isolata (es. "Notifiche").
    \item Scrivere un nuovo Microservizio per le Notifiche.
    \item Configurare l'API Gateway per girare le chiamate \texttt{/api/notifications} al nuovo servizio e tutto il resto al vecchio monolite.
    \item Ripetere finché il monolite non scompare (o diventa molto piccolo).
\end{enumerate}

\section{Tabella Riassuntiva Definitiva}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Aspetto}} & \textcolor{white}{\textbf{Monolite}} & \textcolor{white}{\textbf{Microservizi}} \\
    \hline
    \textbf{Deployment} & Semplice (1 file), ma rischioso (tutto o niente). & Complesso (Orchestrazione K8s), ma granulare. \\
    \hline
    \textbf{Database} & Condiviso, ACID garantito. & Separato per servizio, Eventual Consistency. \\
    \hline
    \textbf{Scalabilità} & Verticale (Server più potente) o Orizzontale (Replica intera app). & Granulare (Scalo solo il servizio che serve). \\
    \hline
    \textbf{Debug} & Facile (Stacktrace locale). & Difficile (Log distribuiti, Tracing ID). \\
    \hline
    \textbf{Comunicazione} & Metodi Java (Veloce). & REST/gRPC/Kafka (Lento, Fallibile). \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Advanced Messaging: Apache Kafka}

"Se RabbitMQ è una cassetta delle lettere (il messaggio sparisce dopo che lo leggi), Kafka è una biblioteca (il libro resta lì, tu tieni il segno della pagina)."

Apache Kafka non è un Message Broker tradizionale. È una \textbf{Piattaforma di Streaming Eventi}.
È progettato per gestire milioni di messaggi al secondo, persistendoli su disco in modo duraturo.

\section{Architettura: Log, non Code}
In una coda JMS classica, il messaggio viene rimosso dopo il consumo.
In Kafka, il messaggio è \textbf{immutabile} e viene appeso alla fine di un \textbf{Log}. Resta lì per giorni (retention policy), permettendo a diversi consumer di leggerlo in momenti diversi.

\subsection{Anatomia di un Topic}
Un \textbf{Topic} è una categoria logica (es. "ordini-creati").
Per scalare, un Topic è diviso in \textbf{Partizioni}.

\begin{center}
\begin{tikzpicture}[
    node distance=1cm, auto, thick,
    msg/.style={rectangle, draw=deepblue, fill=white, minimum width=1cm, minimum height=1cm, align=center, font=\scriptsize},
    part/.style={rectangle, draw=black, fill=gray!10, minimum width=8cm, minimum height=4cm, align=center, font=\small},
    arrow/.style={->, >=stealth, thick}
]

    % Partition 0
    \node[part] (p0) at (0, 2.5) {\textbf{Partition 0}};

    % Messaggi allineati
    \node[msg, fill=javagreen!20] (m0) at (-3,0) {Off\\0};
    \node[msg, fill=javagreen!20] (m1) at (-1,0) {Off\\1};
    \node[msg, fill=javagreen!20] (m2) at (1,0) {Off\\2};
    \node[msg, draw=black, dashed, fill=white] (new) at (3,0) {New};

    % Frecce
    \draw[arrow] (new) -- node[above, font=\tiny] {Write} (m2);

    % Nota
    \node[font=\scriptsize, right=3.5cm of p0] {Il Producer scrive sempre in coda};

\end{tikzpicture}
\end{center}

\begin{itemize}
    \item \textbf{Partition:} L'unità di parallelismo. I dati dentro una partizione sono \textbf{Ordinati}.
    \item \textbf{Offset:} Un numero sequenziale (ID) che identifica univocamente un messaggio nella partizione.
    \item \textbf{Immutabilità:} Una volta scritto, un messaggio non cambia e non si cancella (fino alla scadenza della retention).
\end{itemize}

\section{Consumer Groups: La Magia dello Scaling}
Come facciamo a leggere velocemente se arrivano 1000 messaggi al secondo?
Non possiamo avere un solo consumer.

Kafka introduce il \textbf{Consumer Group}.
Un gruppo di applicazioni che collaborano per leggere un Topic. Kafka assegna automaticamente le partizioni ai membri del gruppo.

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    % Topic e Partizioni
    topic/.style={rectangle, draw=black, fill=gray!5, minimum width=2cm, minimum height=3cm, align=center},
    part/.style={rectangle, draw=deepblue, fill=white, minimum width=1.5cm, minimum height=0.6cm, align=center, font=\scriptsize},
    % Consumers
    cons/.style={circle, draw=intervieworange, fill=intervieworange!10, minimum size=1.2cm, align=center, font=\scriptsize},
    arrow/.style={->, >=stealth, thick, dashed}
]

    % Topic Box
    \node[topic] (t) {};
    \node[above] at (t.north) {\textbf{Topic A}};
    
    % Partitions inside Topic
    \node[part] (p0) at (t.center) [yshift=1cm] {Part 0};
    \node[part] (p1) at (t.center) [yshift=0cm] {Part 1};
    \node[part] (p2) at (t.center) [yshift=-1cm] {Part 2};

    % Consumers
    \node[cons, right=3cm of p0] (c1) {App\\A};
    \node[cons, right=3cm of p2] (c2) {App\\B};
    
    % Group Label
    \node[draw=intervieworange, fit=(c1) (c2), inner sep=0.5cm, label=above:\textcolor{intervieworange}{\textbf{Consumer Group 1}}] {};

    % Mapping
    \draw[arrow] (c1) -- (p0);
    \draw[arrow] (c1) -- (p1);
    \draw[arrow] (c2) -- (p2);

\end{tikzpicture}
\end{center}

\begin{deepdive}{La Regola d'Oro dello Scaling}
\textbf{1 Partizione = Max 1 Consumer (dello stesso gruppo).}
Se hai 3 partizioni e avvii 4 istanze della tua applicazione (Consumer), la quarta istanza rimarrà \textbf{Idle} (inattiva). Non riceverà messaggi.
Se vuoi più parallelismo, devi aumentare il numero di partizioni del Topic (non solo il numero di consumer).
\end{deepdive}

\section{Spring Boot e Kafka}
Spring fornisce \texttt{spring-kafka}, un'astrazione potente che gestisce la connessione e la deserializzazione.

\subsection{Il Producer (KafkaTemplate)}
Inviare messaggi è semplice. Ricorda che è un'operazione asincrona.

\begin{lstlisting}[language=Java]
@Service
@RequiredArgsConstructor
public class OrderProducer {

    private final KafkaTemplate<String, OrderDTO> kafkaTemplate;

    public void sendOrder(OrderDTO order) {
        // Topic, Key (per ordinamento), Value
        // La Key è fondamentale: messaggi con la stessa Key finiscono
        // nella stessa partizione (garantendo l'ordine).
        kafkaTemplate.send("ordini-topic", order.getOrderId(), order);
    }
}
\end{lstlisting}

\subsection{Il Consumer (@KafkaListener)}
Spring gestisce il polling e il commit degli offset per te.

\begin{lstlisting}[language=Java]
@Service
public class OrderConsumer {

    @KafkaListener(
        topics = "ordini-topic", 
        groupId = "gestione-magazzino-group",
        concurrency = "3" // Avvia 3 thread (come avere 3 consumer)
    )
    public void processOrder(OrderDTO order, Acknowledgment ack) {
        try {
            log.info("Ricevuto ordine: {}", order);
            warehouseService.reserveStock(order);
            
            // Commit manuale (se configurato)
            ack.acknowledge(); 
        } catch (Exception e) {
            log.error("Errore processamento", e);
            // Non fare ack -> il messaggio verrà riletto (o andrà in DLQ)
        }
    }
}
\end{lstlisting}

\section{Reliability: Non perdere dati}
Kafka è configurabile. Puoi scegliere tra velocità e sicurezza.

\subsection{Producer Acks}
Quando il producer considera il messaggio "inviato"?
\begin{itemize}
    \item \textbf{acks=0 (Fire \& Forget):} Invia e non aspetta risposta. Velocissimo, rischio perdita dati altissimo.
    \item \textbf{acks=1 (Leader):} Aspetta che il Broker Leader l'abbia scritto su disco. Compromesso standard.
    \item \textbf{acks=all (Strongest):} Aspetta che il Leader E tutte le Repliche l'abbiano scritto. Lento ma sicurissimo.
\end{itemize}

\subsection{Consumer Semantics}
\begin{itemize}
    \item \textbf{At-most-once:} Leggi, fai commit dell'offset, poi processi. Se crashi durante il processamento, il messaggio è perso.
    \item \textbf{At-least-once (Default):} Leggi, processi, poi fai commit. Se crashi prima del commit, al riavvio rileggi lo stesso messaggio.
    \textbf{Implicazione:} Il tuo codice deve essere \textbf{Idempotente} (gestire duplicati).
\end{itemize}

\section{Interview Questions}

\begin{interview}{Ordering Guarantee}
\textbf{Domanda:} Kafka garantisce l'ordine totale dei messaggi?
\textbf{Risposta:} \textbf{NO.}
Kafka garantisce l'ordine \textbf{solo all'interno di una partizione}.
Se invii l'ordine A e l'ordine B su partizioni diverse, il consumer potrebbe leggere B prima di A.
Se l'ordine è vitale (es. "Crea Utente" prima di "Attiva Utente"), devi assicurarti che entrambi i messaggi abbiano la stessa \textbf{Message Key} (es. l'ID utente). Stessa chiave = Stessa partizione.
\end{interview}

\begin{interview}{Kafka vs RabbitMQ}
\textbf{Domanda:} Quando scegliere l'uno o l'altro?
\textbf{Risposta:}
\begin{itemize}
    \item \textbf{RabbitMQ:} Smart Broker, Dumb Consumer. Ottimo per routing complesso, priority queues, e quando vuoi cancellare il messaggio dopo l'uso.
    \item \textbf{Kafka:} Dumb Broker, Smart Consumer. Ottimo per throughput enormi, replay dei dati (riavvolgere il nastro), event sourcing e analytics.
\end{itemize}
\end{interview}

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Concetto}} & \textcolor{white}{\textbf{Dettaglio}} \\
    \hline
    \textbf{Topic} & Flusso di dati logico. Diviso in Partizioni fisiche. \\
    \hline
    \textbf{Offset} & Puntatore di lettura. Il Consumer Group ricorda "dove era arrivato". \\
    \hline
    \textbf{Retention} & I dati non si cancellano dopo la lettura. Si cancellano per tempo (es. 7 giorni) o dimensione. \\
    \hline
    \textbf{Key} & Fondamentale per l'ordine. Messaggi con stessa chiave vanno nella stessa partizione. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Cloud Native Development e Patterns}

"Cloud Native non riguarda \textit{dove} gira la tua applicazione, ma \textit{come} gira."

Un'applicazione Java tradizionale (Legacy) è come un animale domestico (\textbf{Pet}): le diamo un nome (server-01), la curiamo quando sta male e se muore è una tragedia.
Un'applicazione Cloud Native è bestiame (\textbf{Cattle}): sono tutte uguali, numerate, e se una muore viene sostituita immediatamente da una nuova senza che nessuno pianga.

Per scrivere codice "Cattle-ready", dobbiamo seguire la metodologia \textbf{12-Factor App} e implementare pattern di resilienza.

\section{I 12-Factor App (Java Edition)}
Di 12 fattori, 4 sono critici per uno sviluppatore Java. Se ne violi uno, la tua app non scalerà su Kubernetes.

\subsection{1. Configurazione (Factor III)}
\textbf{Regola:} Mai salvare la configurazione nel codice o nel pacchetto (WAR).
La configurazione deve venire dall'\textbf{Ambiente}.

\begin{itemize}
    \item \textbf{Legacy:} File \texttt{config.properties} dentro il JAR. Per cambiare DB, ricompili.
    \item \textbf{Cloud Native:} Spring Boot legge \texttt{System.getenv()}.
    Kubernetes inietta ConfigMaps e Secrets come variabili d'ambiente.
\end{itemize}

\subsection{2. Processi Stateless (Factor VI)}
\textbf{Regola:} Il processo deve essere senza stato e "Shared-Nothing".

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    server/.style={rectangle, draw=deepblue, fill=white, minimum width=2cm, minimum height=1.5cm, rounded corners, align=center},
    db/.style={cylinder, draw=black, aspect=0.25, fill=gray!20, minimum height=1cm, minimum width=1.5cm, shape border rotate=90, align=center},
    user/.style={circle, draw=black, fill=white, minimum size=0.8cm}
]

    \node[user] (u) {User};
    
    \node[server, right=2cm of u] (s1) {Instance A};
    \node[server, below=0.5cm of s1] (s2) {Instance B};
    
    \node[db, right=2cm of s1, yshift=-1cm] (redis) {Redis\\(Session)};

    \draw[->] (u) -- (s1);
    \draw[->, dashed] (u) -- (s2);
    
    \draw[<->, red] (s1) -- (redis);
    \draw[<->, red] (s2) -- (redis);

    \node[below=0.5cm of s2, font=\scriptsize, align=center] {La RAM delle istanze è effimera.\\Lo stato va su Redis.};

\end{tikzpicture}
\end{center}

\begin{deepdive}{Sticky Session: L'Anti-Pattern}
Se salvi l'oggetto \texttt{HttpSession} nella RAM di Tomcat, l'utente è "incollato" a quel server. Se quel server muore (o se K8s scala giù), l'utente viene buttato fuori.
\textbf{Soluzione:} Usa \textbf{Spring Session Data Redis}. La sessione viene salvata su Redis. Qualsiasi istanza può servire qualsiasi utente.
\end{deepdive}

\subsection{3. Disposability (Factor IX)}
\textbf{Regola:} Avvio rapido e spegnimento grazioso (\textit{Graceful Shutdown}).
I container sono mortali. K8s può uccidere il tuo Pod in qualsiasi momento (scaling, update, crash nodo).
L'app deve intercettare il \texttt{SIGTERM}, smettere di accettare traffico, finire le query in corso e spegnersi entro 30 secondi.

\section{Design for Failure: Resilienza}
Nel Cloud, le cose si rompono. La rete è inaffidabile.
Se il Microservizio A chiama B, e B è lento, A non deve bloccarsi aspettando in eterno (esaurendo i Thread).

\subsection{Il Circuit Breaker Pattern}
È un interruttore di protezione.
Se le chiamate verso un servizio falliscono ripetutamente, il circuito si "Apre" e le chiamate successive vengono bloccate istantaneamente (Fail Fast) senza intasare la rete, permettendo al sistema remoto di riprendersi.

\begin{center}
\begin{tikzpicture}[
    node distance=2.5cm, auto, thick,
    state/.style={circle, draw=deepblue, fill=white, minimum size=2cm, align=center, font=\bfseries\small},
    arrow/.style={->, >=stealth, thick, bend left=45}
]

    % Nodi principali
    \node[state, fill=javagreen!20] (closed) {CLOSED\\(Normal)};
    \node[state, fill=javared!20, right=3cm of closed] (open) {OPEN\\(Fail Fast)};
    
    % Nodo in basso (posizionato manualmente sotto al primo, spostato a destra)
    % xshift serve a centrarlo visivamente tra i due
    \node[state, fill=intervieworange!20, below=2cm of closed, xshift=2.5cm] (half) {HALF-OPEN\\(Test)};

    % Transizioni
    \draw[arrow] (closed) to node[above, font=\tiny] {Error Threshold} (open);
    \draw[arrow] (open) to node[right, font=\tiny] {Timeout} (half);
    \draw[arrow] (half) to node[left, font=\tiny] {Success} (closed);
    \draw[arrow] (half) to node[right, font=\tiny] {Failure} (open);

\end{tikzpicture}
\end{center}

\subsection{Implementazione con Resilience4j}
Netflix Hystrix è deprecato. Lo standard oggi è \textbf{Resilience4j}.

\begin{lstlisting}[language=Java]
@Service
public class PaymentService {

    @Autowired
    private RestTemplate restTemplate;

    // Configura il Circuit Breaker "pagamenti"
    @CircuitBreaker(name = "pagamenti", fallbackMethod = "fallbackPay")
    @Retry(name = "pagamenti") // Riprova 3 volte prima di arrendersi
    public String processPayment() {
        return restTemplate.getForObject("http://billing-service/pay", String.class);
    }

    // Metodo eseguito se il circuito è APERTO o se c'è eccezione
    public String fallbackPay(Exception e) {
        return "Pagamento differito (Sistema non disponibile)";
    }
}
\end{lstlisting}

\section{Spring Cloud vs Kubernetes Native}
Questa è una distinzione architetturale fondamentale che un Senior deve conoscere.
Ci sono due modi per fare "Cloud Native":

\subsection{1. La "Old School" (Netflix OSS / Spring Cloud)}
L'applicazione gestisce tutto.
\begin{itemize}
    \item \textbf{Discovery:} L'app chiama Eureka Server per sapere gli IP.
    \item \textbf{Config:} L'app chiama Spring Config Server.
    \item \textbf{Load Balancing:} L'app usa Ribbon/Client-Side LB.
\end{itemize}
\textit{Pro:} Funziona ovunque (anche su metallo nudo). \textit{Contro:} L'app è pesante e piena di librerie infrastrutturali.

\subsection{2. La "Modern Way" (Kubernetes Native)}
Deleghiamo l'infrastruttura a Kubernetes.
\begin{itemize}
    \item \textbf{Discovery:} K8s Service (DNS).
    \item \textbf{Config:} K8s ConfigMaps (volumi/env vars).
    \item \textbf{Load Balancing:} K8s Service (ClusterIP).
\end{itemize}
\textit{Pro:} L'app è agnostica. Il codice è pulito.

\begin{interview}{Cosa usare oggi?}
\textbf{Domanda:} Ha senso usare Eureka se sono su Kubernetes?
\textbf{Risposta:} \textbf{Generalmente No.}
È ridondante. K8s fa già Service Discovery (DNS) e Load Balancing in modo eccellente a livello di rete.
Usa le librerie di Spring Cloud solo per logica applicativa interna (es. OpenFeign, Circuit Breaker, Gateway), ma delega il "wiring" infrastrutturale a Kubernetes.
\end{interview}

\section{Distributed Tracing (Observability)}
In un monolite, se c'è un errore, guardi lo stacktrace.
Nei microservizi, una richiesta attraversa 5 servizi. Dove si è bloccata?

Devi usare uno standard di \textbf{Tracing} (come OpenTelemetry / Micrometer Tracing).
Ogni richiesta HTTP deve avere due header propagati:
\begin{itemize}
    \item \textbf{Trace ID:} Identificativo unico della transazione globale.
    \item \textbf{Span ID:} Identificativo del singolo passaggio.
\end{itemize}

\begin{lstlisting}[language=bash, title={Esempio Log Cloud Native}]
# Log Service A
[INFO] [TraceID: abc-123] [SpanID: 1] Chiamata a Service B avviata...

# Log Service B
[INFO] [TraceID: abc-123] [SpanID: 2] Ricevuta richiesta da A...
[ERROR] [TraceID: abc-123] [SpanID: 2] DB Timeout!
\end{lstlisting}
Cercando \texttt{abc-123} su Kibana/Grafana, ricostruisci l'intera storia.

\section{Riepilogo}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Concetto}} & \textcolor{white}{\textbf{Cloud Native Way}} \\
    \hline
    \textbf{Stato (Session)} & Mai in RAM. Sempre su Redis (Stateless). \\
    \hline
    \textbf{Filesystem} & Effimero. Se scrivi un file su disco, al riavvio è perso. Usa S3/Blob Storage. \\
    \hline
    \textbf{Log} & Stream su \texttt{System.out}. Non scrivere su file. Ci pensa l'infrastruttura a raccoglierli. \\
    \hline
    \textbf{Configurazione} & Variabili d'ambiente (Environment Variables). \\
    \hline
    \textbf{Resilienza} & Fail Fast. Usa Circuit Breakers per non bloccare i thread. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{AWS per Sviluppatori Java}

Il Cloud non è solo "il computer di qualcun altro". È un set di primitive programmabili.
Per uno sviluppatore Java, passare ad AWS significa smettere di preoccuparsi dell'hardware e iniziare a comporre servizi gestiti.

L'obiettivo è trasformare l'infrastruttura in codice.

\section{AWS SDK for Java 2.x}
La prima cosa da sapere: esiste una nuova versione dell'SDK.
\begin{itemize}
    \item \textbf{V1 (Legacy):} Bloccante, monolitica, usa classi come \texttt{AmazonS3Client}.
    \item \textbf{V2 (Modern):} Non bloccante (basata su Netty), modulare, usa il pattern Builder e Client immutabili (es. \texttt{S3Client}, \texttt{S3AsyncClient}).
\end{itemize}

\textbf{Best Practice:} Nei nuovi progetti usa sempre la V2.

\begin{lstlisting}[language=Java, title={Configurazione S3 Client V2}]
@Configuration
public class AwsConfig {
    
    @Bean
    public S3Client s3Client() {
        // Le credenziali vengono lette automaticamente da:
        // 1. Variabili d'ambiente (AWS_ACCESS_KEY_ID)
        // 2. Ruolo IAM (se siamo su EC2/EKS/Lambda)
        // 3. File ~/.aws/credentials (in locale)
        return S3Client.builder()
                .region(Region.EU_SOUTH_1) // Milano
                .build();
    }
}
\end{lstlisting}

\section{Compute: Dove gira il mio JAR?}
Hai compilato la tua app Spring Boot. Ora dove la metti?
Esistono 4 opzioni principali, con diversi gradi di controllo.

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|X|l|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Servizio}} & \textcolor{white}{\textbf{Descrizione}} & \textcolor{white}{\textbf{Use Case}} \\
    \hline
    \textbf{EC2} & Virtual Machine pura (Linux/Windows). Hai il controllo totale (e la responsabilità totale). & Legacy, DB proprietari. \\
    \hline
    \textbf{Elastic Beanstalk} & PaaS. Carichi il JAR e lui crea l'EC2, il Load Balancer e l'Auto Scaling. & Startup, MVP veloce. \\
    \hline
    \textbf{ECS / Fargate} & Docker nativo. Tu definisci CPU/RAM e l'immagine Docker. Lui la esegue senza gestire server. & \textbf{Microservizi Spring Boot}. \\
    \hline
    \textbf{Lambda} & Function-as-a-Service. Paghi per millisecondo. Scala a zero. & Event-driven, Task asincroni. \\
    \hline
\end{tabularx}
\end{center}

\begin{deepdive}{Java su Lambda: Il problema del Cold Start}
Java è famoso per essere lento a partire (caricamento classi, JIT warm-up).
Su Lambda, questo è un problema: se la funzione non viene chiamata per un po', AWS spegne l'ambiente. La chiamata successiva potrebbe impiegare 5-10 secondi (Cold Start).
\textbf{Soluzione:} Usare \textbf{AWS Lambda SnapStart} (che fa uno snapshot della memoria dopo l'init) o passare a GraalVM Native Image.
\end{deepdive}

\section{Storage: S3 (Simple Storage Service)}
S3 non è un filesystem. Non puoi fare \texttt{new File("/s3/miofile.txt")}.
È un Object Store: una mappa gigante \texttt{Key $\to$ Blob} accessibile via HTTP.

\textbf{Scenario Classico:} Upload immagine profilo utente.

\begin{lstlisting}[language=Java]
public void uploadProfilePic(String userId, byte[] imageBytes) {
    PutObjectRequest request = PutObjectRequest.builder()
            .bucket("my-app-user-images")
            .key(userId + "/profile.jpg") // La chiave è il percorso
            .contentType("image/jpeg")
            .build();

    s3Client.putObject(request, RequestBody.fromBytes(imageBytes));
}
\end{lstlisting}

\begin{interview}{Database vs S3}
\textbf{Domanda:} Perché non salvare le immagini (BLOB) nel Database dentro una colonna \texttt{byte[]}?
\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Costo:} Lo storage DB (EBS/SSD) costa 10x più di S3.
    \item \textbf{Performance:} Caricare blob pesanti intasa la memoria del DB e la rete.
    \item \textbf{CDN:} S3 può essere collegato a CloudFront per servire i file statici globalmente con latenza minima.
\end{itemize}
\end{interview}

\section{Database: RDS vs DynamoDB}

\subsection{RDS (Relational Database Service)}
È il classico SQL (Postgres, MySQL, Oracle) ma gestito. AWS fa i backup, le patch di sicurezza e la replica.
Per l'applicazione Java, è trasparente: cambi solo la stringa JDBC.

\subsection{DynamoDB (NoSQL Serverless)}
Qui cambia tutto. Non ci sono Join, non ci sono schemi fissi.
È una \textbf{Hash Map distribuita} infinitamente scalabile.

\textbf{Quando usarlo?} Alta mole di dati, accessi per chiave primaria, carichi di picco imprevedibili (es. Black Friday).

\begin{lstlisting}[language=Java, title={DynamoDB Enhanced Client (Mappatura Oggetti)}]
@DynamoDbBean // Simile a @Entity di JPA
public class Order {
    private String orderId; // Partition Key
    private String userId;  // Sort Key
    
    @DynamoDbPartitionKey
    public String getOrderId() { return orderId; }
    // ... getter e setter
}

// Salvataggio
dynamoDbEnhancedClient.save(order);
\end{lstlisting}

\section{Messaging: SQS e SNS (Fanout Pattern)}
Disaccoppiare i servizi è vitale.

\begin{itemize}
    \item \textbf{SQS (Simple Queue Service):} Coda 1-a-1. Pull-based (il consumer chiede i messaggi).
    \item \textbf{SNS (Simple Notification Service):} Topic 1-a-Molti. Push-based.
\end{itemize}

\subsection{Architectural Pattern: Fanout}
Vogliamo che quando un utente si registra, succedano due cose: invio mail e creazione wallet.
Usiamo SNS per "moltiplicare" il messaggio verso più code SQS.

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    comp/.style={rectangle, draw=deepblue, fill=white, minimum height=1cm, align=center},
    sns/.style={circle, draw=intervieworange, fill=intervieworange!10, minimum size=1.5cm, align=center, font=\bfseries\small},
    sqs/.style={rectangle, draw=javagreen, fill=javagreen!10, minimum width=2cm, minimum height=1cm, rounded corners, align=center, font=\small},
    arrow/.style={->, >=stealth, thick}
]

    % Producer
    \node[comp] (prod) {UserService};
    
    % SNS Topic
    \node[sns, right=1.5cm of prod] (topic) {SNS\\Topic\\(UserCreated)};
    
    % SQS Queues
    \node[sqs, right=2cm of topic, yshift=1.5cm] (q1) {SQS\\Email};
    \node[sqs, right=2cm of topic, yshift=-1.5cm] (q2) {SQS\\Wallet};
    
    % Consumers
    \node[comp, right=1cm of q1] (c1) {Email\\Service};
    \node[comp, right=1cm of q2] (c2) {Wallet\\Service};

    % Wiring
    \draw[arrow] (prod) -- (topic);
    \draw[arrow] (topic) -- (q1);
    \draw[arrow] (topic) -- (q2);
    \draw[arrow] (q1) -- (c1);
    \draw[arrow] (q2) -- (c2);

\end{tikzpicture}
\end{center}

\section{Secrets Management: Parameter Store}
Mai committare password nel codice o nei file properties.
AWS fornisce \textbf{SSM Parameter Store} (gratuito per standard throughput) o \textbf{Secrets Manager} (a pagamento, rotazione automatica).

Con \textbf{Spring Cloud AWS}, puoi importare le proprietà all'avvio automaticamente:

\begin{lstlisting}[language=bash, title={application.yml (bootstrap)}]
spring:
  config:
    import: "aws-parameterstore:/config/myservice/"
\end{lstlisting}
Se in AWS crei il parametro \texttt{/config/myservice/spring.datasource.password}, Spring Boot lo inietterà automaticamente nel DataSource. Magia.

\section{Riepilogo Scelte Architetturali}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Problema}} & \textcolor{white}{\textbf{Soluzione AWS Java}} \\
    \hline
    Gestione File & \textbf{S3}. Non usare il disco locale del container. \\
    \hline
    Code Asincrone & \textbf{SQS}. Garanzia di consegna "At-least-once". \\
    \hline
    Database Relazionale & \textbf{Aurora (RDS)}. Postgres/MySQL compatibile ma cloud-native. \\
    \hline
    Password & \textbf{SSM Parameter Store}. Iniettato a runtime. \\
    \hline
    Hosting App & \textbf{Fargate (ECS)}. Container serverless, ideale per Spring Boot. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Quarkus: Supersonic Subatomic Java}

"Java è lento. Consuma troppa memoria. Non va bene per il Serverless."
Queste erano le critiche che stavano spingendo le aziende verso Go e Node.js. Poi è arrivato \textbf{Quarkus}.

Quarkus è un framework "Kubernetes Native", progettato per GraalVM e HotSpot.
La sua rivoluzione non sta nelle API (che sono standard: JAX-RS, JPA, Hibernate), ma nel \textbf{ciclo di vita dell'applicazione}.

\section{La Filosofia: Build Time First}
La differenza fondamentale tra Spring Boot e Quarkus sta in \textit{quando} vengono fatte le cose pesanti.

\begin{center}
\begin{tikzpicture}[
    % Scala leggermente per adattarsi alla pagina
    scale=0.95, transform shape,
    % Stile base per i blocchi
    phase/.style={
        rectangle, 
        draw=black!50, 
        minimum height=1.5cm, 
        align=center, 
        font=\sffamily\scriptsize,
        inner sep=2pt
    },
    % Stile per le etichette dei titoli
    title/.style={
        anchor=west, 
        font=\bfseries\small, 
        text=deepblue
    }
]

    % --- RIGA 1: SPRING BOOT ---
    \node[title] at (0, 2.5) {Spring Boot (Carico al Runtime)};
    
    % Build (Corto)
    \node[phase, fill=gray!20, minimum width=2cm] at (1, 1.5) {Build\\(Maven/Gradle)};
    
    % Runtime Start (LUNGO e PESANTE)
    \node[phase, fill=javared!10, minimum width=8cm, text width=7.5cm] at (6, 1.5) {\textbf{RUNTIME START}\\Scan Classpath, Parse Config, Create Proxies (CGLIB), Dependency Injection, Warmup};
    
    % Ready
    \node[phase, fill=javagreen!20, minimum width=2cm] at (11, 1.5) {App Ready};


    % --- RIGA 2: QUARKUS ---
    \node[title] at (0, -0.5) {Quarkus (Carico al Build Time)};
    
    % Build (LUNGO - Fa il lavoro sporco qui)
    \node[phase, fill=deepblue!10, minimum width=7cm, text width=6.5cm] at (3.5, -1.5) {\textbf{BUILD e AUGMENTATION}\\Class Loading, Scanning, Wiring, Dead Code Elimination, Bytecode Recording};
    
    % Start (Cortissimo)
    \node[phase, fill=javared!10, minimum width=2cm] at (8, -1.5) {Start\\(Esecuzione)};
    
    % Ready (Arriva prima)
    \node[phase, fill=javagreen!20, minimum width=2cm] at (10, -1.5) {App Ready};

    % --- ASSE TEMPORALE ---
    \draw[->, thick, gray] (0, -2.8) -- (12.5, -2.8) node[right] {Tempo};

\end{tikzpicture}
\end{center}
\begin{itemize}
    \item \textbf{Spring (Runtime):} Quando lanci il JAR, Spring scansiona il classpath, legge le annotazioni, crea i proxy dinamici e inietta i bean. Questo costa CPU e RAM all'avvio.
    \item \textbf{Quarkus (Build Time):} Sposta queste operazioni alla fase di compilazione (\texttt{mvn package}). Il bytecode generato è già "cablato". All'avvio deve solo eseguire, non "capire" cosa fare.
\end{itemize}

\section{Developer Experience: Live Coding}
Dimentica il tasto "Riavvia Server".
Quarkus offre la migliore Developer Experience (DX) sul mercato.

Comando magico:
\begin{lstlisting}[language=bash]
mvn quarkus:dev
\end{lstlisting}

\begin{deepdive}{Come funziona il Dev Mode?}
Quando modifichi un file Java e salvi, Quarkus non ricompila tutto.
Mantiene l'app in uno stato "sospeso". Appena arriva una richiesta HTTP:
1. Ferma il mondo.
2. Ricompila solo le classi cambiate (millisecondi).
3. Ricarica il contesto.
4. Serve la richiesta.
Tutto questo avviene in meno di 0.5 secondi. È trasparente.
\end{deepdive}

\subsection{Dev Services (Zero Config)}
Se aggiungi l'estensione PostgreSQL ma non configuri l'URL nel \texttt{application.properties}, Quarkus (in Dev Mode) usa \textbf{Testcontainers} per avviare automaticamente un container Postgres Docker, collegarlo all'app e spegnerlo quando chiudi.
Niente più \texttt{docker-compose} per lo sviluppo locale!

\section{Hibernate con Panache}
Quarkus usa Hibernate, ma offre un layer opzionale chiamato \textbf{Panache} che semplifica drasticamente il codice.
Supporta due pattern:

\subsection{1. Repository Pattern (Classico)}
Simile a Spring Data.
\begin{lstlisting}[language=Java]
@ApplicationScoped
public class UserRepository implements PanacheRepository<User> {
    // findById, persist, delete... sono già qui.
    // Puoi aggiungere metodi custom:
    public User findByUsername(String name) {
        return find("username", name).firstResult();
    }
}
\end{lstlisting}

\subsection{2. Active Record Pattern (Il marchio di fabbrica)}
Qui l'Entity sa come salvarsi da sola. Molto amato per la sua sinteticità, ma controverso per i puristi dell'architettura (mescola dati e accesso ai dati).

\begin{lstlisting}[language=Java, title={Entity Active Record}]
@Entity
public class User extends PanacheEntity { 
    // PanacheEntity aggiunge il campo 'id' autogenerato
    
    public String username; // Campi pubblici! (Panache riscrive il bytecode per renderli getter/setter)
    public LocalDate birthDate;

    // Metodi statici sull'Entity
    public static User findByName(String name) {
        return find("username", name).firstResult();
    }
}

// Utilizzo nel Service
User u = new User();
u.username = "Mario";
u.persist(); // L'entità si salva da sola!
\end{lstlisting}

\section{Reactive Core: Mutiny}
Spring ha aggiunto la reattività (WebFlux) dopo anni. Quarkus è nato reattivo.
Il motore sottostante è \textbf{Vert.x} (non-blocking I/O).

Anche se scrivi codice imperativo (bloccante), Quarkus lo esegue in modo efficiente. Ma se vuoi la massima scalabilità, usi le API reattive \textbf{Mutiny}.

\begin{lstlisting}[language=Java]
// Uni = 0 o 1 elemento (come Mono)
// Multi = 0 o N elementi (come Flux)

@GET
@Path("/{id}")
public Uni<User> getUser(Long id) {
    return User.findById(id)
        .onItem().ifNull().failWith(new NotFoundException())
        .onItem().transform(u -> {
            log.info("Utente trovato: " + u.username);
            return u;
        });
}
\end{lstlisting}

\section{Native Compilation (GraalVM)}
Quarkus definisce le estensioni come "Native Ready".
Se usi librerie supportate (l'ecosistema Quarkus Extension), compilare in nativo è banale:

\begin{lstlisting}[language=bash]
mvn package -Pnative
\end{lstlisting}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|c|c|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Metrica}} & \textcolor{white}{\textbf{JVM (OpenJDK)}} & \textcolor{white}{\textbf{Native (GraalVM)}} \\
    \hline
    \textbf{Startup Time} & 2.0s & 0.05s \\
    \hline
    \textbf{RSS Memory (Idle)} & 140MB & 12MB \\
    \hline
    \textbf{Throughput} & Molto Alto (JIT) & Alto (AOT) \\
    \hline
    \textbf{Use Case} & Monoliti, Long Running & Serverless, K8s Scaling \\
    \hline
\end{tabularx}
\end{center}

\section{Spring vs Quarkus: Guida alla Scelta}

\begin{interview}{Quando migrare a Quarkus?}
\textbf{Domanda:} Ho un monolite Spring Boot. Devo riscriverlo in Quarkus?

\textbf{Risposta:}
\begin{itemize}
    \item \textbf{Resta su Spring Boot se:} Hai un team grande che conosce bene Spring, usi molte librerie legacy non supportate da Quarkus, o l'applicazione è un servizio "always-on" dove 200MB di RAM non sono un problema.
    \item \textbf{Passa a Quarkus se:} Stai facendo \textbf{Serverless} (AWS Lambda) dove il cold-start è critico. Stai costruendo microservizi ad alta densità su Kubernetes (vuoi far girare 50 pod su un nodo piccolo). Vuoi ridurre la bolletta del Cloud (meno RAM = istanze più piccole).
\end{itemize}
\end{interview}

\section{Spring Compatibility API}
Quarkus è intelligente. Sa che gli sviluppatori conoscono Spring.
Offre estensioni di compatibilità: puoi usare le annotazioni di Spring (\texttt{@RestController}, \texttt{@Autowired}, \texttt{@Service}) dentro Quarkus!

\begin{lstlisting}[language=Java]
// Questo è codice Quarkus, ma sembra Spring!
@RestController
@RequestMapping("/api")
public class SpringGreeterController {

    @GetMapping("/hello")
    public String hello() {
        return "Funziona su Quarkus!";
    }
}
\end{lstlisting}
\textit{Nota: Sotto il cofano vengono tradotte in JAX-RS e CDI a build time. Non c'è il runtime di Spring.}



\part{Mindset: Troubleshooting e Live Coding}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Debugging Avanzato: Oltre il Breakpoint}

"Un Junior cerca di indovinare dove è il bug cambiando codice a caso (Shotgun Debugging). Un Senior formula un'ipotesi, isola il problema e lo dimostra."

Il debugging non è solo conoscere i tasti dell'IDE. È l'arte di ridurre lo spazio di ricerca. In questo capitolo vedremo strumenti avanzati, il protocollo di debug remoto (fondamentale per Docker) e come analizzare i thread dump.

\section{Il Mindset Scientifico}
Prima di toccare la tastiera, segui il ciclo:
\begin{enumerate}
    \item \textbf{Riproduzione:} Se non puoi riprodurlo costantemente, non puoi fixarlo. Isola lo scenario (test unitario).
    \item \textbf{Ipotesi:} "Credo che sia colpa della transazione non committata".
    \item \textbf{Verifica:} Usa i log o il debugger per confermare l'ipotesi.
    \item \textbf{Fix:} Applica la correzione.
    \item \textbf{Regression:} Verifica di non aver rotto altro.
\end{enumerate}

\section{IDE Power Tools (IntelliJ/Eclipse)}
Tutti sanno fare "Step Over" (F8). Ecco cosa usano i Pro.

\subsection{1. Conditional Breakpoints}
Hai un ciclo che gira 10.000 volte. Il bug si verifica solo all'iterazione 9.500. Non puoi premere F8 novemila volte.

\textbf{Soluzione:} Tasto destro sul pallino rosso del breakpoint $\to$ Condition:
\begin{lstlisting}[language=Java]
user.getId().equals("buggy-user-123")
\end{lstlisting}
Il debugger si fermerà \textbf{solo} quando la condizione è vera.

\subsection{2. Exception Breakpoints}
Il programma crasha con \texttt{NullPointerException}, ma i log sono confusi e non sai dove succede.
\textbf{Soluzione:} Configura l'IDE per fermarsi automaticamente \textbf{appena viene lanciata una specifica eccezione}, prima ancora che venga catturata dal \texttt{try-catch}.

\subsection{3. Drop Frame (Rewind)}
Hai appena fatto "Step Over" su una funzione, ma ti sei accorto che il bug era \textit{dentro} quella funzione. Troppo tardi?
No. Usa \textbf{Drop Frame}.
Questa funzione "smonta" lo stack corrente e riporta l'esecuzione all'inizio del metodo chiamante, permettendoti di rientrare nel metodo (Step Into) come se avessi riavvolto il tempo.
\textit{Nota: Non annulla le modifiche al DB o alle variabili globali, solo lo stack di esecuzione.}

\subsection{4. Evaluate Expression (Alt+F8)}
Mentre sei in pausa, puoi scrivere ed eseguire codice Java arbitrario nel contesto corrente.
Puoi persino fare chiamate al DB (\texttt{repo.findById(...)}) per verificare lo stato del sistema in quel micro-istante.

\section{Remote Debugging (JDWP)}
Come debuggo un'applicazione che gira dentro un container Docker o su un server di staging? Non ho la GUI lì.

Java possiede il \textbf{JDWP (Java Debug Wire Protocol)}. La JVM agisce come un server e l'IDE si connette via TCP.

\begin{center}
\begin{tikzpicture}[
    node distance=2cm, auto, thick,
    ide/.style={rectangle, draw=deepblue, fill=white, text width=2.5cm, align=center, minimum height=1.5cm, rounded corners},
    server/.style={rectangle, draw=black, fill=gray!10, text width=3cm, align=center, minimum height=1.5cm},
    arrow/.style={<->, >=stealth, thick, dashed}
]

    \node[ide] (laptop) {\textbf{Tuo Laptop}\\(IntelliJ IDEA)\\Debugger Client};
    
    \node[server, right=4cm of laptop] (container) {\textbf{Docker / Server}\\(JVM)\\Debugger Server};

    \draw[arrow] (laptop) -- node[above, font=\scriptsize] {TCP Socket} node[below, font=\scriptsize] {Port 5005} (container);

\end{tikzpicture}
\end{center}

\subsection{Configurazione}
Per abilitare il debug remoto, devi avviare l'applicazione Java (nel Dockerfile o nello script di avvio) con questi flag:

\begin{lstlisting}[language=bash]
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 -jar app.jar
\end{lstlisting}

\begin{itemize}
    \item \textbf{transport=dt\_socket:} Usa TCP.
    \item \textbf{server=y:} La JVM aspetta la connessione.
    \item \textbf{suspend=n:} L'app parte subito (se metti 'y', l'app resta congelata all'avvio finché non ti colleghi).
    \item \textbf{address=*:5005:} Ascolta sulla porta 5005 su tutte le interfacce di rete (fondamentale per Docker).
\end{itemize}

\begin{deepdive}{Security Warning}
\textbf{MAI} lasciare la porta di debug (5005) aperta pubblicamente in Produzione.
Il protocollo JDWP non ha autenticazione e permette l'esecuzione remota di codice arbitrario. Un hacker potrebbe prendere il controllo totale del server in secondi.
\end{deepdive}

\section{Analisi dello Stack Trace}
Uno stack trace va letto \textbf{dal basso verso l'alto} per capire il flusso, ma \textbf{dall'alto verso il basso} per trovare l'errore.

\begin{lstlisting}[language=bash, basicstyle=\tiny\ttfamily]
java.lang.NullPointerException: Cannot invoke "String.length()" because "name" is null
    at com.myapp.service.UserService.process(UserService.java:42)  <-- IL TUO CODICE
    at com.myapp.controller.UserController.create(UserController.java:20)
    at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at ... (Linee di framework Spring/Tomcat inutili) ...
    at java.lang.Thread.run(Thread.java:833)
\end{lstlisting}

\textbf{Regola Senior:} Ignora le righe che iniziano con \texttt{org.springframework}, \texttt{org.hibernate}, \texttt{java.lang.reflect}.
Cerca la prima riga che appartiene al tuo package (\texttt{com.myapp}). Lì è esploso il codice.

\subsection{Caused By: La vera radice}
Spesso le eccezioni sono "wrappate".
Hibernate lancia \texttt{PersistenceException}, che contiene una \texttt{ConstraintViolationException}, che contiene una \texttt{SQLException}.
Scorri sempre fino all'ultimo \textbf{"Caused by:"}. Quella è la radice del male.

\section{Thread Dumps: Debugging dei Blocchi}
L'applicazione è attiva, la CPU è al 100\% (o allo 0\%), ma non risponde. I log sono fermi.
Probabile causa: \textbf{Deadlock} o \textbf{Loop Infinito}.

Un \textbf{Thread Dump} è una fotografia istantanea di cosa stanno facendo tutti i thread della JVM.

\subsection{Come catturarlo}
\begin{enumerate}
    \item Trova il PID: \texttt{jps}
    \item Cattura dump: \texttt{jstack <PID> > dump.txt}
\end{enumerate}

\subsection{Cosa cercare nel file}
Cerca lo stato dei thread:
\begin{itemize}
    \item \textbf{RUNNABLE:} Sta lavorando (consuma CPU). Se molti thread sono runnable nello stesso metodo, hai un loop infinito o un algoritmo lento.
    \item \textbf{BLOCKED:} Sta aspettando un \texttt{synchronized} lock posseduto da altri.
    \item \textbf{WAITING:} Sta aspettando un segnale (es. connessione DB dal pool).
\end{itemize}

\begin{lstlisting}[language=bash, title={Esempio di Deadlock nel Dump}]
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x0000... (Object A),
  which is held by "Thread-2"
"Thread-2":
  waiting to lock monitor 0x0000... (Object B),
  which is held by "Thread-1"
\end{lstlisting}
Se vedi questo, devi riavviare e correggere l'ordine di acquisizione dei lock nel codice.

\section{Interview Questions}

\begin{interview}{Heisenbug}
\textbf{Domanda:} Cos'è un Heisenbug?
\textbf{Risposta:} È un bug che scompare o cambia comportamento quando provi a studiarlo (es. attivando il debugger o aggiungendo log).
Spesso è causato da \textbf{Race Conditions} (concorrenza). L'atto di fermare il thread col debugger altera il timing dell'esecuzione, "risolvendo" temporaneamente il problema di sincronizzazione.
\end{interview}

\begin{interview}{Debug in Prod}
\textbf{Domanda:} Il sistema è lento in produzione ma non riesci a riprodurlo in locale. Che fai?
\textbf{Risposta:}
\begin{enumerate}
    \item Analizzo metriche (CPU/RAM) e Log.
    \item Controllo il Distributed Tracing (Span lenti).
    \item Eseguo un \textbf{Thread Dump} per vedere dove sono bloccati i thread.
    \item Eseguo un \textbf{Heap Dump} (con cautela, "freeza" la JVM per secondi) per analizzare Memory Leaks con strumenti come Eclipse Memory Analyzer (MAT).
\end{enumerate}
\end{interview}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Nozioni base di Algoritmi nel Live Coding}

"Non importa quanto conosci Spring Boot se non riesci a scrivere un ciclo for efficiente."

Il Live Coding (o Whiteboard Interview) terrorizza molti sviluppatori Senior. Perché? Perché nel lavoro quotidiano usiamo librerie già pronte. Nelle interviste, invece, dobbiamo dimostrare di saper ragionare sulla \textbf{Complessità Computazionale}.

L'obiettivo non è trovare la soluzione "che funziona", ma la soluzione \textbf{Scalabile}.

\section{Big O Notation: Il Linguaggio delle Performance}
Non dire "questo codice è veloce". Di' "questo codice è $O(n)$".
La Big O descrive come cresce il tempo di esecuzione al crescere dei dati di input ($n$).

\begin{center}
\begin{tikzpicture}[scale=0.8, transform shape]
    % Assi
    \draw[->] (0,0) -- (6,0) node[right] {$n$ (Input Size)};
    \draw[->] (0,0) -- (0,5) node[above] {Time};
    
    % O(1)
    \draw[thick, javagreen] plot[domain=0:5.5, samples=200] (\x, 1)
		node[right, yshift=2pt] {$O(1)$ Eccellente};
    
    % O(log n)
    \draw[thick, blue] plot[domain=0:5.5, samples=200] (\x, {ln(\x+1)}) 
        node[right, yshift=2pt] {$O(\log n)$ Buono};

    % O(n)
    \draw[thick, orange] plot[domain=0:5.5, samples=200] (\x, {\x}) 
        node[right, yshift=-2pt] {$O(n)$ Discreto};
    
    % O(n^2)
    \draw[thick, red] plot[domain=0:2.2, samples=200] (\x, {\x*\x}) 
        node[right, yshift=2pt] {$O(n^2)$ Cattivo};
	
	% O(n!) approssimato con esponenziale
    \draw[thick, purple] plot[domain=0:1.5, samples=200] (\x, {exp(\x)-1}) 
        node[right, yshift=2pt] {$O(n!)$ Malissimo};
\end{tikzpicture}
\end{center}


\begin{itemize}
    \item \textbf{$O(1)$ - Costant Time:} Accesso a Map o Array per indice. Il Santo Graal.
    \item \textbf{$O(\log n)$ - Logarithmic:} Binary Search. Tagli il problema a metà ad ogni passo.
    \item \textbf{$O(n)$ - Linear:} Un ciclo for che scorre tutto. Accettabile.
    \item \textbf{$O(n^2)$ - Quadratic:} Due cicli for annidati (Nested Loops). Da evitare come la peste su grandi dataset.
\end{itemize}

\begin{interview}{Space Complexity}
\textbf{Domanda:} "La tua soluzione è $O(n)$ in tempo. E in spazio?"
\textbf{Risposta:} Spesso dimenticata.
\begin{itemize}
    \item Se crei una \texttt{HashMap} o un array di supporto grande quanto l'input, sei $O(n)$ space.
    \item Se usi solo poche variabili (\texttt{int i, int j}), sei $O(1)$ space.
\end{itemize}
I senior cercano sempre di ottimizzare lo spazio se il tempo è già ottimo.
\end{interview}

\section{Pattern 1: Two Pointers (I Due Puntatori)}
\textbf{Problema:} Data una stringa o un array ordinato, trovare qualcosa (es. palindromo, coppia somma).
\textbf{Soluzione Naive ($O(n^2)$):} Due cicli for annidati.
\textbf{Soluzione Two Pointers ($O(n)$):} Un puntatore all'inizio, uno alla fine, si muovono verso il centro.

\begin{center}
\begin{tikzpicture}[
    node distance=0cm, auto, thick,
    cell/.style={rectangle, draw=black, minimum size=0.8cm, outer sep=0pt},
    ptr/.style={->, >=stealth, line width=1.5pt, deepblue}
]
    % Celle attaccate (node distance=0cm)
    \node[cell] (1) {R};
    \node[cell, right=of 1] (2) {A};
    \node[cell, right=of 2] (3) {D};
    \node[cell, right=of 3] (4) {A};
    \node[cell, right=of 4] (5) {R};

    % Puntatori (Uso yshift invece di calcoli $)
    \draw[ptr] ([yshift=-0.8cm]1.south) -- node[below = 0.6cm] {Left} (1.south);
    \draw[ptr] ([yshift=-0.8cm]5.south) -- node[below = 0.6cm] {Right} (5.south);
    
    % Freccia di confronto
    \draw[->, dashed, bend left] (1.north) to node[above, font=\tiny] {Confronta} (5.north);

\end{tikzpicture}
\end{center}

\begin{lstlisting}[language=Java, title={Valid Palindrome (O(n))}]
public boolean isPalindrome(String s) {
    int left = 0;
    int right = s.length() - 1;

    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
\end{lstlisting}

\section{Pattern 2: Sliding Window (Finestra Scorrevole)}
\textbf{Problema:} Trovare il subarray (o sottostringa) contiguo che soddisfa una condizione (es. somma massima di 3 elementi consecutivi).
\textbf{Soluzione:} Invece di ricalcolare tutto ogni volta, "trascini" una finestra. Sottrai l'elemento che esce, aggiungi quello che entra.

\begin{center}
\begin{tikzpicture}[
    node distance=0cm, auto, thick,
    cell/.style={rectangle, draw=black, minimum size=0.8cm, outer sep=0pt},
    window/.style={rectangle, draw=intervieworange, line width=1.5pt, minimum height=1cm, minimum width=2.4cm}
]
% Celle
\node[cell] (1) {2};
\node[cell, right=of 1] (2) {5};
\node[cell, right=of 2] (3) {1};
\node[cell, right=of 3] (4) {8};
\node[cell, right=of 4] (5) {2};

% Finestra centrata su 2-3-4
\node[window, fit=(2)(3)(4)] (win) {};

% Testo somma
\node[above=0.6cm of win, text=intervieworange] {Window Sum = 14};

% Freccia slide
\draw[->, thick, intervieworange] (win.south east) -- ++(1,0) node[right] {Slide};
\end{tikzpicture}
\end{center}

\begin{lstlisting}[language=Java]
public int maxSubArraySum(int[] arr, int k) {
    int maxSum = 0;
    int windowSum = 0;

    // 1. Calcola somma prima finestra
    for (int i = 0; i < k; i++) windowSum += arr[i];
    maxSum = windowSum;

    // 2. Slide
    for (int i = k; i < arr.length; i++) {
        windowSum += arr[i];     // Aggiungi elemento nuovo
        windowSum -= arr[i - k]; // Togli elemento vecchio
        maxSum = Math.max(maxSum, windowSum);
    }
    return maxSum;
}
\end{lstlisting}

\section{Pattern 3: Fast e Slow Pointers (Tartaruga e Lepre)}
Usato per rilevare cicli nelle LinkedList.
Un puntatore va a velocità 1 (\texttt{next}), l'altro a velocità 2 (\texttt{next.next}). Se c'è un ciclo, prima o poi si incontrano.

\begin{lstlisting}[language=Java]
public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;       // 1 step
        fast = fast.next.next;  // 2 steps
        
        if (slow == fast) return true; // Collisione!
    }
    return false;
}
\end{lstlisting}

\section{Pattern 4: HashMap come "Memoria"}
Spesso per abbattere la complessità da $O(n^2)$ a $O(n)$, basta usare memoria ($O(n)$ space).
\textbf{Esempio (Two Sum):} Trova due numeri che sommati danno il target.

\begin{itemize}
    \item \textbf{Naive:} Doppio ciclo for. "Per ogni numero, cerco se esiste il complementare nel resto dell'array".
    \item \textbf{HashMap:} "Mentre scorro, salvo i numeri visti in una mappa. Per ogni numero, chiedo alla mappa in $O(1)$: 'Hai già visto il mio complementare?'".
\end{itemize}

\begin{lstlisting}[language=Java]
public int[] twoSum(int[] nums, int target) {
    // Key: Numero, Value: Indice
    Map<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No solution");
}
\end{lstlisting}

\section{Binary Search: Oltre l'Array}
Tutti sanno fare binary search su un array ordinato.
Ma i Senior sanno che si può usare Binary Search su \textbf{qualsiasi spazio di ricerca monotono}.

Esempio: "Trova la versione del software che ha introdotto il bug".
Se la v10 funziona e la v50 è rotta, il bug è nel mezzo. Testo la v30.
\begin{itemize}
    \item Se v30 rotta $\to$ Bug è tra v10 e v29.
    \item Se v30 funziona $\to$ Bug è tra v31 e v50.
\end{itemize}
Questo è $O(\log n)$ invece di testare tutte le versioni.

\section{Consigli per il Live Coding}

\begin{interview}{Parla mentre scrivi}
L'errore più grande è stare zitti per 5 minuti e poi scrivere la soluzione perfetta.
L'intervistatore vuole vedere \textbf{come ragioni}.
\begin{enumerate}
    \item \textbf{Restate:} Ripeti il problema per essere sicuro di aver capito.
    \item \textbf{Examples:} Scrivi input/output di esempio sulla lavagna.
    \item \textbf{Brute Force:} Dì ad alta voce: "Potrei fare due cicli for, ma sarebbe $O(n^2)$. Proviamo a ottimizzare".
    \item \textbf{Coding:} Scrivi codice pulito. Nomi variabili sensati.
    \item \textbf{Dry Run:} Esegui mentalmente il codice con un esempio prima di dire "Finito".
\end{enumerate}
\end{interview}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Algoritmi Avanzati: Grafi, DP e Backtracking}

"Chiunque sa scrivere un ciclo for. Pochi sanno scrivere una funzione che chiama se stessa senza causare uno StackOverflow."

I problemi "Hard" delle Big Tech (Google, Amazon, ma anche banche d'affari) richiedono di modellare la realtà come un Grafo o di ottimizzare la ricorsione tramite la Programmazione Dinamica.

\section{Grafi: BFS vs DFS}
Quasi tutti i problemi di connessione (social network, mappe, dipendenze tra task) sono grafi.
Esistono due modi per esplorarli.

\subsection{1. BFS (Breadth-First Search) - A Livelli}
Esplora "a macchia d'olio". Prima i vicini, poi i vicini dei vicini.
\textbf{Uso:} Trovare il percorso più breve (Shortest Path) in grafi non pesati.
\textbf{Struttura Dati:} \texttt{Queue} (FIFO).

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm, auto, thick,
    node/.style={circle, draw=deepblue, fill=white, minimum size=0.8cm},
    level1/.style={fill=javagreen!20},
    level2/.style={fill=intervieworange!20}
]
    \node[node, fill=deepblue!20] (root) {1};
    
    \node[node, level1, below left=of root] (2) {2};
    \node[node, level1, below right=of root] (3) {3};
    
    \node[node, level2, below=of 2] (4) {4};
    \node[node, level2, below=of 3] (5) {5};

    \draw (root) -- (2);
    \draw (root) -- (3);
    \draw (2) -- (4);
    \draw (3) -- (5);
    
    \node[right=0.5cm of 3, font=\scriptsize, align=left] {Level 1:\\Visitati insieme};
    \node[right=0.5cm of 5, font=\scriptsize, align=left] {Level 2:\\Visitati dopo};

\end{tikzpicture}
\end{center}

\begin{lstlisting}[language=Java, title={BFS Template}]
public void bfs(Node start) {
    Queue<Node> queue = new LinkedList<>();
    Set<Node> visited = new HashSet<>();
    
    queue.add(start);
    visited.add(start);
    
    while (!queue.isEmpty()) {
        Node current = queue.poll();
        // Processa current...
        
        for (Node neighbor : current.neighbors) {
            if (!visited.contains(neighbor)) {
                queue.add(neighbor);
                visited.add(neighbor);
            }
        }
    }
}
\end{lstlisting}

\subsection{2. DFS (Depth-First Search) - In Profondità}
Va il più a fondo possibile in un ramo prima di tornare indietro (Backtrack).
\textbf{Uso:} Trovare se esiste un percorso, risolvere labirinti, topological sort.
\textbf{Struttura Dati:} \texttt{Stack} (o Ricorsione).

\begin{lstlisting}[language=Java, title={DFS Recursion Template}]
public void dfs(Node node, Set<Node> visited) {
    if (visited.contains(node)) return;
    
    visited.add(node);
    // Processa node...
    
    for (Node neighbor : node.neighbors) {
        dfs(neighbor, visited);
    }
}
\end{lstlisting}

\section{Recursion e Backtracking}
Il Backtracking è una "brute force intelligente".
Proviamo tutte le combinazioni possibili, ma ci fermiamo subito (Pruning) se una strada non è valida.

\textbf{Pattern Classico:} Generare permutazioni, Sudoku, N-Queens.

\begin{tcolorbox}[colback=white, colframe=deepblue, title=Il Template del Backtracking]
\begin{enumerate}
    \item \textbf{Choose:} Fai una scelta (aggiungi elemento alla lista temporanea).
    \item \textbf{Explore:} Chiama la funzione ricorsiva per il passo successivo.
    \item \textbf{Un-Choose:} Annulla la scelta (togli elemento) per provare un'altra strada.
\end{enumerate}
\end{tcolorbox}

\begin{lstlisting}[language=Java, title={Permutazioni [1,2,3]}]
public void backtrack(List<Integer> temp, int[] nums, boolean[] used) {
    // Caso Base: Soluzione trovata
    if (temp.size() == nums.length) {
        result.add(new ArrayList<>(temp));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        if (used[i]) continue; // Skip se già usato
        
        // 1. Choose
        used[i] = true;
        temp.add(nums[i]);
        
        // 2. Explore
        backtrack(temp, nums, used);
        
        // 3. Un-Choose (Backtrack)
        used[i] = false;
        temp.remove(temp.size() - 1);
    }
}
\end{lstlisting}

\section{Dynamic Programming (DP)}
La DP è semplicemente \textbf{Ricorsione + Memoria}.
Se un problema può essere diviso in sottoproblemi che si ripetono (Overlapping Subproblems), usa la DP.

\subsection{Top-Down (Memoization)}
Scrivi la soluzione ricorsiva, ma prima di calcolare, controlli in una Mappa se l'hai già fatto.

\begin{lstlisting}[language=Java, title={Fibonacci con Memoization}]
Map<Integer, Integer> memo = new HashMap<>();

public int fib(int n) {
    if (n <= 1) return n;
    
    // Check Cache
    if (memo.containsKey(n)) return memo.get(n);
    
    // Calcola e Salva
    int res = fib(n - 1) + fib(n - 2);
    memo.put(n, res);
    
    return res;
}
\end{lstlisting}
Senza memoization: $O(2^n)$ (Esponenziale - Lento!).
Con memoization: $O(n)$ (Lineare - Veloce!).

\section{Priority Queue (Heap)}
Spesso ti chiedono: "Trova i K elementi più grandi in uno stream di numeri".
Ordinare tutto l'array ($O(n \log n)$) è troppo lento.

Usa una \textbf{Min-Heap} di dimensione K.
\begin{itemize}
    \item Mantieni nella heap solo i K numeri più grandi visti finora.
    \item Il più piccolo dei grandi è in cima (root).
    \item Se arriva un numero nuovo $X$:
    \begin{itemize}
        \item Se $X > root$: togli root, inserisci $X$.
        \item Se $X < root$: ignoralo (è troppo piccolo per entrare nella top K).
    \end{itemize}
\end{itemize}

\begin{lstlisting}[language=Java]
public int findKthLargest(int[] nums, int k) {
    // Min-Heap (default in Java)
    PriorityQueue<Integer> heap = new PriorityQueue<>();

    for (int n : nums) {
        heap.add(n);
        if (heap.size() > k) {
            heap.poll(); // Rimuove il più piccolo
        }
    }
    // In cima rimane il K-esimo elemento più grande
    return heap.peek();
}
\end{lstlisting}
\textbf{Complessità:} $O(n \log k)$. Molto meglio di ordinare tutto.

\section{Trie (Prefix Tree)}
Se ti chiedono di implementare un \textbf{Autocomplete} o un correttore ortografico, la risposta è il Trie.
È un albero dove ogni nodo è un carattere.

\begin{center}
\begin{tikzpicture}[
    node distance=1cm, auto, thick,
    node/.style={circle, draw=black, minimum size=0.6cm, font=\small},
    root/.style={circle, draw=deepblue, fill=deepblue!10, minimum size=0.6cm}
]
    \node[root] (r) {};
    
    \node[node, below left=of r] (c) {c};
    \node[node, below=of c] (a) {a};
    \node[node, below left=of a] (t) {t};
    \node[node, below right=of a] (r2) {r};
    
    \draw (r) -- (c);
    \draw (c) -- (a);
    \draw (a) -- (t);
    \draw (a) -- (r2);
    
    \node[right=0.2cm of r2, font=\tiny] {Parole: "cat", "car"};

\end{tikzpicture}
\end{center}

\section{Riepilogo Strategia di Scelta}

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|X|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Problema}} & \textcolor{white}{\textbf{Algoritmo/Struttura}} \\
    \hline
    Shortest Path (non pesato) & \textbf{BFS} (Queue). \\
    \hline
    Maze / Puzzle / Path Exists & \textbf{DFS} (Stack/Recursion). \\
    \hline
    Combinazioni / Permutazioni & \textbf{Backtracking}. \\
    \hline
    Ottimizzazione (Max/Min profitto) & \textbf{Dynamic Programming}. \\
    \hline
    Top K elements & \textbf{PriorityQueue} (Heap). \\
    \hline
    Dictionary / Prefix Search & \textbf{Trie}. \\
    \hline
\end{tabularx}
\end{center}

% -------------------------------------------------------------------
% CAPITOLO
% -------------------------------------------------------------------
\chapter{Soft Skills: Consigli per il Colloquio}

"Le Hard Skills ti portano al colloquio. Le Soft Skills ti fanno ottenere il lavoro."

Essere un Senior Developer non significa sapere a memoria le API di Java. Significa saper comunicare, saper gestire l'incertezza e dimostrare di essere un problem solver affidabile.
In questo capitolo finale, analizziamo la strategia psicologica per affrontare le selezioni tecniche e comportamentali.

\section{Gestire il "Non lo so"}
La paura più grande del candidato è ricevere una domanda a cui non sa rispondere.
\textbf{Spoiler:} Succederà. È fatto apposta.

Un Junior prova a indovinare, arrampicandosi sugli specchi.
Un Senior usa l'\textbf{Onestà Intellettuale}.

\begin{interview}{Come rispondere quando non sai la risposta}
\textbf{Scenario:} "Come funziona l'algoritmo di Garbage Collection G1 nel dettaglio?" (E tu non lo sai).

\textbf{Risposta Sbagliata:} "Eh, pulisce la memoria... è veloce... credo usi dei thread..." (Vago, insicuro).

\textbf{Risposta Senior:} "Onestamente non conosco i dettagli interni del G1 a questo livello di profondità. So che divide la memoria in regioni invece che in generazioni fisiche contigue per ridurre le pause. Se dovessi ottimizzarlo in produzione, leggerei la documentazione ufficiale di Oracle e analizzerei i log del GC con strumenti come GCeasy."

\textbf{Analisi:} Hai ammesso l'ignoranza (Onestà), hai mostrato di conoscere il concetto generale (Competenza) e hai spiegato come risolveresti il problema (Metodo).
\end{interview}

\section{Live Coding: "Think Out Loud"}
Durante le sessioni di coding (LeetCode/HackerRank), il silenzio è il tuo nemico.
L'intervistatore non è interessato solo alla soluzione finale, ma al tuo \textbf{processo mentale}.

\begin{tcolorbox}[colback=white, colframe=deepblue, title=Il Protocollo del Live Coding]
\begin{enumerate}
    \item \textbf{Ripeti la domanda:} "Se ho capito bene, devo trovare i duplicati in una lista, giusto?". Evita malintesi catastrofici.
    \item \textbf{Discuti i casi limite:} "Cosa succede se la lista è null? Se è vuota? Se contiene numeri negativi?". Questo dimostra che pensi ai bug prima di scrivere codice.
    \item \textbf{Proponi prima la Brute Force:} "L'approccio ingenuo sarebbe usare due cicli for ($O(n^2)$). Possiamo ottimizzarlo usando una HashMap ($O(n)$)".
    \item \textbf{Parla mentre scrivi:} "Ora inizializzo la mappa... qui scorro l'array...".
\end{enumerate}
\end{tcolorbox}

\section{Behavioral Interview: Il Metodo STAR}
Le domande comportamentali ("Parlami di una volta in cui hai avuto un conflitto con un collega") sono trappole. Se rispondi a caso, sembri disorganizzato o lamentoso.

Usa la struttura \textbf{S.T.A.R.}:

\begin{center}
\rowcolors{2}{gray!10}{white}
\begin{tabularx}{\textwidth}{|l|l|X|}
    \hline
    \rowcolor{deepblue} \textcolor{white}{\textbf{Fase}} & \textcolor{white}{\textbf{Significato}} & \textcolor{white}{\textbf{Esempio}} \\
    \hline
    \textbf{S - Situation} & Contesto & "Eravamo vicini al rilascio e il DB era lento." \\
    \hline
    \textbf{T - Task} & Obiettivo & "Dovevo ottimizzare la query senza rompere il report." \\
    \hline
    \textbf{A - Action} & Cosa HAI fatto & "Ho analizzato l'Explain Plan, ho visto un Full Table Scan e ho proposto di aggiungere un indice composito." (Usa "IO", non "NOI"). \\
    \hline
    \textbf{R - Result} & Risultato & "La query è passata da 5s a 200ms e il cliente è stato felice." (Usa numeri!). \\
    \hline
\end{tabularx}
\end{center}

\section{System Design: Niente Panico}
Se ti chiedono "Disegna un clone di Twitter", non iniziare a disegnare tabelle SQL. È un errore da Junior.
Segui questo flusso "Top-Down":

\begin{enumerate}
    \item \textbf{Requisiti Funzionali:} Cosa deve fare? (Postare tweet, seguire utenti).
    \item \textbf{Requisiti Non Funzionali:} Quanti utenti? (1M o 100M?). Alta disponibilità o Coerenza stretta? (CAP Theorem).
    \item \textbf{Design Alto Livello:} Disegna i blocchi grandi (Load Balancer, Web Server, Database, Cache).
    \item \textbf{Deep Dive:} "Il collo di bottiglia sarà la lettura della Timeline. Usiamo Redis per cachare i tweet degli utenti famosi".
\end{enumerate}

\section{Reverse Interviewing: Intervista l'Azienda}
Alla fine del colloquio chiedono sempre: "Hai domande per noi?".
Rispondere "No" è un segnale di disinteresse.
Fai domande che dimostrano che sei un professionista che tiene alla qualità del proprio lavoro.

\begin{deepdive}{Domande da fare (The Senior Checklist)}
\begin{itemize}
    \item \textbf{CI/CD:} "Quanto tempo passa dal commit al deploy in produzione?" (Se dicono "3 mesi", scappa).
    \item \textbf{Testing:} "Qual è la vostra copertura di test? Fate TDD?"
    \item \textbf{Tech Debt:} "Come gestite il debito tecnico? Avete sprint dedicati al refactoring?"
    \item \textbf{On-Call:} "C'è reperibilità notturna? Quante volte suona il telefono?" (Fondamentale per il work-life balance).
    \item \textbf{Team:} "Come è composto il team? Chi decide l'architettura?"
\end{itemize}
\end{deepdive}

\section{Red Flags: Quando scappare}
Il colloquio è bidirezionale. Loro valutano te, tu valuti loro.
Fai attenzione a questi segnali di pericolo:

\begin{itemize}
    \item \textbf{"Siamo una grande famiglia":} Traduzione: ci aspettiamo che tu faccia straordinari non pagati e non abbia confini tra vita e lavoro.
    \item \textbf{"Usiamo tecnologie proprietarie":} Traduzione: imparerai cose inutili fuori da qui e il tuo CV perderà valore.
    \item \textbf{"Il codice è auto-documentante":} Traduzione: non abbiamo documentazione e nessuno sa come funziona il sistema.
    \item \textbf{"Urgenza":} Se ti fanno un'offerta dopo 20 minuti di colloquio, sono disperati. Probabilmente il progetto è un incendio.
\end{itemize}

\section{Conclusione}
Sei arrivato alla fine di questo manuale.
Hai studiato le Collection, dominato i Thread, configurato Spring, ottimizzato Hibernate e imparato a gestire Kubernetes.

Ora hai tutte le carte in regola.
Ricorda: la tecnologia cambia, ma la curiosità e la capacità di imparare a fondo ("Under the Hood") non invecchiano mai.


\end{document}
